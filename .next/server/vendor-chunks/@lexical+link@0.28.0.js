"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+link@0.28.0";
exports.ids = ["vendor-chunks/@lexical+link@0.28.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@lexical+link@0.28.0/node_modules/@lexical/link/LexicalLink.dev.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+link@0.28.0/node_modules/@lexical/link/LexicalLink.dev.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createAutoLinkNode: () => (/* binding */ $createAutoLinkNode),\n/* harmony export */   $createLinkNode: () => (/* binding */ $createLinkNode),\n/* harmony export */   $isAutoLinkNode: () => (/* binding */ $isAutoLinkNode),\n/* harmony export */   $isLinkNode: () => (/* binding */ $isLinkNode),\n/* harmony export */   $toggleLink: () => (/* binding */ $toggleLink),\n/* harmony export */   AutoLinkNode: () => (/* binding */ AutoLinkNode),\n/* harmony export */   LinkNode: () => (/* binding */ LinkNode),\n/* harmony export */   TOGGLE_LINK_COMMAND: () => (/* binding */ TOGGLE_LINK_COMMAND),\n/* harmony export */   toggleLink: () => (/* binding */ toggleLink)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/.pnpm/@lexical+utils@0.28.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/.pnpm/lexical@0.28.0/node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url = '', attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    element.href = this.sanitizeUrl(this.__url);\n    if (this.__target !== null) {\n      element.target = this.__target;\n    }\n    if (this.__rel !== null) {\n      element.rel = this.__rel;\n    }\n    if (this.__title !== null) {\n      element.title = this.__title;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.link);\n    return element;\n  }\n  updateDOM(prevNode, anchor, config) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement)(anchor)) {\n      const url = this.__url;\n      const target = this.__target;\n      const rel = this.__rel;\n      const title = this.__title;\n      if (url !== prevNode.__url) {\n        anchor.href = url;\n      }\n      if (target !== prevNode.__target) {\n        if (target) {\n          anchor.target = target;\n        } else {\n          anchor.removeAttribute('target');\n        }\n      }\n      if (rel !== prevNode.__rel) {\n        if (rel) {\n          anchor.rel = rel;\n        } else {\n          anchor.removeAttribute('rel');\n        }\n      }\n      if (title !== prevNode.__title) {\n        if (title) {\n          anchor.title = title;\n        } else {\n          anchor.removeAttribute('title');\n        }\n      }\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: $convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);\n  }\n  sanitizeUrl(url) {\n    try {\n      const parsedUrl = new URL(url);\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      url: this.getURL()\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n    return writable;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n    return writable;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n    return writable;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n    return writable;\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n  isEmailURI() {\n    return this.__url.startsWith('mailto:');\n  }\n  isWebSiteURI() {\n    return this.__url.startsWith('https://') || this.__url.startsWith('http://');\n  }\n}\nfunction $convertAnchorElement(domNode) {\n  let node = null;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement)(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url = '', attributes) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  /** @internal */\n  /** Indicates whether the autolink was ever unlinked. **/\n\n  constructor(url = '', attributes = {}, key) {\n    super(url, attributes, key);\n    this.__isUnlinked = attributes.isUnlinked !== undefined && attributes.isUnlinked !== null ? attributes.isUnlinked : false;\n  }\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      isUnlinked: node.__isUnlinked,\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  getIsUnlinked() {\n    return this.__isUnlinked;\n  }\n  setIsUnlinked(value) {\n    const self = this.getWritable();\n    self.__isUnlinked = value;\n    return self;\n  }\n  createDOM(config) {\n    if (this.__isUnlinked) {\n      return document.createElement('span');\n    } else {\n      return super.createDOM(config);\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;\n  }\n  static importJSON(serializedNode) {\n    return $createAutoLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIsUnlinked(serializedNode.isUnlinked || false);\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      isUnlinked: this.__isUnlinked\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        isUnlinked: this.__isUnlinked,\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url = '', attributes) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('TOGGLE_LINK_COMMAND');\nfunction $getPointNode(point, offset) {\n  if (point.type === 'element') {\n    const node = point.getNode();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      formatDevErrorMessage(`$getPointNode: element point is not an ElementNode`);\n    }\n    const childNode = node.getChildren()[point.offset + offset];\n    return childNode || null;\n  }\n  return null;\n}\n\n/**\n * Preserve the logical start/end of a RangeSelection in situations where\n * the point is an element that may be reparented in the callback.\n *\n * @param $fn The function to run\n * @returns The result of the callback\n */\nfunction $withSelectedNodes($fn) {\n  const initialSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(initialSelection)) {\n    return $fn();\n  }\n  const normalized = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(initialSelection);\n  const isBackwards = normalized.isBackward();\n  const anchorNode = $getPointNode(normalized.anchor, isBackwards ? -1 : 0);\n  const focusNode = $getPointNode(normalized.focus, isBackwards ? 0 : -1);\n  const rval = $fn();\n  if (anchorNode || focusNode) {\n    const updatedSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(updatedSelection)) {\n      const finalSelection = updatedSelection.clone();\n      if (anchorNode) {\n        const anchorParent = anchorNode.getParent();\n        if (anchorParent) {\n          finalSelection.anchor.set(anchorParent.getKey(), anchorNode.getIndexWithinParent() + (isBackwards ? 1 : 0), 'element');\n        }\n      }\n      if (focusNode) {\n        const focusParent = focusNode.getParent();\n        if (focusParent) {\n          finalSelection.focus.set(focusParent.getKey(), focusNode.getIndexWithinParent() + (isBackwards ? 0 : 1), 'element');\n        }\n      }\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(finalSelection));\n    }\n  }\n  return rval;\n}\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n */\nfunction $toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    return;\n  }\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parentLink = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n      if (parentLink) {\n        const children = parentLink.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parentLink.insertBefore(children[i]);\n        }\n        parentLink.remove();\n      }\n    });\n    return;\n  }\n  const updatedNodes = new Set();\n  const updateLinkNode = linkNode => {\n    if (updatedNodes.has(linkNode.getKey())) {\n      return;\n    }\n    updatedNodes.add(linkNode.getKey());\n    linkNode.setURL(url);\n    if (target !== undefined) {\n      linkNode.setTarget(target);\n    }\n    if (rel !== undefined) {\n      linkNode.setRel(rel);\n    }\n    if (title !== undefined) {\n      linkNode.setTitle(title);\n    }\n  };\n  // Add or merge LinkNodes\n  if (nodes.length === 1) {\n    const firstNode = nodes[0];\n    // if the first node is a LinkNode or if its\n    // parent is a LinkNode, we update the URL, target and rel.\n    const linkNode = $getAncestor(firstNode, $isLinkNode);\n    if (linkNode !== null) {\n      return updateLinkNode(linkNode);\n    }\n  }\n  $withSelectedNodes(() => {\n    let linkNode = null;\n    for (const node of nodes) {\n      if (!node.isAttached()) {\n        continue;\n      }\n      const parentLinkNode = $getAncestor(node, $isLinkNode);\n      if (parentLinkNode) {\n        updateLinkNode(parentLinkNode);\n        continue;\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n        if (!node.isInline()) {\n          // Ignore block nodes, if there are any children we will see them\n          // later and wrap in a new LinkNode\n          continue;\n        }\n        if ($isLinkNode(node)) {\n          // If it's not an autolink node and we don't already have a LinkNode\n          // in this block then we can update it and re-use it\n          if (!$isAutoLinkNode(node) && (linkNode === null || !linkNode.getParentOrThrow().isParentOf(node))) {\n            updateLinkNode(node);\n            linkNode = node;\n            continue;\n          }\n          // Unwrap LinkNode, we already have one or it's an AutoLinkNode\n          for (const child of node.getChildren()) {\n            node.insertBefore(child);\n          }\n          node.remove();\n          continue;\n        }\n      }\n      const prevLinkNode = node.getPreviousSibling();\n      if ($isLinkNode(prevLinkNode) && prevLinkNode.is(linkNode)) {\n        prevLinkNode.append(node);\n        continue;\n      }\n      linkNode = $createLinkNode(url, {\n        rel,\n        target,\n        title\n      });\n      node.insertAfter(linkNode);\n      linkNode.append(node);\n    }\n  });\n}\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nconst toggleLink = $toggleLink;\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrbGlua0AwLjI4LjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2xpbmsvTGV4aWNhbExpbmsuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRztBQUM4RTs7QUFFaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCLGdEQUFXO0FBQ2xDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzRUFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0REFBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBcUI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFxQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdURBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzREFBYTtBQUN4QyxPQUFPLDBEQUFpQjtBQUN4QjtBQUNBO0FBQ0EscUJBQXFCLDBFQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNEQUFhO0FBQzFDLFFBQVEsMERBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxzREFBYSxDQUFDLDBFQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvQkFBb0Isc0RBQWE7QUFDakMsT0FBTywwREFBaUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1FQUFtQjtBQUM1QztBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdURBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0oiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaGFzaGlcXERlc2t0b3BcXGZ1c2lvbmlxeC1wcm9qZWN0c1xcZnVzaW9uaXF4XFxub2RlX21vZHVsZXNcXC5wbnBtXFxAbGV4aWNhbCtsaW5rQDAuMjguMFxcbm9kZV9tb2R1bGVzXFxAbGV4aWNhbFxcbGlua1xcTGV4aWNhbExpbmsuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsIGlzSFRNTEFuY2hvckVsZW1lbnQsICRmaW5kTWF0Y2hpbmdQYXJlbnQgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVDb21tYW5kLCBFbGVtZW50Tm9kZSwgJGlzUmFuZ2VTZWxlY3Rpb24sICRhcHBseU5vZGVSZXBsYWNlbWVudCwgJGlzRWxlbWVudE5vZGUsICRnZXRTZWxlY3Rpb24sICRub3JtYWxpemVTZWxlY3Rpb25fX0VYUEVSSU1FTlRBTCwgJHNldFNlbGVjdGlvbiB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzLlxuXG5mdW5jdGlvbiBmb3JtYXREZXZFcnJvck1lc3NhZ2UobWVzc2FnZSkge1xuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbmNvbnN0IFNVUFBPUlRFRF9VUkxfUFJPVE9DT0xTID0gbmV3IFNldChbJ2h0dHA6JywgJ2h0dHBzOicsICdtYWlsdG86JywgJ3NtczonLCAndGVsOiddKTtcblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpbmtOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdsaW5rJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgTGlua05vZGUobm9kZS5fX3VybCwge1xuICAgICAgcmVsOiBub2RlLl9fcmVsLFxuICAgICAgdGFyZ2V0OiBub2RlLl9fdGFyZ2V0LFxuICAgICAgdGl0bGU6IG5vZGUuX190aXRsZVxuICAgIH0sIG5vZGUuX19rZXkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHVybCA9ICcnLCBhdHRyaWJ1dGVzID0ge30sIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0ID0gbnVsbCxcbiAgICAgIHJlbCA9IG51bGwsXG4gICAgICB0aXRsZSA9IG51bGxcbiAgICB9ID0gYXR0cmlidXRlcztcbiAgICB0aGlzLl9fdXJsID0gdXJsO1xuICAgIHRoaXMuX190YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fX3JlbCA9IHJlbDtcbiAgICB0aGlzLl9fdGl0bGUgPSB0aXRsZTtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBlbGVtZW50LmhyZWYgPSB0aGlzLnNhbml0aXplVXJsKHRoaXMuX191cmwpO1xuICAgIGlmICh0aGlzLl9fdGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnRhcmdldCA9IHRoaXMuX190YXJnZXQ7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fcmVsICE9PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnJlbCA9IHRoaXMuX19yZWw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fdGl0bGUgIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnQudGl0bGUgPSB0aGlzLl9fdGl0bGU7XG4gICAgfVxuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLmxpbmspO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgYW5jaG9yLCBjb25maWcpIHtcbiAgICBpZiAoaXNIVE1MQW5jaG9yRWxlbWVudChhbmNob3IpKSB7XG4gICAgICBjb25zdCB1cmwgPSB0aGlzLl9fdXJsO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fX3RhcmdldDtcbiAgICAgIGNvbnN0IHJlbCA9IHRoaXMuX19yZWw7XG4gICAgICBjb25zdCB0aXRsZSA9IHRoaXMuX190aXRsZTtcbiAgICAgIGlmICh1cmwgIT09IHByZXZOb2RlLl9fdXJsKSB7XG4gICAgICAgIGFuY2hvci5ocmVmID0gdXJsO1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldCAhPT0gcHJldk5vZGUuX190YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIGFuY2hvci50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5jaG9yLnJlbW92ZUF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZWwgIT09IHByZXZOb2RlLl9fcmVsKSB7XG4gICAgICAgIGlmIChyZWwpIHtcbiAgICAgICAgICBhbmNob3IucmVsID0gcmVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuY2hvci5yZW1vdmVBdHRyaWJ1dGUoJ3JlbCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGl0bGUgIT09IHByZXZOb2RlLl9fdGl0bGUpIHtcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgYW5jaG9yLnRpdGxlID0gdGl0bGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5jaG9yLnJlbW92ZUF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYTogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEFuY2hvckVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAxXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUxpbmtOb2RlKCkudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRVUkwoc2VyaWFsaXplZE5vZGUudXJsKS5zZXRSZWwoc2VyaWFsaXplZE5vZGUucmVsIHx8IG51bGwpLnNldFRhcmdldChzZXJpYWxpemVkTm9kZS50YXJnZXQgfHwgbnVsbCkuc2V0VGl0bGUoc2VyaWFsaXplZE5vZGUudGl0bGUgfHwgbnVsbCk7XG4gIH1cbiAgc2FuaXRpemVVcmwodXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zY3JpcHQtdXJsXG4gICAgICBpZiAoIVNVUFBPUlRFRF9VUkxfUFJPVE9DT0xTLmhhcyhwYXJzZWRVcmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHJldHVybiAnYWJvdXQ6YmxhbmsnO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgcmVsOiB0aGlzLmdldFJlbCgpLFxuICAgICAgdGFyZ2V0OiB0aGlzLmdldFRhcmdldCgpLFxuICAgICAgdGl0bGU6IHRoaXMuZ2V0VGl0bGUoKSxcbiAgICAgIHVybDogdGhpcy5nZXRVUkwoKVxuICAgIH07XG4gIH1cbiAgZ2V0VVJMKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fdXJsO1xuICB9XG4gIHNldFVSTCh1cmwpIHtcbiAgICBjb25zdCB3cml0YWJsZSA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICB3cml0YWJsZS5fX3VybCA9IHVybDtcbiAgICByZXR1cm4gd3JpdGFibGU7XG4gIH1cbiAgZ2V0VGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fdGFyZ2V0O1xuICB9XG4gIHNldFRhcmdldCh0YXJnZXQpIHtcbiAgICBjb25zdCB3cml0YWJsZSA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICB3cml0YWJsZS5fX3RhcmdldCA9IHRhcmdldDtcbiAgICByZXR1cm4gd3JpdGFibGU7XG4gIH1cbiAgZ2V0UmVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fcmVsO1xuICB9XG4gIHNldFJlbChyZWwpIHtcbiAgICBjb25zdCB3cml0YWJsZSA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICB3cml0YWJsZS5fX3JlbCA9IHJlbDtcbiAgICByZXR1cm4gd3JpdGFibGU7XG4gIH1cbiAgZ2V0VGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX190aXRsZTtcbiAgfVxuICBzZXRUaXRsZSh0aXRsZSkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fdGl0bGUgPSB0aXRsZTtcbiAgICByZXR1cm4gd3JpdGFibGU7XG4gIH1cbiAgaW5zZXJ0TmV3QWZ0ZXIoXywgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBsaW5rTm9kZSA9ICRjcmVhdGVMaW5rTm9kZSh0aGlzLl9fdXJsLCB7XG4gICAgICByZWw6IHRoaXMuX19yZWwsXG4gICAgICB0YXJnZXQ6IHRoaXMuX190YXJnZXQsXG4gICAgICB0aXRsZTogdGhpcy5fX3RpdGxlXG4gICAgfSk7XG4gICAgdGhpcy5pbnNlcnRBZnRlcihsaW5rTm9kZSwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgcmV0dXJuIGxpbmtOb2RlO1xuICB9XG4gIGNhbkluc2VydFRleHRCZWZvcmUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhbkluc2VydFRleHRBZnRlcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZXh0cmFjdFdpdGhDaGlsZChjaGlsZCwgc2VsZWN0aW9uLCBkZXN0aW5hdGlvbikge1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgICByZXR1cm4gdGhpcy5pc1BhcmVudE9mKGFuY2hvck5vZGUpICYmIHRoaXMuaXNQYXJlbnRPZihmb2N1c05vZGUpICYmIHNlbGVjdGlvbi5nZXRUZXh0Q29udGVudCgpLmxlbmd0aCA+IDA7XG4gIH1cbiAgaXNFbWFpbFVSSSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3VybC5zdGFydHNXaXRoKCdtYWlsdG86Jyk7XG4gIH1cbiAgaXNXZWJTaXRlVVJJKCkge1xuICAgIHJldHVybiB0aGlzLl9fdXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykgfHwgdGhpcy5fX3VybC5zdGFydHNXaXRoKCdodHRwOi8vJyk7XG4gIH1cbn1cbmZ1bmN0aW9uICRjb252ZXJ0QW5jaG9yRWxlbWVudChkb21Ob2RlKSB7XG4gIGxldCBub2RlID0gbnVsbDtcbiAgaWYgKGlzSFRNTEFuY2hvckVsZW1lbnQoZG9tTm9kZSkpIHtcbiAgICBjb25zdCBjb250ZW50ID0gZG9tTm9kZS50ZXh0Q29udGVudDtcbiAgICBpZiAoY29udGVudCAhPT0gbnVsbCAmJiBjb250ZW50ICE9PSAnJyB8fCBkb21Ob2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIG5vZGUgPSAkY3JlYXRlTGlua05vZGUoZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSB8fCAnJywge1xuICAgICAgICByZWw6IGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdyZWwnKSxcbiAgICAgICAgdGFyZ2V0OiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgndGFyZ2V0JyksXG4gICAgICAgIHRpdGxlOiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgndGl0bGUnKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbm9kZVxuICB9O1xufVxuXG4vKipcbiAqIFRha2VzIGEgVVJMIGFuZCBjcmVhdGVzIGEgTGlua05vZGUuXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0aGUgTGlua05vZGUgc2hvdWxkIGRpcmVjdCB0by5cbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIC0gT3B0aW9uYWwgSFRNTCBhIHRhZyBhdHRyaWJ1dGVzIFxcXFx7IHRhcmdldCwgcmVsLCB0aXRsZSBcXFxcfVxuICogQHJldHVybnMgVGhlIExpbmtOb2RlLlxuICovXG5mdW5jdGlvbiAkY3JlYXRlTGlua05vZGUodXJsID0gJycsIGF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgTGlua05vZGUodXJsLCBhdHRyaWJ1dGVzKSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBub2RlIGlzIGEgTGlua05vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIG5vZGUgaXMgYSBMaW5rTm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNMaW5rTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgTGlua05vZGU7XG59XG4vLyBDdXN0b20gbm9kZSB0eXBlIHRvIG92ZXJyaWRlIGBjYW5JbnNlcnRUZXh0QWZ0ZXJgIHRoYXQgd2lsbFxuLy8gYWxsb3cgdHlwaW5nIHdpdGhpbiB0aGUgbGlua1xuY2xhc3MgQXV0b0xpbmtOb2RlIGV4dGVuZHMgTGlua05vZGUge1xuICAvKiogQGludGVybmFsICovXG4gIC8qKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYXV0b2xpbmsgd2FzIGV2ZXIgdW5saW5rZWQuICoqL1xuXG4gIGNvbnN0cnVjdG9yKHVybCA9ICcnLCBhdHRyaWJ1dGVzID0ge30sIGtleSkge1xuICAgIHN1cGVyKHVybCwgYXR0cmlidXRlcywga2V5KTtcbiAgICB0aGlzLl9faXNVbmxpbmtlZCA9IGF0dHJpYnV0ZXMuaXNVbmxpbmtlZCAhPT0gdW5kZWZpbmVkICYmIGF0dHJpYnV0ZXMuaXNVbmxpbmtlZCAhPT0gbnVsbCA/IGF0dHJpYnV0ZXMuaXNVbmxpbmtlZCA6IGZhbHNlO1xuICB9XG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnYXV0b2xpbmsnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBBdXRvTGlua05vZGUobm9kZS5fX3VybCwge1xuICAgICAgaXNVbmxpbmtlZDogbm9kZS5fX2lzVW5saW5rZWQsXG4gICAgICByZWw6IG5vZGUuX19yZWwsXG4gICAgICB0YXJnZXQ6IG5vZGUuX190YXJnZXQsXG4gICAgICB0aXRsZTogbm9kZS5fX3RpdGxlXG4gICAgfSwgbm9kZS5fX2tleSk7XG4gIH1cbiAgZ2V0SXNVbmxpbmtlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2lzVW5saW5rZWQ7XG4gIH1cbiAgc2V0SXNVbmxpbmtlZCh2YWx1ZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2lzVW5saW5rZWQgPSB2YWx1ZTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgaWYgKHRoaXMuX19pc1VubGlua2VkKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIuY3JlYXRlRE9NKGNvbmZpZyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgYW5jaG9yLCBjb25maWcpIHtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlRE9NKHByZXZOb2RlLCBhbmNob3IsIGNvbmZpZykgfHwgcHJldk5vZGUuX19pc1VubGlua2VkICE9PSB0aGlzLl9faXNVbmxpbmtlZDtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlQXV0b0xpbmtOb2RlKCkudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRJc1VubGlua2VkKHNlcmlhbGl6ZWROb2RlLmlzVW5saW5rZWQgfHwgZmFsc2UpO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgLy8gVE9ETzogU2hvdWxkIGxpbmsgbm9kZSBzaG91bGQgaGFuZGxlIHRoZSBpbXBvcnQgb3ZlciBhdXRvbGluaz9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBpc1VubGlua2VkOiB0aGlzLl9faXNVbmxpbmtlZFxuICAgIH07XG4gIH1cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5pbnNlcnROZXdBZnRlcihzZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShlbGVtZW50KSkge1xuICAgICAgY29uc3QgbGlua05vZGUgPSAkY3JlYXRlQXV0b0xpbmtOb2RlKHRoaXMuX191cmwsIHtcbiAgICAgICAgaXNVbmxpbmtlZDogdGhpcy5fX2lzVW5saW5rZWQsXG4gICAgICAgIHJlbDogdGhpcy5fX3JlbCxcbiAgICAgICAgdGFyZ2V0OiB0aGlzLl9fdGFyZ2V0LFxuICAgICAgICB0aXRsZTogdGhpcy5fX3RpdGxlXG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuYXBwZW5kKGxpbmtOb2RlKTtcbiAgICAgIHJldHVybiBsaW5rTm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBhIFVSTCBhbmQgY3JlYXRlcyBhbiBBdXRvTGlua05vZGUuIEF1dG9MaW5rTm9kZXMgYXJlIGdlbmVyYWxseSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZFxuICogZHVyaW5nIHR5cGluZywgd2hpY2ggaXMgZXNwZWNpYWxseSB1c2VmdWwgd2hlbiBhIGJ1dHRvbiB0byBnZW5lcmF0ZSBhIExpbmtOb2RlIGlzIG5vdCBwcmFjdGljYWwuXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0aGUgTGlua05vZGUgc2hvdWxkIGRpcmVjdCB0by5cbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIC0gT3B0aW9uYWwgSFRNTCBhIHRhZyBhdHRyaWJ1dGVzLiBcXFxceyB0YXJnZXQsIHJlbCwgdGl0bGUgXFxcXH1cbiAqIEByZXR1cm5zIFRoZSBMaW5rTm9kZS5cbiAqL1xuZnVuY3Rpb24gJGNyZWF0ZUF1dG9MaW5rTm9kZSh1cmwgPSAnJywgYXR0cmlidXRlcykge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBBdXRvTGlua05vZGUodXJsLCBhdHRyaWJ1dGVzKSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBub2RlIGlzIGFuIEF1dG9MaW5rTm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIHRydWUgaWYgbm9kZSBpcyBhbiBBdXRvTGlua05vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGlzQXV0b0xpbmtOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBBdXRvTGlua05vZGU7XG59XG5jb25zdCBUT0dHTEVfTElOS19DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnVE9HR0xFX0xJTktfQ09NTUFORCcpO1xuZnVuY3Rpb24gJGdldFBvaW50Tm9kZShwb2ludCwgb2Zmc2V0KSB7XG4gIGlmIChwb2ludC50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICBjb25zdCBub2RlID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGlmICghJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGdldFBvaW50Tm9kZTogZWxlbWVudCBwb2ludCBpcyBub3QgYW4gRWxlbWVudE5vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGROb2RlID0gbm9kZS5nZXRDaGlsZHJlbigpW3BvaW50Lm9mZnNldCArIG9mZnNldF07XG4gICAgcmV0dXJuIGNoaWxkTm9kZSB8fCBudWxsO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFByZXNlcnZlIHRoZSBsb2dpY2FsIHN0YXJ0L2VuZCBvZiBhIFJhbmdlU2VsZWN0aW9uIGluIHNpdHVhdGlvbnMgd2hlcmVcbiAqIHRoZSBwb2ludCBpcyBhbiBlbGVtZW50IHRoYXQgbWF5IGJlIHJlcGFyZW50ZWQgaW4gdGhlIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSAkZm4gVGhlIGZ1bmN0aW9uIHRvIHJ1blxuICogQHJldHVybnMgVGhlIHJlc3VsdCBvZiB0aGUgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gJHdpdGhTZWxlY3RlZE5vZGVzKCRmbikge1xuICBjb25zdCBpbml0aWFsU2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKGluaXRpYWxTZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuICRmbigpO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSAkbm9ybWFsaXplU2VsZWN0aW9uX19FWFBFUklNRU5UQUwoaW5pdGlhbFNlbGVjdGlvbik7XG4gIGNvbnN0IGlzQmFja3dhcmRzID0gbm9ybWFsaXplZC5pc0JhY2t3YXJkKCk7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSAkZ2V0UG9pbnROb2RlKG5vcm1hbGl6ZWQuYW5jaG9yLCBpc0JhY2t3YXJkcyA/IC0xIDogMCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9ICRnZXRQb2ludE5vZGUobm9ybWFsaXplZC5mb2N1cywgaXNCYWNrd2FyZHMgPyAwIDogLTEpO1xuICBjb25zdCBydmFsID0gJGZuKCk7XG4gIGlmIChhbmNob3JOb2RlIHx8IGZvY3VzTm9kZSkge1xuICAgIGNvbnN0IHVwZGF0ZWRTZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHVwZGF0ZWRTZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBmaW5hbFNlbGVjdGlvbiA9IHVwZGF0ZWRTZWxlY3Rpb24uY2xvbmUoKTtcbiAgICAgIGlmIChhbmNob3JOb2RlKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvclBhcmVudCA9IGFuY2hvck5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmIChhbmNob3JQYXJlbnQpIHtcbiAgICAgICAgICBmaW5hbFNlbGVjdGlvbi5hbmNob3Iuc2V0KGFuY2hvclBhcmVudC5nZXRLZXkoKSwgYW5jaG9yTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgKGlzQmFja3dhcmRzID8gMSA6IDApLCAnZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm9jdXNOb2RlKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzUGFyZW50ID0gZm9jdXNOb2RlLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoZm9jdXNQYXJlbnQpIHtcbiAgICAgICAgICBmaW5hbFNlbGVjdGlvbi5mb2N1cy5zZXQoZm9jdXNQYXJlbnQuZ2V0S2V5KCksIGZvY3VzTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgKGlzQmFja3dhcmRzID8gMCA6IDEpLCAnZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAkc2V0U2VsZWN0aW9uKCRub3JtYWxpemVTZWxlY3Rpb25fX0VYUEVSSU1FTlRBTChmaW5hbFNlbGVjdGlvbikpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgb3IgdXBkYXRlcyBhIExpbmtOb2RlLiBJdCBjYW4gYWxzbyBkZWxldGUgYSBMaW5rTm9kZSBpZiB0aGUgVVJMIGlzIG51bGwsXG4gKiBidXQgc2F2ZXMgYW55IGNoaWxkcmVuIGFuZCBicmluZ3MgdGhlbSB1cCB0byB0aGUgcGFyZW50IG5vZGUuXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0aGUgbGluayBkaXJlY3RzIHRvLlxuICogQHBhcmFtIGF0dHJpYnV0ZXMgLSBPcHRpb25hbCBIVE1MIGEgdGFnIGF0dHJpYnV0ZXMuIFxcXFx7IHRhcmdldCwgcmVsLCB0aXRsZSBcXFxcfVxuICovXG5mdW5jdGlvbiAkdG9nZ2xlTGluayh1cmwsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdGFyZ2V0LFxuICAgIHRpdGxlXG4gIH0gPSBhdHRyaWJ1dGVzO1xuICBjb25zdCByZWwgPSBhdHRyaWJ1dGVzLnJlbCA9PT0gdW5kZWZpbmVkID8gJ25vcmVmZXJyZXInIDogYXR0cmlidXRlcy5yZWw7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmV4dHJhY3QoKTtcbiAgaWYgKHVybCA9PT0gbnVsbCkge1xuICAgIC8vIFJlbW92ZSBMaW5rTm9kZXNcbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgY29uc3QgcGFyZW50TGluayA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgcGFyZW50ID0+ICEkaXNBdXRvTGlua05vZGUocGFyZW50KSAmJiAkaXNMaW5rTm9kZShwYXJlbnQpKTtcbiAgICAgIGlmIChwYXJlbnRMaW5rKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50TGluay5nZXRDaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcGFyZW50TGluay5pbnNlcnRCZWZvcmUoY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudExpbmsucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgdXBkYXRlTGlua05vZGUgPSBsaW5rTm9kZSA9PiB7XG4gICAgaWYgKHVwZGF0ZWROb2Rlcy5oYXMobGlua05vZGUuZ2V0S2V5KCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHVwZGF0ZWROb2Rlcy5hZGQobGlua05vZGUuZ2V0S2V5KCkpO1xuICAgIGxpbmtOb2RlLnNldFVSTCh1cmwpO1xuICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGlua05vZGUuc2V0VGFyZ2V0KHRhcmdldCk7XG4gICAgfVxuICAgIGlmIChyZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGlua05vZGUuc2V0UmVsKHJlbCk7XG4gICAgfVxuICAgIGlmICh0aXRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsaW5rTm9kZS5zZXRUaXRsZSh0aXRsZSk7XG4gICAgfVxuICB9O1xuICAvLyBBZGQgb3IgbWVyZ2UgTGlua05vZGVzXG4gIGlmIChub2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBmaXJzdE5vZGUgPSBub2Rlc1swXTtcbiAgICAvLyBpZiB0aGUgZmlyc3Qgbm9kZSBpcyBhIExpbmtOb2RlIG9yIGlmIGl0c1xuICAgIC8vIHBhcmVudCBpcyBhIExpbmtOb2RlLCB3ZSB1cGRhdGUgdGhlIFVSTCwgdGFyZ2V0IGFuZCByZWwuXG4gICAgY29uc3QgbGlua05vZGUgPSAkZ2V0QW5jZXN0b3IoZmlyc3ROb2RlLCAkaXNMaW5rTm9kZSk7XG4gICAgaWYgKGxpbmtOb2RlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdXBkYXRlTGlua05vZGUobGlua05vZGUpO1xuICAgIH1cbiAgfVxuICAkd2l0aFNlbGVjdGVkTm9kZXMoKCkgPT4ge1xuICAgIGxldCBsaW5rTm9kZSA9IG51bGw7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICBpZiAoIW5vZGUuaXNBdHRhY2hlZCgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50TGlua05vZGUgPSAkZ2V0QW5jZXN0b3Iobm9kZSwgJGlzTGlua05vZGUpO1xuICAgICAgaWYgKHBhcmVudExpbmtOb2RlKSB7XG4gICAgICAgIHVwZGF0ZUxpbmtOb2RlKHBhcmVudExpbmtOb2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgICAgaWYgKCFub2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYmxvY2sgbm9kZXMsIGlmIHRoZXJlIGFyZSBhbnkgY2hpbGRyZW4gd2Ugd2lsbCBzZWUgdGhlbVxuICAgICAgICAgIC8vIGxhdGVyIGFuZCB3cmFwIGluIGEgbmV3IExpbmtOb2RlXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRpc0xpbmtOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgLy8gSWYgaXQncyBub3QgYW4gYXV0b2xpbmsgbm9kZSBhbmQgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGEgTGlua05vZGVcbiAgICAgICAgICAvLyBpbiB0aGlzIGJsb2NrIHRoZW4gd2UgY2FuIHVwZGF0ZSBpdCBhbmQgcmUtdXNlIGl0XG4gICAgICAgICAgaWYgKCEkaXNBdXRvTGlua05vZGUobm9kZSkgJiYgKGxpbmtOb2RlID09PSBudWxsIHx8ICFsaW5rTm9kZS5nZXRQYXJlbnRPclRocm93KCkuaXNQYXJlbnRPZihub2RlKSkpIHtcbiAgICAgICAgICAgIHVwZGF0ZUxpbmtOb2RlKG5vZGUpO1xuICAgICAgICAgICAgbGlua05vZGUgPSBub2RlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVud3JhcCBMaW5rTm9kZSwgd2UgYWxyZWFkeSBoYXZlIG9uZSBvciBpdCdzIGFuIEF1dG9MaW5rTm9kZVxuICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5nZXRDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICBub2RlLmluc2VydEJlZm9yZShjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZMaW5rTm9kZSA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAoJGlzTGlua05vZGUocHJldkxpbmtOb2RlKSAmJiBwcmV2TGlua05vZGUuaXMobGlua05vZGUpKSB7XG4gICAgICAgIHByZXZMaW5rTm9kZS5hcHBlbmQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGlua05vZGUgPSAkY3JlYXRlTGlua05vZGUodXJsLCB7XG4gICAgICAgIHJlbCxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0aXRsZVxuICAgICAgfSk7XG4gICAgICBub2RlLmluc2VydEFmdGVyKGxpbmtOb2RlKTtcbiAgICAgIGxpbmtOb2RlLmFwcGVuZChub2RlKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8ge0BsaW5rICR0b2dnbGVMaW5rfSBieSBAbGV4aWNhbC9lc2xpbnQtcGx1Z2luIHJ1bGVzLW9mLWxleGljYWwgKi9cbmNvbnN0IHRvZ2dsZUxpbmsgPSAkdG9nZ2xlTGluaztcbmZ1bmN0aW9uICRnZXRBbmNlc3Rvcihub2RlLCBwcmVkaWNhdGUpIHtcbiAgbGV0IHBhcmVudCA9IG5vZGU7XG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50LmdldFBhcmVudCgpICE9PSBudWxsICYmICFwcmVkaWNhdGUocGFyZW50KSkge1xuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cbiAgcmV0dXJuIHByZWRpY2F0ZShwYXJlbnQpID8gcGFyZW50IDogbnVsbDtcbn1cblxuZXhwb3J0IHsgJGNyZWF0ZUF1dG9MaW5rTm9kZSwgJGNyZWF0ZUxpbmtOb2RlLCAkaXNBdXRvTGlua05vZGUsICRpc0xpbmtOb2RlLCAkdG9nZ2xlTGluaywgQXV0b0xpbmtOb2RlLCBMaW5rTm9kZSwgVE9HR0xFX0xJTktfQ09NTUFORCwgdG9nZ2xlTGluayB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lexical+link@0.28.0/node_modules/@lexical/link/LexicalLink.dev.mjs\n");

/***/ })

};
;