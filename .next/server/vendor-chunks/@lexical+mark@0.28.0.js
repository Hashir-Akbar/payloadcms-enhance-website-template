"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+mark@0.28.0";
exports.ids = ["vendor-chunks/@lexical+mark@0.28.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@lexical+mark@0.28.0/node_modules/@lexical/mark/LexicalMark.dev.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+mark@0.28.0/node_modules/@lexical/mark/LexicalMark.dev.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createMarkNode: () => (/* binding */ $createMarkNode),\n/* harmony export */   $getMarkIDs: () => (/* binding */ $getMarkIDs),\n/* harmony export */   $isMarkNode: () => (/* binding */ $isMarkNode),\n/* harmony export */   $unwrapMarkNode: () => (/* binding */ $unwrapMarkNode),\n/* harmony export */   $wrapSelectionInMarkNode: () => (/* binding */ $wrapSelectionInMarkNode),\n/* harmony export */   MarkNode: () => (/* binding */ MarkNode)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/.pnpm/lexical@0.28.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/.pnpm/@lexical+utils@0.28.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst NO_IDS = [];\n\n/** @noInheritDoc */\nclass MarkNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'mark';\n  }\n  static clone(node) {\n    return new MarkNode(node.__ids, node.__key);\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedNode) {\n    return $createMarkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIDs(serializedNode.ids);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ids: this.getIDs()\n    };\n  }\n  constructor(ids = NO_IDS, key) {\n    super(key);\n    this.__ids = ids;\n  }\n  createDOM(config) {\n    const element = document.createElement('mark');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.mark);\n    if (this.__ids.length > 1) {\n      (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.markOverlap);\n    }\n    return element;\n  }\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(element, overlapTheme);\n      }\n    }\n    return false;\n  }\n  hasID(id) {\n    return this.getIDs().includes(id);\n  }\n  getIDs() {\n    return Array.from(this.getLatest().__ids);\n  }\n  setIDs(ids) {\n    const self = this.getWritable();\n    self.__ids = ids;\n    return self;\n  }\n  addID(id) {\n    const self = this.getWritable();\n    return self.__ids.includes(id) ? self : self.setIDs([...self.__ids, id]);\n  }\n  deleteID(id) {\n    const self = this.getWritable();\n    const idx = self.__ids.indexOf(id);\n    if (idx === -1) {\n      return self;\n    }\n    const ids = Array.from(self.__ids);\n    ids.splice(idx, 1);\n    return self.setIDs(ids);\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const markNode = $createMarkNode(this.__ids);\n    this.insertAfter(markNode, restoreSelection);\n    return markNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || destination === 'html') {\n      return false;\n    }\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n}\nfunction $createMarkNode(ids = NO_IDS) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new MarkNode(ids));\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n    target = child;\n  }\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {\n  // Force a forwards selection since append is used, ignore the argument.\n  // A new selection is used to avoid side-effects of flipping the given\n  // selection\n  const forwardSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n  const [startPoint, endPoint] = selection.isBackward() ? [selection.focus, selection.anchor] : [selection.anchor, selection.focus];\n  forwardSelection.anchor.set(startPoint.key, startPoint.offset, startPoint.type);\n  forwardSelection.focus.set(endPoint.key, endPoint.offset, endPoint.type);\n  let currentNodeParent;\n  let lastCreatedMarkNode;\n\n  // Note that extract will split text nodes at the boundaries\n  const nodes = forwardSelection.extract();\n  // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n  for (const node of nodes) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n    let targetNode = null;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      // Case 1: The node is a text node and we can include it\n      targetNode = node;\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may utlimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n      continue;\n    } else if (((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node)) && node.isInline()) {\n      // Case 3: inline element/decorator nodes can be added in their entirety\n      // to the new mark\n      targetNode = node;\n    }\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n      const parentNode = targetNode.getParent();\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n      currentNodeParent = parentNode;\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        const createMarkNode = createNode || $createMarkNode;\n        lastCreatedMarkNode = createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      }\n\n      // Add the target node to be wrapped in the latest created mark node\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  }\n  // Make selection collapsed at the end\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lastCreatedMarkNode)) {\n    // eslint-disable-next-line no-unused-expressions\n    isBackward ? lastCreatedMarkNode.selectStart() : lastCreatedMarkNode.selectEnd();\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n    currentNode = currentNode.getParent();\n  }\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrbWFya0AwLjI4LjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL21hcmsvTGV4aWNhbE1hcmsuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzSjtBQUNqRTs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsZ0RBQVc7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzRUFBc0I7QUFDMUI7QUFDQSxNQUFNLHNFQUFzQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNFQUFzQjtBQUNoQztBQUNBLFFBQVE7QUFDUixRQUFRLDJFQUEyQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOERBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBVztBQUNuQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sVUFBVSx1REFBYyxVQUFVLHlEQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsb0RBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwRyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxoYXNoaVxcRGVza3RvcFxcZnVzaW9uaXF4LXByb2plY3RzXFxmdXNpb25pcXhcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBsZXhpY2FsK21hcmtAMC4yOC4wXFxub2RlX21vZHVsZXNcXEBsZXhpY2FsXFxtYXJrXFxMZXhpY2FsTWFyay5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgRWxlbWVudE5vZGUsICRpc1JhbmdlU2VsZWN0aW9uLCAkYXBwbHlOb2RlUmVwbGFjZW1lbnQsICRjcmVhdGVSYW5nZVNlbGVjdGlvbiwgJGlzRWxlbWVudE5vZGUsICRpc1RleHROb2RlLCAkaXNEZWNvcmF0b3JOb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5pbXBvcnQgeyBhZGRDbGFzc05hbWVzVG9FbGVtZW50LCByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgTk9fSURTID0gW107XG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBNYXJrTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnbWFyayc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtOb2RlKG5vZGUuX19pZHMsIG5vZGUuX19rZXkpO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZU1hcmtOb2RlKCkudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRJRHMoc2VyaWFsaXplZE5vZGUuaWRzKTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBpZHM6IHRoaXMuZ2V0SURzKClcbiAgICB9O1xuICB9XG4gIGNvbnN0cnVjdG9yKGlkcyA9IE5PX0lEUywga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9faWRzID0gaWRzO1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbWFyaycpO1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLm1hcmspO1xuICAgIGlmICh0aGlzLl9faWRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLm1hcmtPdmVybGFwKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBlbGVtZW50LCBjb25maWcpIHtcbiAgICBjb25zdCBwcmV2SURzID0gcHJldk5vZGUuX19pZHM7XG4gICAgY29uc3QgbmV4dElEcyA9IHRoaXMuX19pZHM7XG4gICAgY29uc3QgcHJldklEc0NvdW50ID0gcHJldklEcy5sZW5ndGg7XG4gICAgY29uc3QgbmV4dElEc0NvdW50ID0gbmV4dElEcy5sZW5ndGg7XG4gICAgY29uc3Qgb3ZlcmxhcFRoZW1lID0gY29uZmlnLnRoZW1lLm1hcmtPdmVybGFwO1xuICAgIGlmIChwcmV2SURzQ291bnQgIT09IG5leHRJRHNDb3VudCkge1xuICAgICAgaWYgKHByZXZJRHNDb3VudCA9PT0gMSkge1xuICAgICAgICBpZiAobmV4dElEc0NvdW50ID09PSAyKSB7XG4gICAgICAgICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBvdmVybGFwVGhlbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5leHRJRHNDb3VudCA9PT0gMSkge1xuICAgICAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZWxlbWVudCwgb3ZlcmxhcFRoZW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGhhc0lEKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SURzKCkuaW5jbHVkZXMoaWQpO1xuICB9XG4gIGdldElEcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmdldExhdGVzdCgpLl9faWRzKTtcbiAgfVxuICBzZXRJRHMoaWRzKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9faWRzID0gaWRzO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGFkZElEKGlkKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICByZXR1cm4gc2VsZi5fX2lkcy5pbmNsdWRlcyhpZCkgPyBzZWxmIDogc2VsZi5zZXRJRHMoWy4uLnNlbGYuX19pZHMsIGlkXSk7XG4gIH1cbiAgZGVsZXRlSUQoaWQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IGlkeCA9IHNlbGYuX19pZHMuaW5kZXhPZihpZCk7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBjb25zdCBpZHMgPSBBcnJheS5mcm9tKHNlbGYuX19pZHMpO1xuICAgIGlkcy5zcGxpY2UoaWR4LCAxKTtcbiAgICByZXR1cm4gc2VsZi5zZXRJRHMoaWRzKTtcbiAgfVxuICBpbnNlcnROZXdBZnRlcihzZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgbWFya05vZGUgPSAkY3JlYXRlTWFya05vZGUodGhpcy5fX2lkcyk7XG4gICAgdGhpcy5pbnNlcnRBZnRlcihtYXJrTm9kZSwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgcmV0dXJuIG1hcmtOb2RlO1xuICB9XG4gIGNhbkluc2VydFRleHRCZWZvcmUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhbkluc2VydFRleHRBZnRlcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZXh0cmFjdFdpdGhDaGlsZChjaGlsZCwgc2VsZWN0aW9uLCBkZXN0aW5hdGlvbikge1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBkZXN0aW5hdGlvbiA9PT0gJ2h0bWwnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGlzQmFja3dhcmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpO1xuICAgIGNvbnN0IHNlbGVjdGlvbkxlbmd0aCA9IGlzQmFja3dhcmQgPyBhbmNob3Iub2Zmc2V0IC0gZm9jdXMub2Zmc2V0IDogZm9jdXMub2Zmc2V0IC0gYW5jaG9yLm9mZnNldDtcbiAgICByZXR1cm4gdGhpcy5pc1BhcmVudE9mKGFuY2hvck5vZGUpICYmIHRoaXMuaXNQYXJlbnRPZihmb2N1c05vZGUpICYmIHRoaXMuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGggPT09IHNlbGVjdGlvbkxlbmd0aDtcbiAgfVxuICBleGNsdWRlRnJvbUNvcHkoZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gZGVzdGluYXRpb24gIT09ICdjbG9uZSc7XG4gIH1cbn1cbmZ1bmN0aW9uICRjcmVhdGVNYXJrTm9kZShpZHMgPSBOT19JRFMpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgTWFya05vZGUoaWRzKSk7XG59XG5mdW5jdGlvbiAkaXNNYXJrTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgTWFya05vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gJHVud3JhcE1hcmtOb2RlKG5vZGUpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gIGxldCB0YXJnZXQgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICBub2RlLmluc2VydEJlZm9yZShjaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5pbnNlcnRBZnRlcihjaGlsZCk7XG4gICAgfVxuICAgIHRhcmdldCA9IGNoaWxkO1xuICB9XG4gIG5vZGUucmVtb3ZlKCk7XG59XG5mdW5jdGlvbiAkd3JhcFNlbGVjdGlvbkluTWFya05vZGUoc2VsZWN0aW9uLCBpc0JhY2t3YXJkLCBpZCwgY3JlYXRlTm9kZSkge1xuICAvLyBGb3JjZSBhIGZvcndhcmRzIHNlbGVjdGlvbiBzaW5jZSBhcHBlbmQgaXMgdXNlZCwgaWdub3JlIHRoZSBhcmd1bWVudC5cbiAgLy8gQSBuZXcgc2VsZWN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgc2lkZS1lZmZlY3RzIG9mIGZsaXBwaW5nIHRoZSBnaXZlblxuICAvLyBzZWxlY3Rpb25cbiAgY29uc3QgZm9yd2FyZFNlbGVjdGlvbiA9ICRjcmVhdGVSYW5nZVNlbGVjdGlvbigpO1xuICBjb25zdCBbc3RhcnRQb2ludCwgZW5kUG9pbnRdID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKSA/IFtzZWxlY3Rpb24uZm9jdXMsIHNlbGVjdGlvbi5hbmNob3JdIDogW3NlbGVjdGlvbi5hbmNob3IsIHNlbGVjdGlvbi5mb2N1c107XG4gIGZvcndhcmRTZWxlY3Rpb24uYW5jaG9yLnNldChzdGFydFBvaW50LmtleSwgc3RhcnRQb2ludC5vZmZzZXQsIHN0YXJ0UG9pbnQudHlwZSk7XG4gIGZvcndhcmRTZWxlY3Rpb24uZm9jdXMuc2V0KGVuZFBvaW50LmtleSwgZW5kUG9pbnQub2Zmc2V0LCBlbmRQb2ludC50eXBlKTtcbiAgbGV0IGN1cnJlbnROb2RlUGFyZW50O1xuICBsZXQgbGFzdENyZWF0ZWRNYXJrTm9kZTtcblxuICAvLyBOb3RlIHRoYXQgZXh0cmFjdCB3aWxsIHNwbGl0IHRleHQgbm9kZXMgYXQgdGhlIGJvdW5kYXJpZXNcbiAgY29uc3Qgbm9kZXMgPSBmb3J3YXJkU2VsZWN0aW9uLmV4dHJhY3QoKTtcbiAgLy8gV2Ugb25seSB3YW50IHdyYXAgYWRqYWNlbnQgdGV4dCBub2RlcywgbGluZSBicmVhayBub2Rlc1xuICAvLyBhbmQgaW5saW5lIGVsZW1lbnQgbm9kZXMuIEZvciBkZWNvcmF0b3Igbm9kZXMgYW5kIGJsb2NrXG4gIC8vIGVsZW1lbnQgbm9kZXMsIHdlIHN0ZXAgb3V0IG9mIHRoZWlyIGJvdW5kYXJ5IGFuZCBzdGFydFxuICAvLyBhZ2FpbiBhZnRlciwgaWYgdGhlcmUgYXJlIG1vcmUgbm9kZXMuXG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShsYXN0Q3JlYXRlZE1hcmtOb2RlKSAmJiBsYXN0Q3JlYXRlZE1hcmtOb2RlLmlzUGFyZW50T2Yobm9kZSkpIHtcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBjaGlsZCBvZiB0aGUgbGFzdCBjcmVhdGVkIG1hcmsgbm9kZSwgdGhlcmUgaXMgbm90aGluZyB0byBkbyBoZXJlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IHRhcmdldE5vZGUgPSBudWxsO1xuICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgLy8gQ2FzZSAxOiBUaGUgbm9kZSBpcyBhIHRleHQgbm9kZSBhbmQgd2UgY2FuIGluY2x1ZGUgaXRcbiAgICAgIHRhcmdldE5vZGUgPSBub2RlO1xuICAgIH0gZWxzZSBpZiAoJGlzTWFya05vZGUobm9kZSkpIHtcbiAgICAgIC8vIENhc2UgMjogdGhlIG5vZGUgaXMgYSBtYXJrIG5vZGUgYW5kIHdlIGNhbiBpZ25vcmUgaXQgYXMgYSB0YXJnZXQsXG4gICAgICAvLyBtb3Zpbmcgb24gdG8gaXRzIGNoaWxkcmVuLiBOb3RlIHRoYXQgd2hlbiB3ZSBtYWtlIGEgbWFyayBpbnNpZGVcbiAgICAgIC8vIGFub3RoZXIgbWFyaywgaXQgbWF5IHV0bGltYXRlbHkgYmUgdW5uZXN0ZWQgYnkgYSBjYWxsIHRvXG4gICAgICAvLyBgcmVnaXN0ZXJOZXN0ZWRFbGVtZW50UmVzb2x2ZXI8TWFya05vZGU+YCBzb21ld2hlcmUgZWxzZSBpbiB0aGVcbiAgICAgIC8vIGNvZGViYXNlLlxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmICgoJGlzRWxlbWVudE5vZGUobm9kZSkgfHwgJGlzRGVjb3JhdG9yTm9kZShub2RlKSkgJiYgbm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAvLyBDYXNlIDM6IGlubGluZSBlbGVtZW50L2RlY29yYXRvciBub2RlcyBjYW4gYmUgYWRkZWQgaW4gdGhlaXIgZW50aXJldHlcbiAgICAgIC8vIHRvIHRoZSBuZXcgbWFya1xuICAgICAgdGFyZ2V0Tm9kZSA9IG5vZGU7XG4gICAgfVxuICAgIGlmICh0YXJnZXROb2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIGEgdGFyZ2V0IG5vZGUgZm9yIHdyYXBwaW5nIHdpdGggYSBtYXJrLCB3ZSBjYW4gcnVuXG4gICAgICAvLyB0aHJvdWdoIHNwZWNpYWwgY2FzZXMuXG4gICAgICBpZiAodGFyZ2V0Tm9kZSAmJiB0YXJnZXROb2RlLmlzKGN1cnJlbnROb2RlUGFyZW50KSkge1xuICAgICAgICAvLyBUaGUgY3VycmVudCBub2RlIGlzIGEgY2hpbGQgb2YgdGhlIHRhcmdldCBub2RlIHRvIGJlIHdyYXBwZWQsIHRoZXJlXG4gICAgICAgIC8vIGlzIG5vdGhpbmcgdG8gZG8gaGVyZS5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gdGFyZ2V0Tm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGlmIChwYXJlbnROb2RlID09IG51bGwgfHwgIXBhcmVudE5vZGUuaXMoY3VycmVudE5vZGVQYXJlbnQpKSB7XG4gICAgICAgIC8vIElmIHRoZSBwYXJlbnQgbm9kZSBpcyBub3QgdGhlIGN1cnJlbnQgbm9kZSdzIHBhcmVudCBub2RlLCB3ZSBjYW5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGxhc3QgY3JlYXRlZCBtYXJrIG5vZGUuXG4gICAgICAgIGxhc3RDcmVhdGVkTWFya05vZGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjdXJyZW50Tm9kZVBhcmVudCA9IHBhcmVudE5vZGU7XG4gICAgICBpZiAobGFzdENyZWF0ZWRNYXJrTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjcmVhdGVkIG1hcmsgbm9kZSwgd2UgY2FuIG1ha2Ugb25lXG4gICAgICAgIGNvbnN0IGNyZWF0ZU1hcmtOb2RlID0gY3JlYXRlTm9kZSB8fCAkY3JlYXRlTWFya05vZGU7XG4gICAgICAgIGxhc3RDcmVhdGVkTWFya05vZGUgPSBjcmVhdGVNYXJrTm9kZShbaWRdKTtcbiAgICAgICAgdGFyZ2V0Tm9kZS5pbnNlcnRCZWZvcmUobGFzdENyZWF0ZWRNYXJrTm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgdGFyZ2V0IG5vZGUgdG8gYmUgd3JhcHBlZCBpbiB0aGUgbGF0ZXN0IGNyZWF0ZWQgbWFyayBub2RlXG4gICAgICBsYXN0Q3JlYXRlZE1hcmtOb2RlLmFwcGVuZCh0YXJnZXROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHRhcmdldCBub2RlIHRvIHdyYXAgd2UgY2FuIGNsZWFyIG91ciBzdGF0ZSBhbmRcbiAgICAgIC8vIGNvbnRpbnVlIG9uIHdpdGggdGhlIG5leHQgbm9kZVxuICAgICAgY3VycmVudE5vZGVQYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICBsYXN0Q3JlYXRlZE1hcmtOb2RlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICAvLyBNYWtlIHNlbGVjdGlvbiBjb2xsYXBzZWQgYXQgdGhlIGVuZFxuICBpZiAoJGlzRWxlbWVudE5vZGUobGFzdENyZWF0ZWRNYXJrTm9kZSkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgaXNCYWNrd2FyZCA/IGxhc3RDcmVhdGVkTWFya05vZGUuc2VsZWN0U3RhcnQoKSA6IGxhc3RDcmVhdGVkTWFya05vZGUuc2VsZWN0RW5kKCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRnZXRNYXJrSURzKG5vZGUsIG9mZnNldCkge1xuICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuICB3aGlsZSAoY3VycmVudE5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAoJGlzTWFya05vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGUuZ2V0SURzKCk7XG4gICAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZShjdXJyZW50Tm9kZSkgJiYgb2Zmc2V0ID09PSBjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBjdXJyZW50Tm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKCRpc01hcmtOb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcuZ2V0SURzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuZ2V0UGFyZW50KCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7ICRjcmVhdGVNYXJrTm9kZSwgJGdldE1hcmtJRHMsICRpc01hcmtOb2RlLCAkdW53cmFwTWFya05vZGUsICR3cmFwU2VsZWN0aW9uSW5NYXJrTm9kZSwgTWFya05vZGUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lexical+mark@0.28.0/node_modules/@lexical/mark/LexicalMark.dev.mjs\n");

/***/ })

};
;