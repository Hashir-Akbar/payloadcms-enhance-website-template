"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+clipboard@0.28.0";
exports.ids = ["vendor-chunks/@lexical+clipboard@0.28.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@lexical+clipboard@0.28.0/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+clipboard@0.28.0/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $generateJSONFromSelectedNodes: () => (/* binding */ $generateJSONFromSelectedNodes),\n/* harmony export */   $generateNodesFromSerializedNodes: () => (/* binding */ $generateNodesFromSerializedNodes),\n/* harmony export */   $getClipboardDataFromSelection: () => (/* binding */ $getClipboardDataFromSelection),\n/* harmony export */   $getHtmlContent: () => (/* binding */ $getHtmlContent),\n/* harmony export */   $getLexicalContent: () => (/* binding */ $getLexicalContent),\n/* harmony export */   $insertDataTransferForPlainText: () => (/* binding */ $insertDataTransferForPlainText),\n/* harmony export */   $insertDataTransferForRichText: () => (/* binding */ $insertDataTransferForRichText),\n/* harmony export */   $insertGeneratedNodes: () => (/* binding */ $insertGeneratedNodes),\n/* harmony export */   copyToClipboard: () => (/* binding */ copyToClipboard),\n/* harmony export */   setLexicalClipboardDataTransfer: () => (/* binding */ setLexicalClipboardDataTransfer)\n/* harmony export */ });\n/* harmony import */ var _lexical_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/html */ \"(rsc)/./node_modules/.pnpm/@lexical+html@0.28.0/node_modules/@lexical/html/LexicalHtml.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/selection */ \"(rsc)/./node_modules/.pnpm/@lexical+selection@0.28.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/utils */ \"(rsc)/./node_modules/.pnpm/@lexical+utils@0.28.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/.pnpm/lexical@0.28.0/node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor, selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateHtmlFromNodes)(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor, selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  const plainString = dataTransfer.getData('text/plain');\n\n  // Skip HTML handling if it matches the plain text representation.\n  // This avoids unnecessary processing for plain text strings created by\n  // iOS Safari autocorrect, which incorrectly includes a `text/html` type.\n  if (htmlString && plainString !== htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(trustHTML(htmlString), 'text/html');\n      const nodes = (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateNodesFromDOM)(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = plainString || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTabNode)()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction trustHTML(html) {\n  if (window.trustedTypes && window.trustedTypes.createPolicy) {\n    const policy = window.trustedTypes.createPolicy('lexical', {\n      createHTML: input => input\n    });\n    return policy.createHTML(html);\n  }\n  return html;\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(currentNode);\n    clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone) && selection !== null ? (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$sliceSelectedTextNodeContent)(selection, clone) : clone;\n    target = clone;\n  }\n  const children = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with its own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$parseSerializedNode)(serializedNode);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$addNodeStyle)(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const editorWindow = editor._window || window;\n  const windowDocument = window.document;\n  const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(editorWindow);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.COPY_COMMAND, secondEvent => {\n      if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_3__.objectKlassEquals)(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(editor._window);\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isSelectionWithinEditor)(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection === null) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection(selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)()) {\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrY2xpcGJvYXJkQDAuMjguMC9ub2RlX21vZHVsZXMvQGxleGljYWwvY2xpcGJvYXJkL0xleGljYWxDbGlwYm9hcmQuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4RTtBQUNJO0FBQy9CO0FBQ29QOztBQUV2UztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsc0RBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sMERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQSxTQUFTLHFFQUFzQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzREFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSwwREFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvRUFBcUI7QUFDekM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFpQjtBQUN6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QUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtREFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixxQ0FBcUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0UiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxoYXNoaVxcRGVza3RvcFxcZnVzaW9uaXF4LXByb2plY3RzXFxmdXNpb25pcXhcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBsZXhpY2FsK2NsaXBib2FyZEAwLjI4LjBcXG5vZGVfbW9kdWxlc1xcQGxleGljYWxcXGNsaXBib2FyZFxcTGV4aWNhbENsaXBib2FyZC5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGdlbmVyYXRlSHRtbEZyb21Ob2RlcywgJGdlbmVyYXRlTm9kZXNGcm9tRE9NIH0gZnJvbSAnQGxleGljYWwvaHRtbCc7XG5pbXBvcnQgeyAkYWRkTm9kZVN0eWxlLCAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudCB9IGZyb20gJ0BsZXhpY2FsL3NlbGVjdGlvbic7XG5pbXBvcnQgeyBvYmplY3RLbGFzc0VxdWFscyB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7ICRpc1JhbmdlU2VsZWN0aW9uLCAkZ2V0U2VsZWN0aW9uLCAkY3JlYXRlVGFiTm9kZSwgU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwgJGdldFJvb3QsICRwYXJzZVNlcmlhbGl6ZWROb2RlLCAkaXNUZXh0Tm9kZSwgZ2V0RE9NU2VsZWN0aW9uLCBDT1BZX0NPTU1BTkQsIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwsIGlzU2VsZWN0aW9uV2l0aGluRWRpdG9yLCAkZ2V0RWRpdG9yLCAkaXNFbGVtZW50Tm9kZSwgJGNsb25lV2l0aFByb3BlcnRpZXMgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vLyBEbyBub3QgcmVxdWlyZSB0aGlzIG1vZHVsZSBkaXJlY3RseSEgVXNlIG5vcm1hbCBgaW52YXJpYW50YCBjYWxscy5cblxuZnVuY3Rpb24gZm9ybWF0RGV2RXJyb3JNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlICpjdXJyZW50bHkgc2VsZWN0ZWQqIExleGljYWwgY29udGVudCBhcyBhbiBIVE1MIHN0cmluZywgcmVseWluZyBvbiB0aGVcbiAqIGxvZ2ljIGRlZmluZWQgaW4gdGhlIGV4cG9ydERPTSBtZXRob2RzIG9uIHRoZSBMZXhpY2FsTm9kZSBjbGFzc2VzLiBOb3RlIHRoYXRcbiAqIHRoaXMgd2lsbCBub3QgcmV0dXJuIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIGVudGlyZSBlZGl0b3IgKHVubGVzcyBhbGwgdGhlIGNvbnRlbnQgaXMgaW5jbHVkZWRcbiAqIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbikuXG4gKlxuICogQHBhcmFtIGVkaXRvciAtIExleGljYWxFZGl0b3IgaW5zdGFuY2UgdG8gZ2V0IEhUTUwgY29udGVudCBmcm9tXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB0byB1c2UgKGRlZmF1bHQgaXMgJGdldFNlbGVjdGlvbigpKVxuICogQHJldHVybnMgYSBzdHJpbmcgb2YgSFRNTCBjb250ZW50XG4gKi9cbmZ1bmN0aW9uICRnZXRIdG1sQ29udGVudChlZGl0b3IsIHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKSkge1xuICBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIHZhbGlkIExleGljYWxTZWxlY3Rpb25gKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlbid0IHNlbGVjdGVkIGFueXRoaW5nXG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8IHNlbGVjdGlvbi5nZXROb2RlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gJGdlbmVyYXRlSHRtbEZyb21Ob2RlcyhlZGl0b3IsIHNlbGVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgKmN1cnJlbnRseSBzZWxlY3RlZCogTGV4aWNhbCBjb250ZW50IGFzIGEgSlNPTiBzdHJpbmcsIHJlbHlpbmcgb24gdGhlXG4gKiBsb2dpYyBkZWZpbmVkIGluIHRoZSBleHBvcnRKU09OIG1ldGhvZHMgb24gdGhlIExleGljYWxOb2RlIGNsYXNzZXMuIE5vdGUgdGhhdFxuICogdGhpcyB3aWxsIG5vdCByZXR1cm4gdGhlIEpTT04gY29udGVudCBvZiB0aGUgZW50aXJlIGVkaXRvciAodW5sZXNzIGFsbCB0aGUgY29udGVudCBpcyBpbmNsdWRlZFxuICogaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uKS5cbiAqXG4gKiBAcGFyYW0gZWRpdG9yICAtIExleGljYWxFZGl0b3IgaW5zdGFuY2UgdG8gZ2V0IHRoZSBKU09OIGNvbnRlbnQgZnJvbVxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gdG8gdXNlIChkZWZhdWx0IGlzICRnZXRTZWxlY3Rpb24oKSlcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uICRnZXRMZXhpY2FsQ29udGVudChlZGl0b3IsIHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKSkge1xuICBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIHZhbGlkIExleGljYWxTZWxlY3Rpb25gKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlbid0IHNlbGVjdGVkIGFueXRoaW5nXG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8IHNlbGVjdGlvbi5nZXROb2RlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSgkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXMoZWRpdG9yLCBzZWxlY3Rpb24pKTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnNlcnQgY29udGVudCBvZiB0aGUgbWltZS10eXBlcyB0ZXh0L3BsYWluIG9yIHRleHQvdXJpLWxpc3QgZnJvbVxuICogdGhlIHByb3ZpZGVkIERhdGFUcmFuc2ZlciBvYmplY3QgaW50byB0aGUgZWRpdG9yIGF0IHRoZSBwcm92aWRlZCBzZWxlY3Rpb24uXG4gKiB0ZXh0L3VyaS1saXN0IGlzIG9ubHkgdXNlZCBpZiB0ZXh0L3BsYWluIGlzIG5vdCBhbHNvIHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSBkYXRhVHJhbnNmZXIgYW4gb2JqZWN0IGNvbmZvcm1pbmcgdG8gdGhlIFtEYXRhVHJhbnNmZXIgaW50ZXJmYWNlXSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG5kLmh0bWwjdGhlLWRhdGF0cmFuc2Zlci1pbnRlcmZhY2UpXG4gKiBAcGFyYW0gc2VsZWN0aW9uIHRoZSBzZWxlY3Rpb24gdG8gdXNlIGFzIHRoZSBpbnNlcnRpb24gcG9pbnQgZm9yIHRoZSBjb250ZW50IGluIHRoZSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uICRpbnNlcnREYXRhVHJhbnNmZXJGb3JQbGFpblRleHQoZGF0YVRyYW5zZmVyLCBzZWxlY3Rpb24pIHtcbiAgY29uc3QgdGV4dCA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3BsYWluJykgfHwgZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvdXJpLWxpc3QnKTtcbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIHNlbGVjdGlvbi5pbnNlcnRSYXdUZXh0KHRleHQpO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gaW5zZXJ0IGNvbnRlbnQgb2YgdGhlIG1pbWUtdHlwZXMgYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvciwgdGV4dC9odG1sLFxuICogdGV4dC9wbGFpbiwgb3IgdGV4dC91cmktbGlzdCAoaW4gZGVzY2VuZGluZyBvcmRlciBvZiBwcmlvcml0eSkgZnJvbSB0aGUgcHJvdmlkZWQgRGF0YVRyYW5zZmVyXG4gKiBvYmplY3QgaW50byB0aGUgZWRpdG9yIGF0IHRoZSBwcm92aWRlZCBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIGRhdGFUcmFuc2ZlciBhbiBvYmplY3QgY29uZm9ybWluZyB0byB0aGUgW0RhdGFUcmFuc2ZlciBpbnRlcmZhY2VdIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kbmQuaHRtbCN0aGUtZGF0YXRyYW5zZmVyLWludGVyZmFjZSlcbiAqIEBwYXJhbSBzZWxlY3Rpb24gdGhlIHNlbGVjdGlvbiB0byB1c2UgYXMgdGhlIGluc2VydGlvbiBwb2ludCBmb3IgdGhlIGNvbnRlbnQgaW4gdGhlIERhdGFUcmFuc2ZlciBvYmplY3RcbiAqIEBwYXJhbSBlZGl0b3IgdGhlIExleGljYWxFZGl0b3IgdGhlIGNvbnRlbnQgaXMgYmVpbmcgaW5zZXJ0ZWQgaW50by5cbiAqL1xuZnVuY3Rpb24gJGluc2VydERhdGFUcmFuc2ZlckZvclJpY2hUZXh0KGRhdGFUcmFuc2Zlciwgc2VsZWN0aW9uLCBlZGl0b3IpIHtcbiAgY29uc3QgbGV4aWNhbFN0cmluZyA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCdhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yJyk7XG4gIGlmIChsZXhpY2FsU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGxleGljYWxTdHJpbmcpO1xuICAgICAgaWYgKHBheWxvYWQubmFtZXNwYWNlID09PSBlZGl0b3IuX2NvbmZpZy5uYW1lc3BhY2UgJiYgQXJyYXkuaXNBcnJheShwYXlsb2FkLm5vZGVzKSkge1xuICAgICAgICBjb25zdCBub2RlcyA9ICRnZW5lcmF0ZU5vZGVzRnJvbVNlcmlhbGl6ZWROb2RlcyhwYXlsb2FkLm5vZGVzKTtcbiAgICAgICAgcmV0dXJuICRpbnNlcnRHZW5lcmF0ZWROb2RlcyhlZGl0b3IsIG5vZGVzLCBzZWxlY3Rpb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgIC8vIEZhaWwgc2lsZW50bHkuXG4gICAgfVxuICB9XG4gIGNvbnN0IGh0bWxTdHJpbmcgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gIGNvbnN0IHBsYWluU3RyaW5nID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblxuICAvLyBTa2lwIEhUTUwgaGFuZGxpbmcgaWYgaXQgbWF0Y2hlcyB0aGUgcGxhaW4gdGV4dCByZXByZXNlbnRhdGlvbi5cbiAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcnkgcHJvY2Vzc2luZyBmb3IgcGxhaW4gdGV4dCBzdHJpbmdzIGNyZWF0ZWQgYnlcbiAgLy8gaU9TIFNhZmFyaSBhdXRvY29ycmVjdCwgd2hpY2ggaW5jb3JyZWN0bHkgaW5jbHVkZXMgYSBgdGV4dC9odG1sYCB0eXBlLlxuICBpZiAoaHRtbFN0cmluZyAmJiBwbGFpblN0cmluZyAhPT0gaHRtbFN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICBjb25zdCBkb20gPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRydXN0SFRNTChodG1sU3RyaW5nKSwgJ3RleHQvaHRtbCcpO1xuICAgICAgY29uc3Qgbm9kZXMgPSAkZ2VuZXJhdGVOb2Rlc0Zyb21ET00oZWRpdG9yLCBkb20pO1xuICAgICAgcmV0dXJuICRpbnNlcnRHZW5lcmF0ZWROb2RlcyhlZGl0b3IsIG5vZGVzLCBzZWxlY3Rpb24pO1xuICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7XG4gICAgICAvLyBGYWlsIHNpbGVudGx5LlxuICAgIH1cbiAgfVxuXG4gIC8vIE11bHRpLWxpbmUgcGxhaW4gdGV4dCBpbiByaWNoIHRleHQgbW9kZSBwYXN0ZWQgYXMgc2VwYXJhdGUgcGFyYWdyYXBoc1xuICAvLyBpbnN0ZWFkIG9mIHNpbmdsZSBwYXJhZ3JhcGggd2l0aCBsaW5lYnJlYWtzLlxuICAvLyBXZWJraXQtc3BlY2lmaWM6IFN1cHBvcnRzIHJlYWQgJ3RleHQvdXJpLWxpc3QnIGluIGNsaXBib2FyZC5cbiAgY29uc3QgdGV4dCA9IHBsYWluU3RyaW5nIHx8IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3VyaS1saXN0Jyk7XG4gIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgcGFydHMgPSB0ZXh0LnNwbGl0KC8oXFxyP1xcbnxcXHQpLyk7XG4gICAgICBpZiAocGFydHNbcGFydHMubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgaWYgKHBhcnQgPT09ICdcXG4nIHx8IHBhcnQgPT09ICdcXHJcXG4nKSB7XG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uLmluc2VydFBhcmFncmFwaCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24uaW5zZXJ0Tm9kZXMoWyRjcmVhdGVUYWJOb2RlKCldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFNlbGVjdGlvbi5pbnNlcnRUZXh0KHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uaW5zZXJ0UmF3VGV4dCh0ZXh0KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRydXN0SFRNTChodG1sKSB7XG4gIGlmICh3aW5kb3cudHJ1c3RlZFR5cGVzICYmIHdpbmRvdy50cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KSB7XG4gICAgY29uc3QgcG9saWN5ID0gd2luZG93LnRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3koJ2xleGljYWwnLCB7XG4gICAgICBjcmVhdGVIVE1MOiBpbnB1dCA9PiBpbnB1dFxuICAgIH0pO1xuICAgIHJldHVybiBwb2xpY3kuY3JlYXRlSFRNTChodG1sKTtcbiAgfVxuICByZXR1cm4gaHRtbDtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIExleGljYWwgbm9kZXMgaW50byB0aGUgZWRpdG9yIHVzaW5nIGRpZmZlcmVudCBzdHJhdGVnaWVzIGRlcGVuZGluZyBvblxuICogc29tZSBzaW1wbGUgc2VsZWN0aW9uLWJhc2VkIGhldXJpc3RpY3MuIElmIHlvdSdyZSBsb29raW5nIGZvciBhIGdlbmVyaWMgd2F5IHRvXG4gKiB0byBpbnNlcnQgbm9kZXMgaW50byB0aGUgZWRpdG9yIGF0IGEgc3BlY2lmaWMgc2VsZWN0aW9uIHBvaW50LCB5b3UgcHJvYmFibHkgd2FudFxuICoge0BsaW5rIGxleGljYWwuJGluc2VydE5vZGVzfVxuICpcbiAqIEBwYXJhbSBlZGl0b3IgTGV4aWNhbEVkaXRvciBpbnN0YW5jZSB0byBpbnNlcnQgdGhlIG5vZGVzIGludG8uXG4gKiBAcGFyYW0gbm9kZXMgVGhlIG5vZGVzIHRvIGluc2VydC5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gVGhlIHNlbGVjdGlvbiB0byBpbnNlcnQgdGhlIG5vZGVzIGludG8uXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnRHZW5lcmF0ZWROb2RlcyhlZGl0b3IsIG5vZGVzLCBzZWxlY3Rpb24pIHtcbiAgaWYgKCFlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9JTlNFUlRfQ0xJUEJPQVJEX05PREVTX0NPTU1BTkQsIHtcbiAgICBub2RlcyxcbiAgICBzZWxlY3Rpb25cbiAgfSkpIHtcbiAgICBzZWxlY3Rpb24uaW5zZXJ0Tm9kZXMobm9kZXMpO1xuICB9XG4gIHJldHVybjtcbn1cbmZ1bmN0aW9uIGV4cG9ydE5vZGVUb0pTT04obm9kZSkge1xuICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IG5vZGUuZXhwb3J0SlNPTigpO1xuICBjb25zdCBub2RlQ2xhc3MgPSBub2RlLmNvbnN0cnVjdG9yO1xuICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSAhPT0gbm9kZUNsYXNzLmdldFR5cGUoKSkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IC5leHBvcnRKU09OKCkuYCk7XG4gICAgfVxuICB9XG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZHJlbiA9IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzZXJpYWxpemVkQ2hpbGRyZW4pKSB7XG4gICAgICB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gaXMgYW4gZWxlbWVudCBidXQgLmV4cG9ydEpTT04oKSBkb2VzIG5vdCBoYXZlIGEgY2hpbGRyZW4gYXJyYXkuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkTm9kZTtcbn1cbmZ1bmN0aW9uICRhcHBlbmROb2Rlc1RvSlNPTihlZGl0b3IsIHNlbGVjdGlvbiwgY3VycmVudE5vZGUsIHRhcmdldEFycmF5ID0gW10pIHtcbiAgbGV0IHNob3VsZEluY2x1ZGUgPSBzZWxlY3Rpb24gIT09IG51bGwgPyBjdXJyZW50Tm9kZS5pc1NlbGVjdGVkKHNlbGVjdGlvbikgOiB0cnVlO1xuICBjb25zdCBzaG91bGRFeGNsdWRlID0gJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmIGN1cnJlbnROb2RlLmV4Y2x1ZGVGcm9tQ29weSgnaHRtbCcpO1xuICBsZXQgdGFyZ2V0ID0gY3VycmVudE5vZGU7XG4gIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICBsZXQgY2xvbmUgPSAkY2xvbmVXaXRoUHJvcGVydGllcyhjdXJyZW50Tm9kZSk7XG4gICAgY2xvbmUgPSAkaXNUZXh0Tm9kZShjbG9uZSkgJiYgc2VsZWN0aW9uICE9PSBudWxsID8gJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQoc2VsZWN0aW9uLCBjbG9uZSkgOiBjbG9uZTtcbiAgICB0YXJnZXQgPSBjbG9uZTtcbiAgfVxuICBjb25zdCBjaGlsZHJlbiA9ICRpc0VsZW1lbnROb2RlKHRhcmdldCkgPyB0YXJnZXQuZ2V0Q2hpbGRyZW4oKSA6IFtdO1xuICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IGV4cG9ydE5vZGVUb0pTT04odGFyZ2V0KTtcblxuICAvLyBUT0RPOiBUZXh0Tm9kZSBjYWxscyBnZXRUZXh0Q29udGVudCgpIChOT1Qgbm9kZS5fX3RleHQpIHdpdGhpbiBpdHMgZXhwb3J0SlNPTiBtZXRob2RcbiAgLy8gd2hpY2ggdXNlcyBnZXRMYXRlc3QoKSB0byBnZXQgdGhlIHRleHQgZnJvbSB0aGUgb3JpZ2luYWwgbm9kZSB3aXRoIHRoZSBzYW1lIGtleS5cbiAgLy8gVGhpcyBpcyBhIGRlZXBlciBpc3N1ZSB3aXRoIHRoZSB3b3JkIFwiY2xvbmVcIiBoZXJlLCBpdCdzIHN0aWxsIGEgcmVmZXJlbmNlIHRvIHRoZVxuICAvLyBzYW1lIG5vZGUgYXMgZmFyIGFzIHRoZSBMZXhpY2FsRWRpdG9yIGlzIGNvbmNlcm5lZCBzaW5jZSBpdCBzaGFyZXMgYSBrZXkuXG4gIC8vIFdlIG5lZWQgYSB3YXkgdG8gY3JlYXRlIGEgY2xvbmUgb2YgYSBOb2RlIGluIG1lbW9yeSB3aXRoIGl0cyBvd24ga2V5LCBidXRcbiAgLy8gdW50aWwgdGhlbiB0aGlzIGhhY2sgd2lsbCB3b3JrIGZvciB0aGUgc2VsZWN0ZWQgdGV4dCBleHRyYWN0IHVzZSBjYXNlLlxuICBpZiAoJGlzVGV4dE5vZGUodGFyZ2V0KSkge1xuICAgIGNvbnN0IHRleHQgPSB0YXJnZXQuX190ZXh0O1xuICAgIC8vIElmIGFuIHVuY29sbGFwc2VkIHNlbGVjdGlvbiBlbmRzIG9yIHN0YXJ0cyBhdCB0aGUgZW5kIG9mIGEgbGluZSBvZiBzcGVjaWFsaXplZCxcbiAgICAvLyBUZXh0Tm9kZXMsIHN1Y2ggYXMgY29kZSB0b2tlbnMsIHdlIHdpbGwgZ2V0IGEgJ2JsYW5rJyBUZXh0Tm9kZSBoZXJlLCBpLmUuLCBvbmVcbiAgICAvLyB3aXRoIHRleHQgb2YgbGVuZ3RoIDAuIFdlIGRvbid0IHdhbnQgdGhpcywgaXQgbWFrZXMgYSBjb25mdXNpbmcgbWVzcy4gUmVzZXQhXG4gICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgc2VyaWFsaXplZE5vZGUudGV4dCA9IHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZEluY2x1ZGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IHNob3VsZEluY2x1ZGVDaGlsZCA9ICRhcHBlbmROb2Rlc1RvSlNPTihlZGl0b3IsIHNlbGVjdGlvbiwgY2hpbGROb2RlLCBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbik7XG4gICAgaWYgKCFzaG91bGRJbmNsdWRlICYmICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiBzaG91bGRJbmNsdWRlQ2hpbGQgJiYgY3VycmVudE5vZGUuZXh0cmFjdFdpdGhDaGlsZChjaGlsZE5vZGUsIHNlbGVjdGlvbiwgJ2Nsb25lJykpIHtcbiAgICAgIHNob3VsZEluY2x1ZGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoc2hvdWxkSW5jbHVkZSAmJiAhc2hvdWxkRXhjbHVkZSkge1xuICAgIHRhcmdldEFycmF5LnB1c2goc2VyaWFsaXplZE5vZGUpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VyaWFsaXplZE5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZENoaWxkTm9kZSA9IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuW2ldO1xuICAgICAgdGFyZ2V0QXJyYXkucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNob3VsZEluY2x1ZGU7XG59XG5cbi8vIFRPRE8gd2h5ICQgZnVuY3Rpb24gd2l0aCBFZGl0b3IgaW5zdGFuY2U/XG4vKipcbiAqIEdldHMgdGhlIExleGljYWwgSlNPTiBvZiB0aGUgbm9kZXMgaW5zaWRlIHRoZSBwcm92aWRlZCBTZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIGVkaXRvciBMZXhpY2FsRWRpdG9yIHRvIGdldCB0aGUgSlNPTiBjb250ZW50IGZyb20uXG4gKiBAcGFyYW0gc2VsZWN0aW9uIFNlbGVjdGlvbiB0byBnZXQgdGhlIEpTT04gY29udGVudCBmcm9tLlxuICogQHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGVkaXRvciBuYW1lc3BhY2UgYW5kIGEgbGlzdCBvZiBzZXJpYWxpemFibGUgbm9kZXMgYXMgSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiAkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXMoZWRpdG9yLCBzZWxlY3Rpb24pIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gIGNvbnN0IHRvcExldmVsQ2hpbGRyZW4gPSByb290LmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9wTGV2ZWxDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvcExldmVsTm9kZSA9IHRvcExldmVsQ2hpbGRyZW5baV07XG4gICAgJGFwcGVuZE5vZGVzVG9KU09OKGVkaXRvciwgc2VsZWN0aW9uLCB0b3BMZXZlbE5vZGUsIG5vZGVzKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWVzcGFjZTogZWRpdG9yLl9jb25maWcubmFtZXNwYWNlLFxuICAgIG5vZGVzXG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgdGFrZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb25mb3JtaW5nIHRvIHRoZSBCYXNlU2VyYWxpemVkTm9kZSBpbnRlcmZhY2UgYW5kIHJldHVybnNcbiAqIGFuIEFycmF5IGNvbnRhaW5pbmcgaW5zdGFuY2VzIG9mIHRoZSBjb3JyZXNwb25kaW5nIExleGljYWxOb2RlIGNsYXNzZXMgcmVnaXN0ZXJlZCBvbiB0aGUgZWRpdG9yLlxuICogTm9ybWFsbHksIHlvdSdkIGdldCBhbiBBcnJheSBvZiBCYXNlU2VyaWFsaXplZCBub2RlcyBmcm9tIHtAbGluayAkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXN9XG4gKlxuICogQHBhcmFtIHNlcmlhbGl6ZWROb2RlcyBhbiBBcnJheSBvZiBvYmplY3RzIGNvbmZvcm1pbmcgdG8gdGhlIEJhc2VTZXJpYWxpemVkTm9kZSBpbnRlcmZhY2UuXG4gKiBAcmV0dXJucyBhbiBBcnJheSBvZiBMZXhpY2FsIE5vZGUgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gJGdlbmVyYXRlTm9kZXNGcm9tU2VyaWFsaXplZE5vZGVzKHNlcmlhbGl6ZWROb2Rlcykge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcmlhbGl6ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplZE5vZGVzW2ldO1xuICAgIGNvbnN0IG5vZGUgPSAkcGFyc2VTZXJpYWxpemVkTm9kZShzZXJpYWxpemVkTm9kZSk7XG4gICAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAkYWRkTm9kZVN0eWxlKG5vZGUpO1xuICAgIH1cbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cbmNvbnN0IEVWRU5UX0xBVEVOQ1kgPSA1MDtcbmxldCBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSBudWxsO1xuXG4vLyBUT0RPIGN1c3RvbSBzZWxlY3Rpb25cbi8vIFRPRE8gcG90ZW50aWFsbHkgaGF2ZSBhIG5vZGUgY3VzdG9taXphYmxlIHZlcnNpb24gZm9yIHBsYWluIHRleHRcbi8qKlxuICogQ29waWVzIHRoZSBjb250ZW50IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB0byB0aGUgY2xpcGJvYXJkIGluXG4gKiB0ZXh0L3BsYWluLCB0ZXh0L2h0bWwsIGFuZCBhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yIChMZXhpY2FsIEpTT04pXG4gKiBmb3JtYXRzLlxuICpcbiAqIEBwYXJhbSBlZGl0b3IgdGhlIExleGljYWxFZGl0b3IgaW5zdGFuY2UgdG8gY29weSBjb250ZW50IGZyb21cbiAqIEBwYXJhbSBldmVudCB0aGUgbmF0aXZlIGJyb3dzZXIgQ2xpcGJvYXJkRXZlbnQgdG8gYWRkIHRoZSBjb250ZW50IHRvLlxuICogQHJldHVybnNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY29weVRvQ2xpcGJvYXJkKGVkaXRvciwgZXZlbnQsIGRhdGEpIHtcbiAgaWYgKGNsaXBib2FyZEV2ZW50VGltZW91dCAhPT0gbnVsbCkge1xuICAgIC8vIFByZXZlbnQgd2VpcmQgcmFjZSBjb25kaXRpb25zIHRoYXQgY2FuIGhhcHBlbiB3aGVuIHRoaXMgZnVuY3Rpb24gaXMgcnVuIG11bHRpcGxlIHRpbWVzXG4gICAgLy8gc3luY2hyb25vdXNseS4gSW4gdGhlIGZ1dHVyZSwgd2UgY2FuIGRvIGJldHRlciwgd2UgY2FuIGNhbmNlbC9vdmVycmlkZSB0aGUgcHJldmlvdXNseSBydW5uaW5nIGpvYi5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGV2ZW50ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICByZXNvbHZlKCRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIGV2ZW50LCBkYXRhKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICBjb25zdCBlZGl0b3JXaW5kb3cgPSBlZGl0b3IuX3dpbmRvdyB8fCB3aW5kb3c7XG4gIGNvbnN0IHdpbmRvd0RvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yV2luZG93KTtcbiAgaWYgKHJvb3RFbGVtZW50ID09PSBudWxsIHx8IGRvbVNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBlbGVtZW50ID0gd2luZG93RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGZpeGVkOyB0b3A6IC0xMDAwcHg7JztcbiAgZWxlbWVudC5hcHBlbmQod2luZG93RG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyMnKSk7XG4gIHJvb3RFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgY29uc3QgcmFuZ2UgPSBuZXcgUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoZWxlbWVudCwgMCk7XG4gIHJhbmdlLnNldEVuZChlbGVtZW50LCAxKTtcbiAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICBkb21TZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDT1BZX0NPTU1BTkQsIHNlY29uZEV2ZW50ID0+IHtcbiAgICAgIGlmIChvYmplY3RLbGFzc0VxdWFscyhzZWNvbmRFdmVudCwgQ2xpcGJvYXJkRXZlbnQpKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgIGlmIChjbGlwYm9hcmRFdmVudFRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNsaXBib2FyZEV2ZW50VGltZW91dCk7XG4gICAgICAgICAgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIHNlY29uZEV2ZW50LCBkYXRhKSk7XG4gICAgICB9XG4gICAgICAvLyBCbG9jayB0aGUgZW50aXJlIGNvcHkgZmxvdyB3aGlsZSB3ZSB3YWl0IGZvciB0aGUgbmV4dCBDbGlwYm9hcmRFdmVudFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCk7XG4gICAgLy8gSWYgdGhlIGFib3ZlIGhhY2sgZXhlY0NvbW1hbmQgaGFjayB3b3JrcywgdGhpcyB0aW1lb3V0IGNvZGUgc2hvdWxkIG5ldmVyIGZpcmUuIE90aGVyd2lzZSxcbiAgICAvLyB0aGUgbGlzdGVuZXIgd2lsbCBiZSBxdWlja2x5IGZyZWVkIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHJldXNlIGl0IGFnYWluXG4gICAgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgIGNsaXBib2FyZEV2ZW50VGltZW91dCA9IG51bGw7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICB9LCBFVkVOVF9MQVRFTkNZKTtcbiAgICB3aW5kb3dEb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gIH0pO1xufVxuXG4vLyBUT0RPIHNob3VsZG4ndCBwYXNzIGVkaXRvciAocGFzcyBuYW1lc3BhY2UgZGlyZWN0bHkpXG5mdW5jdGlvbiAkY29weVRvQ2xpcGJvYXJkRXZlbnQoZWRpdG9yLCBldmVudCwgZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcbiAgICBpZiAoIWRvbVNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JET00gPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgICBjb25zdCBmb2N1c0RPTSA9IGRvbVNlbGVjdGlvbi5mb2N1c05vZGU7XG4gICAgaWYgKGFuY2hvckRPTSAhPT0gbnVsbCAmJiBmb2N1c0RPTSAhPT0gbnVsbCAmJiAhaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IoZWRpdG9yLCBhbmNob3JET00sIGZvY3VzRE9NKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkYXRhID0gJGdldENsaXBib2FyZERhdGFGcm9tU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gIH1cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gIGlmIChjbGlwYm9hcmREYXRhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHNldExleGljYWxDbGlwYm9hcmREYXRhVHJhbnNmZXIoY2xpcGJvYXJkRGF0YSwgZGF0YSk7XG4gIHJldHVybiB0cnVlO1xufVxuY29uc3QgY2xpcGJvYXJkRGF0YUZ1bmN0aW9ucyA9IFtbJ3RleHQvaHRtbCcsICRnZXRIdG1sQ29udGVudF0sIFsnYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvcicsICRnZXRMZXhpY2FsQ29udGVudF1dO1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgY29udGVudCBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gdG8gc3RyaW5ncyBpblxuICogdGV4dC9wbGFpbiwgdGV4dC9odG1sLCBhbmQgYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvciAoTGV4aWNhbCBKU09OKVxuICogZm9ybWF0cyAoYXMgYXZhaWxhYmxlKS5cbiAqXG4gKiBAcGFyYW0gc2VsZWN0aW9uIHRoZSBzZWxlY3Rpb24gdG8gc2VyaWFsaXplIChkZWZhdWx0cyB0byAkZ2V0U2VsZWN0aW9uKCkpXG4gKiBAcmV0dXJucyBMZXhpY2FsQ2xpcGJvYXJkRGF0YVxuICovXG5mdW5jdGlvbiAkZ2V0Q2xpcGJvYXJkRGF0YUZyb21TZWxlY3Rpb24oc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpKSB7XG4gIGNvbnN0IGNsaXBib2FyZERhdGEgPSB7XG4gICAgJ3RleHQvcGxhaW4nOiBzZWxlY3Rpb24gPyBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKSA6ICcnXG4gIH07XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICBjb25zdCBlZGl0b3IgPSAkZ2V0RWRpdG9yKCk7XG4gICAgZm9yIChjb25zdCBbbWltZVR5cGUsICRlZGl0b3JGbl0gb2YgY2xpcGJvYXJkRGF0YUZ1bmN0aW9ucykge1xuICAgICAgY29uc3QgdiA9ICRlZGl0b3JGbihlZGl0b3IsIHNlbGVjdGlvbik7XG4gICAgICBpZiAodiAhPT0gbnVsbCkge1xuICAgICAgICBjbGlwYm9hcmREYXRhW21pbWVUeXBlXSA9IHY7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjbGlwYm9hcmREYXRhO1xufVxuXG4vKipcbiAqIENhbGwgc2V0RGF0YSBvbiB0aGUgZ2l2ZW4gY2xpcGJvYXJkRGF0YSBmb3IgZWFjaCBNSU1FIHR5cGUgcHJlc2VudFxuICogaW4gdGhlIGdpdmVuIGRhdGEgKGZyb20ge0BsaW5rICRnZXRDbGlwYm9hcmREYXRhRnJvbVNlbGVjdGlvbn0pXG4gKlxuICogQHBhcmFtIGNsaXBib2FyZERhdGEgdGhlIGV2ZW50LmNsaXBib2FyZERhdGEgdG8gcG9wdWxhdGUgZnJvbSBkYXRhXG4gKiBAcGFyYW0gZGF0YSBUaGUgbGV4aWNhbCBkYXRhXG4gKi9cbmZ1bmN0aW9uIHNldExleGljYWxDbGlwYm9hcmREYXRhVHJhbnNmZXIoY2xpcGJvYXJkRGF0YSwgZGF0YSkge1xuICBmb3IgKGNvbnN0IGsgaW4gZGF0YSkge1xuICAgIGNvbnN0IHYgPSBkYXRhW2tdO1xuICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YShrLCB2KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgJGdlbmVyYXRlSlNPTkZyb21TZWxlY3RlZE5vZGVzLCAkZ2VuZXJhdGVOb2Rlc0Zyb21TZXJpYWxpemVkTm9kZXMsICRnZXRDbGlwYm9hcmREYXRhRnJvbVNlbGVjdGlvbiwgJGdldEh0bWxDb250ZW50LCAkZ2V0TGV4aWNhbENvbnRlbnQsICRpbnNlcnREYXRhVHJhbnNmZXJGb3JQbGFpblRleHQsICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dCwgJGluc2VydEdlbmVyYXRlZE5vZGVzLCBjb3B5VG9DbGlwYm9hcmQsIHNldExleGljYWxDbGlwYm9hcmREYXRhVHJhbnNmZXIgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@lexical+clipboard@0.28.0/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@lexical+clipboard@0.28.0/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+clipboard@0.28.0/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $generateJSONFromSelectedNodes: () => (/* binding */ $generateJSONFromSelectedNodes),\n/* harmony export */   $generateNodesFromSerializedNodes: () => (/* binding */ $generateNodesFromSerializedNodes),\n/* harmony export */   $getClipboardDataFromSelection: () => (/* binding */ $getClipboardDataFromSelection),\n/* harmony export */   $getHtmlContent: () => (/* binding */ $getHtmlContent),\n/* harmony export */   $getLexicalContent: () => (/* binding */ $getLexicalContent),\n/* harmony export */   $insertDataTransferForPlainText: () => (/* binding */ $insertDataTransferForPlainText),\n/* harmony export */   $insertDataTransferForRichText: () => (/* binding */ $insertDataTransferForRichText),\n/* harmony export */   $insertGeneratedNodes: () => (/* binding */ $insertGeneratedNodes),\n/* harmony export */   copyToClipboard: () => (/* binding */ copyToClipboard),\n/* harmony export */   setLexicalClipboardDataTransfer: () => (/* binding */ setLexicalClipboardDataTransfer)\n/* harmony export */ });\n/* harmony import */ var _lexical_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/html */ \"(ssr)/./node_modules/.pnpm/@lexical+html@0.28.0/node_modules/@lexical/html/LexicalHtml.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/.pnpm/@lexical+selection@0.28.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/.pnpm/@lexical+utils@0.28.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/.pnpm/lexical@0.28.0/node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor, selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateHtmlFromNodes)(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor, selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  const plainString = dataTransfer.getData('text/plain');\n\n  // Skip HTML handling if it matches the plain text representation.\n  // This avoids unnecessary processing for plain text strings created by\n  // iOS Safari autocorrect, which incorrectly includes a `text/html` type.\n  if (htmlString && plainString !== htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(trustHTML(htmlString), 'text/html');\n      const nodes = (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateNodesFromDOM)(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = plainString || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTabNode)()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction trustHTML(html) {\n  if (window.trustedTypes && window.trustedTypes.createPolicy) {\n    const policy = window.trustedTypes.createPolicy('lexical', {\n      createHTML: input => input\n    });\n    return policy.createHTML(html);\n  }\n  return html;\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(currentNode);\n    clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone) && selection !== null ? (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$sliceSelectedTextNodeContent)(selection, clone) : clone;\n    target = clone;\n  }\n  const children = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with its own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$parseSerializedNode)(serializedNode);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$addNodeStyle)(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const editorWindow = editor._window || window;\n  const windowDocument = window.document;\n  const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(editorWindow);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.COPY_COMMAND, secondEvent => {\n      if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_3__.objectKlassEquals)(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(editor._window);\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isSelectionWithinEditor)(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection === null) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection(selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)()) {\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrY2xpcGJvYXJkQDAuMjguMC9ub2RlX21vZHVsZXMvQGxleGljYWwvY2xpcGJvYXJkL0xleGljYWxDbGlwYm9hcmQuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4RTtBQUNJO0FBQy9CO0FBQ29QOztBQUV2UztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsc0RBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sMERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQSxTQUFTLHFFQUFzQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzREFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSwwREFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvRUFBcUI7QUFDekM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFpQjtBQUN6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QUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtREFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixxQ0FBcUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0UiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxoYXNoaVxcRGVza3RvcFxcZnVzaW9uaXF4LXByb2plY3RzXFxmdXNpb25pcXhcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBsZXhpY2FsK2NsaXBib2FyZEAwLjI4LjBcXG5vZGVfbW9kdWxlc1xcQGxleGljYWxcXGNsaXBib2FyZFxcTGV4aWNhbENsaXBib2FyZC5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGdlbmVyYXRlSHRtbEZyb21Ob2RlcywgJGdlbmVyYXRlTm9kZXNGcm9tRE9NIH0gZnJvbSAnQGxleGljYWwvaHRtbCc7XG5pbXBvcnQgeyAkYWRkTm9kZVN0eWxlLCAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudCB9IGZyb20gJ0BsZXhpY2FsL3NlbGVjdGlvbic7XG5pbXBvcnQgeyBvYmplY3RLbGFzc0VxdWFscyB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7ICRpc1JhbmdlU2VsZWN0aW9uLCAkZ2V0U2VsZWN0aW9uLCAkY3JlYXRlVGFiTm9kZSwgU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwgJGdldFJvb3QsICRwYXJzZVNlcmlhbGl6ZWROb2RlLCAkaXNUZXh0Tm9kZSwgZ2V0RE9NU2VsZWN0aW9uLCBDT1BZX0NPTU1BTkQsIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwsIGlzU2VsZWN0aW9uV2l0aGluRWRpdG9yLCAkZ2V0RWRpdG9yLCAkaXNFbGVtZW50Tm9kZSwgJGNsb25lV2l0aFByb3BlcnRpZXMgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vLyBEbyBub3QgcmVxdWlyZSB0aGlzIG1vZHVsZSBkaXJlY3RseSEgVXNlIG5vcm1hbCBgaW52YXJpYW50YCBjYWxscy5cblxuZnVuY3Rpb24gZm9ybWF0RGV2RXJyb3JNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlICpjdXJyZW50bHkgc2VsZWN0ZWQqIExleGljYWwgY29udGVudCBhcyBhbiBIVE1MIHN0cmluZywgcmVseWluZyBvbiB0aGVcbiAqIGxvZ2ljIGRlZmluZWQgaW4gdGhlIGV4cG9ydERPTSBtZXRob2RzIG9uIHRoZSBMZXhpY2FsTm9kZSBjbGFzc2VzLiBOb3RlIHRoYXRcbiAqIHRoaXMgd2lsbCBub3QgcmV0dXJuIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIGVudGlyZSBlZGl0b3IgKHVubGVzcyBhbGwgdGhlIGNvbnRlbnQgaXMgaW5jbHVkZWRcbiAqIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbikuXG4gKlxuICogQHBhcmFtIGVkaXRvciAtIExleGljYWxFZGl0b3IgaW5zdGFuY2UgdG8gZ2V0IEhUTUwgY29udGVudCBmcm9tXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB0byB1c2UgKGRlZmF1bHQgaXMgJGdldFNlbGVjdGlvbigpKVxuICogQHJldHVybnMgYSBzdHJpbmcgb2YgSFRNTCBjb250ZW50XG4gKi9cbmZ1bmN0aW9uICRnZXRIdG1sQ29udGVudChlZGl0b3IsIHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKSkge1xuICBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIHZhbGlkIExleGljYWxTZWxlY3Rpb25gKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlbid0IHNlbGVjdGVkIGFueXRoaW5nXG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8IHNlbGVjdGlvbi5nZXROb2RlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gJGdlbmVyYXRlSHRtbEZyb21Ob2RlcyhlZGl0b3IsIHNlbGVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgKmN1cnJlbnRseSBzZWxlY3RlZCogTGV4aWNhbCBjb250ZW50IGFzIGEgSlNPTiBzdHJpbmcsIHJlbHlpbmcgb24gdGhlXG4gKiBsb2dpYyBkZWZpbmVkIGluIHRoZSBleHBvcnRKU09OIG1ldGhvZHMgb24gdGhlIExleGljYWxOb2RlIGNsYXNzZXMuIE5vdGUgdGhhdFxuICogdGhpcyB3aWxsIG5vdCByZXR1cm4gdGhlIEpTT04gY29udGVudCBvZiB0aGUgZW50aXJlIGVkaXRvciAodW5sZXNzIGFsbCB0aGUgY29udGVudCBpcyBpbmNsdWRlZFxuICogaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uKS5cbiAqXG4gKiBAcGFyYW0gZWRpdG9yICAtIExleGljYWxFZGl0b3IgaW5zdGFuY2UgdG8gZ2V0IHRoZSBKU09OIGNvbnRlbnQgZnJvbVxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gdG8gdXNlIChkZWZhdWx0IGlzICRnZXRTZWxlY3Rpb24oKSlcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uICRnZXRMZXhpY2FsQ29udGVudChlZGl0b3IsIHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKSkge1xuICBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIHZhbGlkIExleGljYWxTZWxlY3Rpb25gKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlbid0IHNlbGVjdGVkIGFueXRoaW5nXG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8IHNlbGVjdGlvbi5nZXROb2RlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSgkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXMoZWRpdG9yLCBzZWxlY3Rpb24pKTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnNlcnQgY29udGVudCBvZiB0aGUgbWltZS10eXBlcyB0ZXh0L3BsYWluIG9yIHRleHQvdXJpLWxpc3QgZnJvbVxuICogdGhlIHByb3ZpZGVkIERhdGFUcmFuc2ZlciBvYmplY3QgaW50byB0aGUgZWRpdG9yIGF0IHRoZSBwcm92aWRlZCBzZWxlY3Rpb24uXG4gKiB0ZXh0L3VyaS1saXN0IGlzIG9ubHkgdXNlZCBpZiB0ZXh0L3BsYWluIGlzIG5vdCBhbHNvIHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSBkYXRhVHJhbnNmZXIgYW4gb2JqZWN0IGNvbmZvcm1pbmcgdG8gdGhlIFtEYXRhVHJhbnNmZXIgaW50ZXJmYWNlXSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG5kLmh0bWwjdGhlLWRhdGF0cmFuc2Zlci1pbnRlcmZhY2UpXG4gKiBAcGFyYW0gc2VsZWN0aW9uIHRoZSBzZWxlY3Rpb24gdG8gdXNlIGFzIHRoZSBpbnNlcnRpb24gcG9pbnQgZm9yIHRoZSBjb250ZW50IGluIHRoZSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uICRpbnNlcnREYXRhVHJhbnNmZXJGb3JQbGFpblRleHQoZGF0YVRyYW5zZmVyLCBzZWxlY3Rpb24pIHtcbiAgY29uc3QgdGV4dCA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3BsYWluJykgfHwgZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvdXJpLWxpc3QnKTtcbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIHNlbGVjdGlvbi5pbnNlcnRSYXdUZXh0KHRleHQpO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gaW5zZXJ0IGNvbnRlbnQgb2YgdGhlIG1pbWUtdHlwZXMgYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvciwgdGV4dC9odG1sLFxuICogdGV4dC9wbGFpbiwgb3IgdGV4dC91cmktbGlzdCAoaW4gZGVzY2VuZGluZyBvcmRlciBvZiBwcmlvcml0eSkgZnJvbSB0aGUgcHJvdmlkZWQgRGF0YVRyYW5zZmVyXG4gKiBvYmplY3QgaW50byB0aGUgZWRpdG9yIGF0IHRoZSBwcm92aWRlZCBzZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIGRhdGFUcmFuc2ZlciBhbiBvYmplY3QgY29uZm9ybWluZyB0byB0aGUgW0RhdGFUcmFuc2ZlciBpbnRlcmZhY2VdIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kbmQuaHRtbCN0aGUtZGF0YXRyYW5zZmVyLWludGVyZmFjZSlcbiAqIEBwYXJhbSBzZWxlY3Rpb24gdGhlIHNlbGVjdGlvbiB0byB1c2UgYXMgdGhlIGluc2VydGlvbiBwb2ludCBmb3IgdGhlIGNvbnRlbnQgaW4gdGhlIERhdGFUcmFuc2ZlciBvYmplY3RcbiAqIEBwYXJhbSBlZGl0b3IgdGhlIExleGljYWxFZGl0b3IgdGhlIGNvbnRlbnQgaXMgYmVpbmcgaW5zZXJ0ZWQgaW50by5cbiAqL1xuZnVuY3Rpb24gJGluc2VydERhdGFUcmFuc2ZlckZvclJpY2hUZXh0KGRhdGFUcmFuc2Zlciwgc2VsZWN0aW9uLCBlZGl0b3IpIHtcbiAgY29uc3QgbGV4aWNhbFN0cmluZyA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCdhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yJyk7XG4gIGlmIChsZXhpY2FsU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGxleGljYWxTdHJpbmcpO1xuICAgICAgaWYgKHBheWxvYWQubmFtZXNwYWNlID09PSBlZGl0b3IuX2NvbmZpZy5uYW1lc3BhY2UgJiYgQXJyYXkuaXNBcnJheShwYXlsb2FkLm5vZGVzKSkge1xuICAgICAgICBjb25zdCBub2RlcyA9ICRnZW5lcmF0ZU5vZGVzRnJvbVNlcmlhbGl6ZWROb2RlcyhwYXlsb2FkLm5vZGVzKTtcbiAgICAgICAgcmV0dXJuICRpbnNlcnRHZW5lcmF0ZWROb2RlcyhlZGl0b3IsIG5vZGVzLCBzZWxlY3Rpb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgIC8vIEZhaWwgc2lsZW50bHkuXG4gICAgfVxuICB9XG4gIGNvbnN0IGh0bWxTdHJpbmcgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gIGNvbnN0IHBsYWluU3RyaW5nID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblxuICAvLyBTa2lwIEhUTUwgaGFuZGxpbmcgaWYgaXQgbWF0Y2hlcyB0aGUgcGxhaW4gdGV4dCByZXByZXNlbnRhdGlvbi5cbiAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcnkgcHJvY2Vzc2luZyBmb3IgcGxhaW4gdGV4dCBzdHJpbmdzIGNyZWF0ZWQgYnlcbiAgLy8gaU9TIFNhZmFyaSBhdXRvY29ycmVjdCwgd2hpY2ggaW5jb3JyZWN0bHkgaW5jbHVkZXMgYSBgdGV4dC9odG1sYCB0eXBlLlxuICBpZiAoaHRtbFN0cmluZyAmJiBwbGFpblN0cmluZyAhPT0gaHRtbFN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICBjb25zdCBkb20gPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRydXN0SFRNTChodG1sU3RyaW5nKSwgJ3RleHQvaHRtbCcpO1xuICAgICAgY29uc3Qgbm9kZXMgPSAkZ2VuZXJhdGVOb2Rlc0Zyb21ET00oZWRpdG9yLCBkb20pO1xuICAgICAgcmV0dXJuICRpbnNlcnRHZW5lcmF0ZWROb2RlcyhlZGl0b3IsIG5vZGVzLCBzZWxlY3Rpb24pO1xuICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7XG4gICAgICAvLyBGYWlsIHNpbGVudGx5LlxuICAgIH1cbiAgfVxuXG4gIC8vIE11bHRpLWxpbmUgcGxhaW4gdGV4dCBpbiByaWNoIHRleHQgbW9kZSBwYXN0ZWQgYXMgc2VwYXJhdGUgcGFyYWdyYXBoc1xuICAvLyBpbnN0ZWFkIG9mIHNpbmdsZSBwYXJhZ3JhcGggd2l0aCBsaW5lYnJlYWtzLlxuICAvLyBXZWJraXQtc3BlY2lmaWM6IFN1cHBvcnRzIHJlYWQgJ3RleHQvdXJpLWxpc3QnIGluIGNsaXBib2FyZC5cbiAgY29uc3QgdGV4dCA9IHBsYWluU3RyaW5nIHx8IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3VyaS1saXN0Jyk7XG4gIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgcGFydHMgPSB0ZXh0LnNwbGl0KC8oXFxyP1xcbnxcXHQpLyk7XG4gICAgICBpZiAocGFydHNbcGFydHMubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgaWYgKHBhcnQgPT09ICdcXG4nIHx8IHBhcnQgPT09ICdcXHJcXG4nKSB7XG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uLmluc2VydFBhcmFncmFwaCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24uaW5zZXJ0Tm9kZXMoWyRjcmVhdGVUYWJOb2RlKCldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudFNlbGVjdGlvbi5pbnNlcnRUZXh0KHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uaW5zZXJ0UmF3VGV4dCh0ZXh0KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRydXN0SFRNTChodG1sKSB7XG4gIGlmICh3aW5kb3cudHJ1c3RlZFR5cGVzICYmIHdpbmRvdy50cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KSB7XG4gICAgY29uc3QgcG9saWN5ID0gd2luZG93LnRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3koJ2xleGljYWwnLCB7XG4gICAgICBjcmVhdGVIVE1MOiBpbnB1dCA9PiBpbnB1dFxuICAgIH0pO1xuICAgIHJldHVybiBwb2xpY3kuY3JlYXRlSFRNTChodG1sKTtcbiAgfVxuICByZXR1cm4gaHRtbDtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIExleGljYWwgbm9kZXMgaW50byB0aGUgZWRpdG9yIHVzaW5nIGRpZmZlcmVudCBzdHJhdGVnaWVzIGRlcGVuZGluZyBvblxuICogc29tZSBzaW1wbGUgc2VsZWN0aW9uLWJhc2VkIGhldXJpc3RpY3MuIElmIHlvdSdyZSBsb29raW5nIGZvciBhIGdlbmVyaWMgd2F5IHRvXG4gKiB0byBpbnNlcnQgbm9kZXMgaW50byB0aGUgZWRpdG9yIGF0IGEgc3BlY2lmaWMgc2VsZWN0aW9uIHBvaW50LCB5b3UgcHJvYmFibHkgd2FudFxuICoge0BsaW5rIGxleGljYWwuJGluc2VydE5vZGVzfVxuICpcbiAqIEBwYXJhbSBlZGl0b3IgTGV4aWNhbEVkaXRvciBpbnN0YW5jZSB0byBpbnNlcnQgdGhlIG5vZGVzIGludG8uXG4gKiBAcGFyYW0gbm9kZXMgVGhlIG5vZGVzIHRvIGluc2VydC5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gVGhlIHNlbGVjdGlvbiB0byBpbnNlcnQgdGhlIG5vZGVzIGludG8uXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnRHZW5lcmF0ZWROb2RlcyhlZGl0b3IsIG5vZGVzLCBzZWxlY3Rpb24pIHtcbiAgaWYgKCFlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9JTlNFUlRfQ0xJUEJPQVJEX05PREVTX0NPTU1BTkQsIHtcbiAgICBub2RlcyxcbiAgICBzZWxlY3Rpb25cbiAgfSkpIHtcbiAgICBzZWxlY3Rpb24uaW5zZXJ0Tm9kZXMobm9kZXMpO1xuICB9XG4gIHJldHVybjtcbn1cbmZ1bmN0aW9uIGV4cG9ydE5vZGVUb0pTT04obm9kZSkge1xuICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IG5vZGUuZXhwb3J0SlNPTigpO1xuICBjb25zdCBub2RlQ2xhc3MgPSBub2RlLmNvbnN0cnVjdG9yO1xuICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSAhPT0gbm9kZUNsYXNzLmdldFR5cGUoKSkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IC5leHBvcnRKU09OKCkuYCk7XG4gICAgfVxuICB9XG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZHJlbiA9IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzZXJpYWxpemVkQ2hpbGRyZW4pKSB7XG4gICAgICB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gaXMgYW4gZWxlbWVudCBidXQgLmV4cG9ydEpTT04oKSBkb2VzIG5vdCBoYXZlIGEgY2hpbGRyZW4gYXJyYXkuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkTm9kZTtcbn1cbmZ1bmN0aW9uICRhcHBlbmROb2Rlc1RvSlNPTihlZGl0b3IsIHNlbGVjdGlvbiwgY3VycmVudE5vZGUsIHRhcmdldEFycmF5ID0gW10pIHtcbiAgbGV0IHNob3VsZEluY2x1ZGUgPSBzZWxlY3Rpb24gIT09IG51bGwgPyBjdXJyZW50Tm9kZS5pc1NlbGVjdGVkKHNlbGVjdGlvbikgOiB0cnVlO1xuICBjb25zdCBzaG91bGRFeGNsdWRlID0gJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmIGN1cnJlbnROb2RlLmV4Y2x1ZGVGcm9tQ29weSgnaHRtbCcpO1xuICBsZXQgdGFyZ2V0ID0gY3VycmVudE5vZGU7XG4gIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICBsZXQgY2xvbmUgPSAkY2xvbmVXaXRoUHJvcGVydGllcyhjdXJyZW50Tm9kZSk7XG4gICAgY2xvbmUgPSAkaXNUZXh0Tm9kZShjbG9uZSkgJiYgc2VsZWN0aW9uICE9PSBudWxsID8gJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQoc2VsZWN0aW9uLCBjbG9uZSkgOiBjbG9uZTtcbiAgICB0YXJnZXQgPSBjbG9uZTtcbiAgfVxuICBjb25zdCBjaGlsZHJlbiA9ICRpc0VsZW1lbnROb2RlKHRhcmdldCkgPyB0YXJnZXQuZ2V0Q2hpbGRyZW4oKSA6IFtdO1xuICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IGV4cG9ydE5vZGVUb0pTT04odGFyZ2V0KTtcblxuICAvLyBUT0RPOiBUZXh0Tm9kZSBjYWxscyBnZXRUZXh0Q29udGVudCgpIChOT1Qgbm9kZS5fX3RleHQpIHdpdGhpbiBpdHMgZXhwb3J0SlNPTiBtZXRob2RcbiAgLy8gd2hpY2ggdXNlcyBnZXRMYXRlc3QoKSB0byBnZXQgdGhlIHRleHQgZnJvbSB0aGUgb3JpZ2luYWwgbm9kZSB3aXRoIHRoZSBzYW1lIGtleS5cbiAgLy8gVGhpcyBpcyBhIGRlZXBlciBpc3N1ZSB3aXRoIHRoZSB3b3JkIFwiY2xvbmVcIiBoZXJlLCBpdCdzIHN0aWxsIGEgcmVmZXJlbmNlIHRvIHRoZVxuICAvLyBzYW1lIG5vZGUgYXMgZmFyIGFzIHRoZSBMZXhpY2FsRWRpdG9yIGlzIGNvbmNlcm5lZCBzaW5jZSBpdCBzaGFyZXMgYSBrZXkuXG4gIC8vIFdlIG5lZWQgYSB3YXkgdG8gY3JlYXRlIGEgY2xvbmUgb2YgYSBOb2RlIGluIG1lbW9yeSB3aXRoIGl0cyBvd24ga2V5LCBidXRcbiAgLy8gdW50aWwgdGhlbiB0aGlzIGhhY2sgd2lsbCB3b3JrIGZvciB0aGUgc2VsZWN0ZWQgdGV4dCBleHRyYWN0IHVzZSBjYXNlLlxuICBpZiAoJGlzVGV4dE5vZGUodGFyZ2V0KSkge1xuICAgIGNvbnN0IHRleHQgPSB0YXJnZXQuX190ZXh0O1xuICAgIC8vIElmIGFuIHVuY29sbGFwc2VkIHNlbGVjdGlvbiBlbmRzIG9yIHN0YXJ0cyBhdCB0aGUgZW5kIG9mIGEgbGluZSBvZiBzcGVjaWFsaXplZCxcbiAgICAvLyBUZXh0Tm9kZXMsIHN1Y2ggYXMgY29kZSB0b2tlbnMsIHdlIHdpbGwgZ2V0IGEgJ2JsYW5rJyBUZXh0Tm9kZSBoZXJlLCBpLmUuLCBvbmVcbiAgICAvLyB3aXRoIHRleHQgb2YgbGVuZ3RoIDAuIFdlIGRvbid0IHdhbnQgdGhpcywgaXQgbWFrZXMgYSBjb25mdXNpbmcgbWVzcy4gUmVzZXQhXG4gICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgc2VyaWFsaXplZE5vZGUudGV4dCA9IHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZEluY2x1ZGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IHNob3VsZEluY2x1ZGVDaGlsZCA9ICRhcHBlbmROb2Rlc1RvSlNPTihlZGl0b3IsIHNlbGVjdGlvbiwgY2hpbGROb2RlLCBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbik7XG4gICAgaWYgKCFzaG91bGRJbmNsdWRlICYmICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiBzaG91bGRJbmNsdWRlQ2hpbGQgJiYgY3VycmVudE5vZGUuZXh0cmFjdFdpdGhDaGlsZChjaGlsZE5vZGUsIHNlbGVjdGlvbiwgJ2Nsb25lJykpIHtcbiAgICAgIHNob3VsZEluY2x1ZGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoc2hvdWxkSW5jbHVkZSAmJiAhc2hvdWxkRXhjbHVkZSkge1xuICAgIHRhcmdldEFycmF5LnB1c2goc2VyaWFsaXplZE5vZGUpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VyaWFsaXplZE5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZENoaWxkTm9kZSA9IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuW2ldO1xuICAgICAgdGFyZ2V0QXJyYXkucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNob3VsZEluY2x1ZGU7XG59XG5cbi8vIFRPRE8gd2h5ICQgZnVuY3Rpb24gd2l0aCBFZGl0b3IgaW5zdGFuY2U/XG4vKipcbiAqIEdldHMgdGhlIExleGljYWwgSlNPTiBvZiB0aGUgbm9kZXMgaW5zaWRlIHRoZSBwcm92aWRlZCBTZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIGVkaXRvciBMZXhpY2FsRWRpdG9yIHRvIGdldCB0aGUgSlNPTiBjb250ZW50IGZyb20uXG4gKiBAcGFyYW0gc2VsZWN0aW9uIFNlbGVjdGlvbiB0byBnZXQgdGhlIEpTT04gY29udGVudCBmcm9tLlxuICogQHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGVkaXRvciBuYW1lc3BhY2UgYW5kIGEgbGlzdCBvZiBzZXJpYWxpemFibGUgbm9kZXMgYXMgSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiAkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXMoZWRpdG9yLCBzZWxlY3Rpb24pIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gIGNvbnN0IHRvcExldmVsQ2hpbGRyZW4gPSByb290LmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9wTGV2ZWxDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvcExldmVsTm9kZSA9IHRvcExldmVsQ2hpbGRyZW5baV07XG4gICAgJGFwcGVuZE5vZGVzVG9KU09OKGVkaXRvciwgc2VsZWN0aW9uLCB0b3BMZXZlbE5vZGUsIG5vZGVzKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWVzcGFjZTogZWRpdG9yLl9jb25maWcubmFtZXNwYWNlLFxuICAgIG5vZGVzXG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgdGFrZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb25mb3JtaW5nIHRvIHRoZSBCYXNlU2VyYWxpemVkTm9kZSBpbnRlcmZhY2UgYW5kIHJldHVybnNcbiAqIGFuIEFycmF5IGNvbnRhaW5pbmcgaW5zdGFuY2VzIG9mIHRoZSBjb3JyZXNwb25kaW5nIExleGljYWxOb2RlIGNsYXNzZXMgcmVnaXN0ZXJlZCBvbiB0aGUgZWRpdG9yLlxuICogTm9ybWFsbHksIHlvdSdkIGdldCBhbiBBcnJheSBvZiBCYXNlU2VyaWFsaXplZCBub2RlcyBmcm9tIHtAbGluayAkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXN9XG4gKlxuICogQHBhcmFtIHNlcmlhbGl6ZWROb2RlcyBhbiBBcnJheSBvZiBvYmplY3RzIGNvbmZvcm1pbmcgdG8gdGhlIEJhc2VTZXJpYWxpemVkTm9kZSBpbnRlcmZhY2UuXG4gKiBAcmV0dXJucyBhbiBBcnJheSBvZiBMZXhpY2FsIE5vZGUgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gJGdlbmVyYXRlTm9kZXNGcm9tU2VyaWFsaXplZE5vZGVzKHNlcmlhbGl6ZWROb2Rlcykge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcmlhbGl6ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplZE5vZGVzW2ldO1xuICAgIGNvbnN0IG5vZGUgPSAkcGFyc2VTZXJpYWxpemVkTm9kZShzZXJpYWxpemVkTm9kZSk7XG4gICAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAkYWRkTm9kZVN0eWxlKG5vZGUpO1xuICAgIH1cbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cbmNvbnN0IEVWRU5UX0xBVEVOQ1kgPSA1MDtcbmxldCBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSBudWxsO1xuXG4vLyBUT0RPIGN1c3RvbSBzZWxlY3Rpb25cbi8vIFRPRE8gcG90ZW50aWFsbHkgaGF2ZSBhIG5vZGUgY3VzdG9taXphYmxlIHZlcnNpb24gZm9yIHBsYWluIHRleHRcbi8qKlxuICogQ29waWVzIHRoZSBjb250ZW50IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB0byB0aGUgY2xpcGJvYXJkIGluXG4gKiB0ZXh0L3BsYWluLCB0ZXh0L2h0bWwsIGFuZCBhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yIChMZXhpY2FsIEpTT04pXG4gKiBmb3JtYXRzLlxuICpcbiAqIEBwYXJhbSBlZGl0b3IgdGhlIExleGljYWxFZGl0b3IgaW5zdGFuY2UgdG8gY29weSBjb250ZW50IGZyb21cbiAqIEBwYXJhbSBldmVudCB0aGUgbmF0aXZlIGJyb3dzZXIgQ2xpcGJvYXJkRXZlbnQgdG8gYWRkIHRoZSBjb250ZW50IHRvLlxuICogQHJldHVybnNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY29weVRvQ2xpcGJvYXJkKGVkaXRvciwgZXZlbnQsIGRhdGEpIHtcbiAgaWYgKGNsaXBib2FyZEV2ZW50VGltZW91dCAhPT0gbnVsbCkge1xuICAgIC8vIFByZXZlbnQgd2VpcmQgcmFjZSBjb25kaXRpb25zIHRoYXQgY2FuIGhhcHBlbiB3aGVuIHRoaXMgZnVuY3Rpb24gaXMgcnVuIG11bHRpcGxlIHRpbWVzXG4gICAgLy8gc3luY2hyb25vdXNseS4gSW4gdGhlIGZ1dHVyZSwgd2UgY2FuIGRvIGJldHRlciwgd2UgY2FuIGNhbmNlbC9vdmVycmlkZSB0aGUgcHJldmlvdXNseSBydW5uaW5nIGpvYi5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGV2ZW50ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICByZXNvbHZlKCRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIGV2ZW50LCBkYXRhKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICBjb25zdCBlZGl0b3JXaW5kb3cgPSBlZGl0b3IuX3dpbmRvdyB8fCB3aW5kb3c7XG4gIGNvbnN0IHdpbmRvd0RvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yV2luZG93KTtcbiAgaWYgKHJvb3RFbGVtZW50ID09PSBudWxsIHx8IGRvbVNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBlbGVtZW50ID0gd2luZG93RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGZpeGVkOyB0b3A6IC0xMDAwcHg7JztcbiAgZWxlbWVudC5hcHBlbmQod2luZG93RG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyMnKSk7XG4gIHJvb3RFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgY29uc3QgcmFuZ2UgPSBuZXcgUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoZWxlbWVudCwgMCk7XG4gIHJhbmdlLnNldEVuZChlbGVtZW50LCAxKTtcbiAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICBkb21TZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDT1BZX0NPTU1BTkQsIHNlY29uZEV2ZW50ID0+IHtcbiAgICAgIGlmIChvYmplY3RLbGFzc0VxdWFscyhzZWNvbmRFdmVudCwgQ2xpcGJvYXJkRXZlbnQpKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgIGlmIChjbGlwYm9hcmRFdmVudFRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGNsaXBib2FyZEV2ZW50VGltZW91dCk7XG4gICAgICAgICAgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIHNlY29uZEV2ZW50LCBkYXRhKSk7XG4gICAgICB9XG4gICAgICAvLyBCbG9jayB0aGUgZW50aXJlIGNvcHkgZmxvdyB3aGlsZSB3ZSB3YWl0IGZvciB0aGUgbmV4dCBDbGlwYm9hcmRFdmVudFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCk7XG4gICAgLy8gSWYgdGhlIGFib3ZlIGhhY2sgZXhlY0NvbW1hbmQgaGFjayB3b3JrcywgdGhpcyB0aW1lb3V0IGNvZGUgc2hvdWxkIG5ldmVyIGZpcmUuIE90aGVyd2lzZSxcbiAgICAvLyB0aGUgbGlzdGVuZXIgd2lsbCBiZSBxdWlja2x5IGZyZWVkIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHJldXNlIGl0IGFnYWluXG4gICAgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgIGNsaXBib2FyZEV2ZW50VGltZW91dCA9IG51bGw7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICB9LCBFVkVOVF9MQVRFTkNZKTtcbiAgICB3aW5kb3dEb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gIH0pO1xufVxuXG4vLyBUT0RPIHNob3VsZG4ndCBwYXNzIGVkaXRvciAocGFzcyBuYW1lc3BhY2UgZGlyZWN0bHkpXG5mdW5jdGlvbiAkY29weVRvQ2xpcGJvYXJkRXZlbnQoZWRpdG9yLCBldmVudCwgZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcbiAgICBpZiAoIWRvbVNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JET00gPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgICBjb25zdCBmb2N1c0RPTSA9IGRvbVNlbGVjdGlvbi5mb2N1c05vZGU7XG4gICAgaWYgKGFuY2hvckRPTSAhPT0gbnVsbCAmJiBmb2N1c0RPTSAhPT0gbnVsbCAmJiAhaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IoZWRpdG9yLCBhbmNob3JET00sIGZvY3VzRE9NKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkYXRhID0gJGdldENsaXBib2FyZERhdGFGcm9tU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gIH1cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gIGlmIChjbGlwYm9hcmREYXRhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHNldExleGljYWxDbGlwYm9hcmREYXRhVHJhbnNmZXIoY2xpcGJvYXJkRGF0YSwgZGF0YSk7XG4gIHJldHVybiB0cnVlO1xufVxuY29uc3QgY2xpcGJvYXJkRGF0YUZ1bmN0aW9ucyA9IFtbJ3RleHQvaHRtbCcsICRnZXRIdG1sQ29udGVudF0sIFsnYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvcicsICRnZXRMZXhpY2FsQ29udGVudF1dO1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgY29udGVudCBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gdG8gc3RyaW5ncyBpblxuICogdGV4dC9wbGFpbiwgdGV4dC9odG1sLCBhbmQgYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvciAoTGV4aWNhbCBKU09OKVxuICogZm9ybWF0cyAoYXMgYXZhaWxhYmxlKS5cbiAqXG4gKiBAcGFyYW0gc2VsZWN0aW9uIHRoZSBzZWxlY3Rpb24gdG8gc2VyaWFsaXplIChkZWZhdWx0cyB0byAkZ2V0U2VsZWN0aW9uKCkpXG4gKiBAcmV0dXJucyBMZXhpY2FsQ2xpcGJvYXJkRGF0YVxuICovXG5mdW5jdGlvbiAkZ2V0Q2xpcGJvYXJkRGF0YUZyb21TZWxlY3Rpb24oc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpKSB7XG4gIGNvbnN0IGNsaXBib2FyZERhdGEgPSB7XG4gICAgJ3RleHQvcGxhaW4nOiBzZWxlY3Rpb24gPyBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKSA6ICcnXG4gIH07XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICBjb25zdCBlZGl0b3IgPSAkZ2V0RWRpdG9yKCk7XG4gICAgZm9yIChjb25zdCBbbWltZVR5cGUsICRlZGl0b3JGbl0gb2YgY2xpcGJvYXJkRGF0YUZ1bmN0aW9ucykge1xuICAgICAgY29uc3QgdiA9ICRlZGl0b3JGbihlZGl0b3IsIHNlbGVjdGlvbik7XG4gICAgICBpZiAodiAhPT0gbnVsbCkge1xuICAgICAgICBjbGlwYm9hcmREYXRhW21pbWVUeXBlXSA9IHY7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjbGlwYm9hcmREYXRhO1xufVxuXG4vKipcbiAqIENhbGwgc2V0RGF0YSBvbiB0aGUgZ2l2ZW4gY2xpcGJvYXJkRGF0YSBmb3IgZWFjaCBNSU1FIHR5cGUgcHJlc2VudFxuICogaW4gdGhlIGdpdmVuIGRhdGEgKGZyb20ge0BsaW5rICRnZXRDbGlwYm9hcmREYXRhRnJvbVNlbGVjdGlvbn0pXG4gKlxuICogQHBhcmFtIGNsaXBib2FyZERhdGEgdGhlIGV2ZW50LmNsaXBib2FyZERhdGEgdG8gcG9wdWxhdGUgZnJvbSBkYXRhXG4gKiBAcGFyYW0gZGF0YSBUaGUgbGV4aWNhbCBkYXRhXG4gKi9cbmZ1bmN0aW9uIHNldExleGljYWxDbGlwYm9hcmREYXRhVHJhbnNmZXIoY2xpcGJvYXJkRGF0YSwgZGF0YSkge1xuICBmb3IgKGNvbnN0IGsgaW4gZGF0YSkge1xuICAgIGNvbnN0IHYgPSBkYXRhW2tdO1xuICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YShrLCB2KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHsgJGdlbmVyYXRlSlNPTkZyb21TZWxlY3RlZE5vZGVzLCAkZ2VuZXJhdGVOb2Rlc0Zyb21TZXJpYWxpemVkTm9kZXMsICRnZXRDbGlwYm9hcmREYXRhRnJvbVNlbGVjdGlvbiwgJGdldEh0bWxDb250ZW50LCAkZ2V0TGV4aWNhbENvbnRlbnQsICRpbnNlcnREYXRhVHJhbnNmZXJGb3JQbGFpblRleHQsICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dCwgJGluc2VydEdlbmVyYXRlZE5vZGVzLCBjb3B5VG9DbGlwYm9hcmQsIHNldExleGljYWxDbGlwYm9hcmREYXRhVHJhbnNmZXIgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lexical+clipboard@0.28.0/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\n");

/***/ })

};
;