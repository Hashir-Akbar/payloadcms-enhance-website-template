"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+utils@0.28.0";
exports.ids = ["vendor-chunks/@lexical+utils@0.28.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@lexical+utils@0.28.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+utils@0.28.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $descendantsMatching: () => (/* binding */ $descendantsMatching),\n/* harmony export */   $dfs: () => (/* binding */ $dfs),\n/* harmony export */   $dfsIterator: () => (/* binding */ $dfsIterator),\n/* harmony export */   $filter: () => (/* binding */ $filter),\n/* harmony export */   $findMatchingParent: () => (/* binding */ $findMatchingParent),\n/* harmony export */   $firstToLastIterator: () => (/* binding */ $firstToLastIterator),\n/* harmony export */   $getAdjacentCaret: () => (/* binding */ $getAdjacentCaret),\n/* harmony export */   $getAdjacentSiblingOrParentSiblingCaret: () => (/* binding */ $getAdjacentSiblingOrParentSiblingCaret),\n/* harmony export */   $getDepth: () => (/* binding */ $getDepth),\n/* harmony export */   $getNearestBlockElementAncestorOrThrow: () => (/* binding */ $getNearestBlockElementAncestorOrThrow),\n/* harmony export */   $getNearestNodeOfType: () => (/* binding */ $getNearestNodeOfType),\n/* harmony export */   $getNextRightPreorderNode: () => (/* binding */ $getNextRightPreorderNode),\n/* harmony export */   $getNextSiblingOrParentSibling: () => (/* binding */ $getNextSiblingOrParentSibling),\n/* harmony export */   $insertFirst: () => (/* binding */ $insertFirst),\n/* harmony export */   $insertNodeToNearestRoot: () => (/* binding */ $insertNodeToNearestRoot),\n/* harmony export */   $insertNodeToNearestRootAtCaret: () => (/* binding */ $insertNodeToNearestRootAtCaret),\n/* harmony export */   $isEditorIsNestedEditor: () => (/* binding */ $isEditorIsNestedEditor),\n/* harmony export */   $lastToFirstIterator: () => (/* binding */ $lastToFirstIterator),\n/* harmony export */   $restoreEditorState: () => (/* binding */ $restoreEditorState),\n/* harmony export */   $reverseDfs: () => (/* binding */ $reverseDfs),\n/* harmony export */   $reverseDfsIterator: () => (/* binding */ $reverseDfsIterator),\n/* harmony export */   $splitNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode),\n/* harmony export */   $unwrapAndFilterDescendants: () => (/* binding */ $unwrapAndFilterDescendants),\n/* harmony export */   $unwrapNode: () => (/* binding */ $unwrapNode),\n/* harmony export */   $wrapNodeInElement: () => (/* binding */ $wrapNodeInElement),\n/* harmony export */   CAN_USE_BEFORE_INPUT: () => (/* binding */ CAN_USE_BEFORE_INPUT),\n/* harmony export */   CAN_USE_DOM: () => (/* binding */ CAN_USE_DOM),\n/* harmony export */   IS_ANDROID: () => (/* binding */ IS_ANDROID),\n/* harmony export */   IS_ANDROID_CHROME: () => (/* binding */ IS_ANDROID_CHROME),\n/* harmony export */   IS_APPLE: () => (/* binding */ IS_APPLE),\n/* harmony export */   IS_APPLE_WEBKIT: () => (/* binding */ IS_APPLE_WEBKIT),\n/* harmony export */   IS_CHROME: () => (/* binding */ IS_CHROME),\n/* harmony export */   IS_FIREFOX: () => (/* binding */ IS_FIREFOX),\n/* harmony export */   IS_IOS: () => (/* binding */ IS_IOS),\n/* harmony export */   IS_SAFARI: () => (/* binding */ IS_SAFARI),\n/* harmony export */   addClassNamesToElement: () => (/* binding */ addClassNamesToElement),\n/* harmony export */   calculateZoomLevel: () => (/* binding */ calculateZoomLevel),\n/* harmony export */   isBlockDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode),\n/* harmony export */   isHTMLAnchorElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement),\n/* harmony export */   isHTMLElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement),\n/* harmony export */   isInlineDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode),\n/* harmony export */   isMimeType: () => (/* binding */ isMimeType),\n/* harmony export */   makeStateWrapper: () => (/* binding */ makeStateWrapper),\n/* harmony export */   markSelection: () => (/* binding */ markSelection),\n/* harmony export */   mediaFileReader: () => (/* binding */ mediaFileReader),\n/* harmony export */   mergeRegister: () => (/* binding */ mergeRegister),\n/* harmony export */   objectKlassEquals: () => (/* binding */ objectKlassEquals),\n/* harmony export */   positionNodeOnRange: () => (/* binding */ mlcPositionNodeOnRange),\n/* harmony export */   registerNestedElementResolver: () => (/* binding */ registerNestedElementResolver),\n/* harmony export */   removeClassNamesFromElement: () => (/* binding */ removeClassNamesFromElement),\n/* harmony export */   selectionAlwaysOnDisplay: () => (/* binding */ selectionAlwaysOnDisplay)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/.pnpm/lexical@0.28.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"(rsc)/./node_modules/.pnpm/@lexical+selection@0.28.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction prependDOMNode(parent, node) {\n  parent.insertBefore(node, parent.firstChild);\n}\n\n/**\n * Place one or multiple newly created Nodes at the passed Range's position.\n * Multiple nodes will only be created when the Range spans multiple lines (aka\n * client rects).\n *\n * This function can come particularly useful to highlight particular parts of\n * the text without interfering with the EditorState, that will often replicate\n * the state across collab and clipboard.\n *\n * This function accounts for DOM updates which can modify the passed Range.\n * Hence, the function return to remove the listener.\n */\nfunction mlcPositionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  wrapperNode.style.position = 'relative';\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: parentLeft,\n      top: parentTop\n    } = parentDOMNode.getBoundingClientRect();\n    const rects = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.createRectsFromDOMRange)(editor, range);\n    if (!wrapperNode.isConnected) {\n      prependDOMNode(parentDOMNode, wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - parentLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - parentTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(currentParentDOMNode)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction rangeTargetFromPoint(point, node, dom) {\n  if (point.type === 'text' || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    const textDOM = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMTextNode)(dom) || dom;\n    return [textDOM, point.offset];\n  } else {\n    const slot = node.getDOMSlot(dom);\n    return [slot.element, slot.getFirstChildOffset() + point.offset];\n  }\n}\nfunction rangeFromPoints(editor, anchor, anchorNode, anchorDOM, focus, focusNode, focusDOM) {\n  const editorDocument = editor._window ? editor._window.document : document;\n  const range = editorDocument.createRange();\n  if (focusNode.isBefore(anchorNode)) {\n    range.setStart(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n    range.setEnd(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n  } else {\n    range.setStart(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n    range.setEnd(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n  }\n  return range;\n}\n/**\n * Place one or multiple newly created Nodes at the current selection. Multiple\n * nodes will only be created when the selection spans multiple lines (aka\n * client rects).\n *\n * This function can come useful when you want to show the selection but the\n * editor has been focused away.\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorNodeDOM = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusNodeDOM = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM !== previousAnchorNodeDOM || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey();\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM !== previousFocusNodeDOM || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey();\n      if ((differentAnchorDOM || differentFocusDOM) && currentAnchorNodeDOM !== null && currentFocusNodeDOM !== null) {\n        const range = rangeFromPoints(editor, anchor, currentAnchorNode, currentAnchorNodeDOM, focus, currentFocusNode, currentFocusNodeDOM);\n        removeRangeListener();\n        removeRangeListener = mlcPositionNodeOnRange(editor, range, domNodes => {\n          if (onReposition === undefined) {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n          } else {\n            onReposition(domNodes);\n          }\n        });\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorNodeDOM = currentAnchorNodeDOM;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusNodeDOM = currentFocusNodeDOM;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction selectionAlwaysOnDisplay(editor) {\n  let removeSelectionMark = null;\n  const onSelectionChange = () => {\n    const domSelection = getSelection();\n    const domAnchorNode = domSelection && domSelection.anchorNode;\n    const editorRootElement = editor.getRootElement();\n    const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);\n    if (isSelectionInsideEditor) {\n      if (removeSelectionMark !== null) {\n        removeSelectionMark();\n        removeSelectionMark = null;\n      }\n    } else {\n      if (removeSelectionMark === null) {\n        removeSelectionMark = markSelection(editor);\n      }\n    }\n  };\n  document.addEventListener('selectionchange', onSelectionChange);\n  return () => {\n    if (removeSelectionMark !== null) {\n      removeSelectionMark();\n    }\n    document.removeEventListener('selectionchange', onSelectionChange);\n  };\n}\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the start node).\n */\nfunction $dfs(startNode, endNode) {\n  return Array.from($dfsIterator(startNode, endNode));\n}\n\n/**\n * Get the adjacent caret in the same direction\n *\n * @param caret A caret or null\n * @returns `caret.getAdjacentCaret()` or `null`\n */\nfunction $getAdjacentCaret(caret) {\n  return caret ? caret.getAdjacentCaret() : null;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfs(startNode, endNode) {\n  return Array.from($reverseDfsIterator(startNode, endNode));\n}\n\n/**\n * $dfs iterator (left to right). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $dfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('next', startNode, endNode);\n}\nfunction $getEndCaret(startNode, direction) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(startNode, direction));\n  return rval && rval[0];\n}\nfunction $dfsCaretIterator(direction, startNode, endNode) {\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const start = startNode || root;\n  const startCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(start) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(start, direction) : (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(start, direction);\n  const startDepth = $getDepth(start);\n  const endCaret = endNode ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaretOrSelf)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(endNode, direction))) : $getEndCaret(start, direction);\n  let depth = startDepth;\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.makeStepwiseIterator)({\n    hasNext: state => state !== null,\n    initial: startCaret,\n    map: state => ({\n      depth,\n      node: state.origin\n    }),\n    step: state => {\n      if (state.isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(state)) {\n        depth++;\n      }\n      const rval = $getAdjacentSiblingOrParentSiblingCaret(state);\n      if (!rval || rval[0].isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      depth += rval[1];\n      return rval[0];\n    }\n  });\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getNextSiblingOrParentSibling(node) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(node, 'next'));\n  return rval && [rval[0].origin, rval[1]];\n}\nfunction $getDepth(node) {\n  let depth = -1;\n  for (let innerNode = node; innerNode !== null; innerNode = innerNode.getParent()) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to parent and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  const startCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaretOrSelf)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(startingNode, 'previous'));\n  const next = $getAdjacentSiblingOrParentSiblingCaret(startCaret, 'root');\n  return next && next[0].origin;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('previous', startNode, endNode);\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(blockNode)) {\n    {\n      formatDevErrorMessage(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  let initialCaret;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    initialCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$caretFromPoint)(selection.focus, 'next');\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      const lastNode = nodes[nodes.length - 1];\n      if (lastNode) {\n        initialCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(lastNode, 'next');\n      }\n    }\n    initialCaret = initialCaret || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)(), 'previous').getFlipped().insert((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n  }\n  const insertCaret = $insertNodeToNearestRootAtCaret(node, initialCaret);\n  const adjacent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(insertCaret);\n  const selectionCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(adjacent) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)(adjacent) : insertCaret;\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelectionFromCaretRange)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCollapsedCaretRange)(selectionCaret));\n  return node.getLatest();\n}\n\n/**\n * If the insertion caret is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be inserted there, otherwise the parent nodes will be split according to the\n * given options.\n * @param node - The node to be inserted\n * @param caret - The location to insert or split from\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRootAtCaret(node, caret, options) {\n  let insertCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCaretInDirection)(caret, 'next');\n  for (let nextCaret = insertCaret; nextCaret; nextCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$splitAtPointCaretNext)(nextCaret, options)) {\n    insertCaret = nextCaret;\n  }\n  if (!!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextPointCaret)(insertCaret)) {\n    formatDevErrorMessage(`$insertNodeToNearestRootAtCaret: An unattached TextNode can not be split`);\n  }\n  insertCaret.insert(node.isInline() ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)().append(node) : node);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCaretInDirection)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(node.getLatest(), 'next'), caret.direction);\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(parent, 'next').insert(node);\n}\nlet NEEDS_MANUAL_ZOOM = IS_FIREFOX || !CAN_USE_DOM ? false : undefined;\nfunction needsManualZoom() {\n  if (NEEDS_MANUAL_ZOOM === undefined) {\n    // If the browser implements standardized CSS zoom, then the client rect\n    // will be wider after zoom is applied\n    // https://chromestatus.com/feature/5198254868529152\n    // https://github.com/facebook/lexical/issues/6863\n    const div = document.createElement('div');\n    div.style.cssText = 'position: absolute; opacity: 0; width: 100px; left: -1000px;';\n    document.body.appendChild(div);\n    const noZoom = div.getBoundingClientRect();\n    div.style.setProperty('zoom', '2');\n    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;\n    document.body.removeChild(div);\n  }\n  return NEEDS_MANUAL_ZOOM;\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property. For browsers that implement standardized CSS\n * zoom (Firefox, Chrome >= 128), this will always return 1.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  let zoom = 1;\n  if (needsManualZoom()) {\n    while (element) {\n      zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n      element = element.parentElement;\n    }\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\n/**\n * A depth first last-to-first traversal of root that stops at each node that matches\n * $predicate and ensures that its parent is root. This is typically used to discard\n * invalid or unsupported wrapping nodes. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * @param root The root to start the traversal\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns true if this unwrapped or removed any nodes\n */\nfunction $unwrapAndFilterDescendants(root, $predicate) {\n  return $unwrapAndFilterDescendantsImpl(root, $predicate, null);\n}\nfunction $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {\n  let didMutate = false;\n  for (const node of $lastToFirstIterator(root)) {\n    if ($predicate(node)) {\n      if ($onSuccess !== null) {\n        $onSuccess(node);\n      }\n      continue;\n    }\n    didMutate = true;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess || (child => node.insertAfter(child)));\n    }\n    node.remove();\n  }\n  return didMutate;\n}\n\n/**\n * A depth first traversal of the children array that stops at and collects\n * each node that `$predicate` matches. This is typically used to discard\n * invalid or unsupported wrapping nodes on a children array in the `after`\n * of an {@link lexical!DOMConversionOutput}. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * This function is read-only and performs no mutation operations, which makes\n * it suitable for import and export purposes but likely not for any in-place\n * mutation. You should use {@link $unwrapAndFilterDescendants} for in-place\n * mutations such as node transforms.\n *\n * @param children The children to traverse\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns The children or their descendants that match $predicate\n */\n\nfunction $descendantsMatching(children, $predicate) {\n  const result = [];\n  const stack = Array.from(children).reverse();\n  for (let child = stack.pop(); child !== undefined; child = stack.pop()) {\n    if ($predicate(child)) {\n      result.push(child);\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n      for (const grandchild of $lastToFirstIterator(child)) {\n        stack.push(grandchild);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Return an iterator that yields each child of node from first to last, taking\n * care to preserve the next sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $firstToLastIterator(node) {\n  return $childIterator((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(node, 'next'));\n}\n\n/**\n * Return an iterator that yields each child of node from last to first, taking\n * care to preserve the previous sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $lastToFirstIterator(node) {\n  return $childIterator((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(node, 'previous'));\n}\nfunction $childIterator(startCaret) {\n  const seen = new Set() ;\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.makeStepwiseIterator)({\n    hasNext: lexical__WEBPACK_IMPORTED_MODULE_0__.$isSiblingCaret,\n    initial: startCaret.getAdjacentCaret(),\n    map: caret => {\n      const origin = caret.origin.getLatest();\n      if (seen !== null) {\n        const key = origin.getKey();\n        if (!!seen.has(key)) {\n          formatDevErrorMessage(`$childIterator: Cycle detected, node with key ${String(key)} has already been traversed`);\n        }\n        seen.add(key);\n      }\n      return origin;\n    },\n    step: caret => caret.getAdjacentCaret()\n  });\n}\n\n/**\n * Replace this node with its children\n *\n * @param node The ElementNode to unwrap and remove\n */\nfunction $unwrapNode(node) {\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$rewindSiblingCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(node, 'next')).splice(1, node.getChildren());\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getAdjacentSiblingOrParentSiblingCaret(startCaret, rootMode = 'root') {\n  let depthDiff = 0;\n  let caret = startCaret;\n  let nextCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(caret);\n  while (nextCaret === null) {\n    depthDiff--;\n    nextCaret = caret.getParentCaret(rootMode);\n    if (!nextCaret) {\n      return null;\n    }\n    caret = nextCaret;\n    nextCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(caret);\n  }\n  return nextCaret && [nextCaret, depthDiff];\n}\n\n/**\n * A wrapper that creates bound functions and methods for the\n * StateConfig to save some boilerplate when defining methods\n * or exporting only the accessors from your modules rather\n * than exposing the StateConfig directly.\n */\n\n/**\n * EXPERIMENTAL\n *\n * A convenience interface for working with {@link $getState} and\n * {@link $setState}.\n *\n * @param stateConfig The stateConfig to wrap with convenience functionality\n * @returns a StateWrapper\n */\nfunction makeStateWrapper(stateConfig) {\n  const $get = node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getState)(node, stateConfig);\n  const $set = (node, valueOrUpdater) => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setState)(node, stateConfig, valueOrUpdater);\n  return {\n    $get,\n    $set,\n    accessors: [$get, $set],\n    makeGetterMethod: () => function $getter() {\n      return $get(this);\n    },\n    makeSetterMethod: () => function $setter(valueOrUpdater) {\n      return $set(this, valueOrUpdater);\n    },\n    stateConfig\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrdXRpbHNAMC4yOC4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC91dGlscy9MZXhpY2FsVXRpbHMuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnaEI7QUFDdGE7QUFDN0M7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0JBQWtCLDJFQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNEQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLHVEQUFjO0FBQzlDLG9CQUFvQix1REFBYztBQUNsQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFhO0FBQ3JDLFdBQVcsMERBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrREFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQXNCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlCQUFpQjtBQUM5RCxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtEQUFTO0FBQ2hDLHlDQUF5QyxrREFBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRTg2QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxoYXNoaVxcRGVza3RvcFxcZnVzaW9uaXF4LXByb2plY3RzXFxmdXNpb25pcXhcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBsZXhpY2FsK3V0aWxzQDAuMjguMFxcbm9kZV9tb2R1bGVzXFxAbGV4aWNhbFxcdXRpbHNcXExleGljYWxVdGlscy5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgJGdldFNlbGVjdGlvbiwgJGlzUmFuZ2VTZWxlY3Rpb24sICRpc0VsZW1lbnROb2RlLCBnZXRET01UZXh0Tm9kZSwgJGdldFJvb3QsICRnZXRDaGlsZENhcmV0LCAkZ2V0U2libGluZ0NhcmV0LCAkZ2V0QWRqYWNlbnRDaGlsZENhcmV0LCAkZ2V0Q2hpbGRDYXJldE9yU2VsZiwgbWFrZVN0ZXB3aXNlSXRlcmF0b3IsICRpc0NoaWxkQ2FyZXQsICRjbG9uZVdpdGhQcm9wZXJ0aWVzLCAkc2V0U2VsZWN0aW9uLCAkZ2V0UHJldmlvdXNTZWxlY3Rpb24sICRjYXJldEZyb21Qb2ludCwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRub3JtYWxpemVDYXJldCwgJHNldFNlbGVjdGlvbkZyb21DYXJldFJhbmdlLCAkZ2V0Q29sbGFwc2VkQ2FyZXRSYW5nZSwgJGdldENhcmV0SW5EaXJlY3Rpb24sICRzcGxpdEF0UG9pbnRDYXJldE5leHQsICRpc1RleHRQb2ludENhcmV0LCAkaXNTaWJsaW5nQ2FyZXQsICRyZXdpbmRTaWJsaW5nQ2FyZXQsICRnZXRTdGF0ZSwgJHNldFN0YXRlIH0gZnJvbSAnbGV4aWNhbCc7XG5leHBvcnQgeyAkc3BsaXROb2RlLCBpc0Jsb2NrRG9tTm9kZSwgaXNIVE1MQW5jaG9yRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNJbmxpbmVEb21Ob2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5pbXBvcnQgeyBjcmVhdGVSZWN0c0Zyb21ET01SYW5nZSB9IGZyb20gJ0BsZXhpY2FsL3NlbGVjdGlvbic7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgYGludmFyaWFudGAgY2FsbHMuXG5cbmZ1bmN0aW9uIGZvcm1hdERldkVycm9yTWVzc2FnZShtZXNzYWdlKSB7XG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSQxID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSQxICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogbnVsbDtcbmNvbnN0IElTX0FQUExFJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfRklSRUZPWCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCQxID0gQ0FOX1VTRV9ET00kMSAmJiAnSW5wdXRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgPyAnZ2V0VGFyZ2V0UmFuZ2VzJyBpbiBuZXcgd2luZG93LklucHV0RXZlbnQoJ2lucHV0JykgOiBmYWxzZTtcbmNvbnN0IElTX1NBRkFSSSQxID0gQ0FOX1VTRV9ET00kMSAmJiAvVmVyc2lvblxcL1tcXGQuXSsuKlNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0lPUyQxID0gQ0FOX1VTRV9ET00kMSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuY29uc3QgSVNfQU5EUk9JRCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvQW5kcm9pZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLy8gS2VlcCB0aGVzZSBpbiBjYXNlIHdlIG5lZWQgdG8gdXNlIHRoZW0gaW4gdGhlIGZ1dHVyZS5cbi8vIGV4cG9ydCBjb25zdCBJU19XSU5ET1dTOiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfQ0hST01FJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9eKD89LipDaHJvbWUpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gZXhwb3J0IGNvbnN0IGNhblVzZVRleHRJbnB1dEV2ZW50OiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbmNvbnN0IElTX0FORFJPSURfQ0hST01FJDEgPSBDQU5fVVNFX0RPTSQxICYmIElTX0FORFJPSUQkMSAmJiBJU19DSFJPTUUkMTtcbmNvbnN0IElTX0FQUExFX1dFQktJVCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvQXBwbGVXZWJLaXRcXC9bXFxkLl0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFJU19DSFJPTUUkMTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc05hbWVzKC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgcnZhbCA9IFtdO1xuICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG4gICAgaWYgKGNsYXNzTmFtZSAmJiB0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZm9yIChjb25zdCBbc10gb2YgY2xhc3NOYW1lLm1hdGNoQWxsKC9cXFMrL2cpKSB7XG4gICAgICAgIHJ2YWwucHVzaChzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgYWxsIGZ1bmN0aW9ucyBwYXNzZWQgd2hlbiBjYWxsZWQuIEl0IGlzIGdlbmVyYWxseSB1c2VkXG4gKiB0byByZWdpc3RlciBtdWx0aXBsZSBsZXhpY2FsIGxpc3RlbmVycyBhbmQgdGhlbiB0ZWFyIHRoZW0gZG93biB3aXRoIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGwsIHN1Y2hcbiAqIGFzIFJlYWN0J3MgdXNlRWZmZWN0IGhvb2suXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKFxuICogICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoLi4ucmVnaXN0ZXJDb21tYW5kMSBsb2dpYyksXG4gKiAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZCguLi5yZWdpc3RlckNvbW1hbmQyIGxvZ2ljKSxcbiAqICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKC4uLnJlZ2lzdGVyQ29tbWFuZDMgbG9naWMpXG4gKiAgIClcbiAqIH0sIFtlZGl0b3JdKVxuICogYGBgXG4gKiBJbiB0aGlzIGNhc2UsIHVzZUVmZmVjdCBpcyByZXR1cm5pbmcgdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IG1lcmdlUmVnaXN0ZXIgYXMgYSBjbGVhbnVwXG4gKiBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBlaXRoZXIgdGhlIHVzZUVmZmVjdCBydW5zIGFnYWluIChkdWUgdG8gb25lIG9mIGl0cyBkZXBlbmRlbmNpZXNcbiAqIHVwZGF0aW5nKSBvciB0aGUgY29tcG9uZW50IGl0IHJlc2lkZXMgaW4gdW5tb3VudHMuXG4gKiBOb3RlIHRoZSBmdW5jdGlvbnMgZG9uJ3QgbmVjY2VzYXJpbHkgbmVlZCB0byBiZSBpbiBhbiBhcnJheSBhcyBhbGwgYXJndW1lbnRzXG4gKiBhcmUgY29uc2lkZXJlZCB0byBiZSB0aGUgZnVuYyBhcmd1bWVudCBhbmQgc3ByZWFkIGZyb20gdGhlcmUuXG4gKiBUaGUgb3JkZXIgb2YgY2xlYW51cCBpcyB0aGUgcmV2ZXJzZSBvZiB0aGUgYXJndW1lbnQgb3JkZXIuIEdlbmVyYWxseSBpdCBpc1xuICogZXhwZWN0ZWQgdGhhdCB0aGUgZmlyc3QgXCJhY3F1aXJlXCIgd2lsbCBiZSBcInJlbGVhc2VkXCIgbGFzdCAoTElGTyBvcmRlciksXG4gKiBiZWNhdXNlIGEgbGF0ZXIgc3RlcCBtYXkgaGF2ZSBzb21lIGRlcGVuZGVuY3kgb24gYW4gZWFybGllciBvbmUuXG4gKiBAcGFyYW0gZnVuYyAtIEFuIGFycmF5IG9mIGNsZWFudXAgZnVuY3Rpb25zIG1lYW50IHRvIGJlIGV4ZWN1dGVkIGJ5IHRoZSByZXR1cm5lZCBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHRoZSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBhbGwgdGhlIHBhc3NlZCBjbGVhbnVwIGZ1bmN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VSZWdpc3RlciguLi5mdW5jKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IGZ1bmMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGZ1bmNbaV0oKTtcbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgdGhlIHJlZmVyZW5jZXMgYW5kIG1ha2UgZnV0dXJlIGNhbGxzIGEgbm8tb3BcbiAgICBmdW5jLmxlbmd0aCA9IDA7XG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcHgodmFsdWUpIHtcbiAgcmV0dXJuIGAke3ZhbHVlfXB4YDtcbn1cblxuY29uc3QgbXV0YXRpb25PYnNlcnZlckNvbmZpZyA9IHtcbiAgYXR0cmlidXRlczogdHJ1ZSxcbiAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgY2hpbGRMaXN0OiB0cnVlLFxuICBzdWJ0cmVlOiB0cnVlXG59O1xuZnVuY3Rpb24gcHJlcGVuZERPTU5vZGUocGFyZW50LCBub2RlKSB7XG4gIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgcGFyZW50LmZpcnN0Q2hpbGQpO1xufVxuXG4vKipcbiAqIFBsYWNlIG9uZSBvciBtdWx0aXBsZSBuZXdseSBjcmVhdGVkIE5vZGVzIGF0IHRoZSBwYXNzZWQgUmFuZ2UncyBwb3NpdGlvbi5cbiAqIE11bHRpcGxlIG5vZGVzIHdpbGwgb25seSBiZSBjcmVhdGVkIHdoZW4gdGhlIFJhbmdlIHNwYW5zIG11bHRpcGxlIGxpbmVzIChha2FcbiAqIGNsaWVudCByZWN0cykuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gY29tZSBwYXJ0aWN1bGFybHkgdXNlZnVsIHRvIGhpZ2hsaWdodCBwYXJ0aWN1bGFyIHBhcnRzIG9mXG4gKiB0aGUgdGV4dCB3aXRob3V0IGludGVyZmVyaW5nIHdpdGggdGhlIEVkaXRvclN0YXRlLCB0aGF0IHdpbGwgb2Z0ZW4gcmVwbGljYXRlXG4gKiB0aGUgc3RhdGUgYWNyb3NzIGNvbGxhYiBhbmQgY2xpcGJvYXJkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWNjb3VudHMgZm9yIERPTSB1cGRhdGVzIHdoaWNoIGNhbiBtb2RpZnkgdGhlIHBhc3NlZCBSYW5nZS5cbiAqIEhlbmNlLCB0aGUgZnVuY3Rpb24gcmV0dXJuIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIG1sY1Bvc2l0aW9uTm9kZU9uUmFuZ2UoZWRpdG9yLCByYW5nZSwgb25SZXBvc2l0aW9uKSB7XG4gIGxldCByb290RE9NTm9kZSA9IG51bGw7XG4gIGxldCBwYXJlbnRET01Ob2RlID0gbnVsbDtcbiAgbGV0IG9ic2VydmVyID0gbnVsbDtcbiAgbGV0IGxhc3ROb2RlcyA9IFtdO1xuICBjb25zdCB3cmFwcGVyTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB3cmFwcGVyTm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgIGlmICghKHJvb3RET01Ob2RlICE9PSBudWxsKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBVbmV4cGVjdGVkIG51bGwgcm9vdERPTU5vZGVgKTtcbiAgICB9XG4gICAgaWYgKCEocGFyZW50RE9NTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgVW5leHBlY3RlZCBudWxsIHBhcmVudERPTU5vZGVgKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbGVmdDogcGFyZW50TGVmdCxcbiAgICAgIHRvcDogcGFyZW50VG9wXG4gICAgfSA9IHBhcmVudERPTU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgcmVjdHMgPSBjcmVhdGVSZWN0c0Zyb21ET01SYW5nZShlZGl0b3IsIHJhbmdlKTtcbiAgICBpZiAoIXdyYXBwZXJOb2RlLmlzQ29ubmVjdGVkKSB7XG4gICAgICBwcmVwZW5kRE9NTm9kZShwYXJlbnRET01Ob2RlLCB3cmFwcGVyTm9kZSk7XG4gICAgfVxuICAgIGxldCBoYXNSZXBvc2l0aW9uZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAvLyBUcnkgdG8gcmV1c2UgdGhlIHByZXZpb3VzbHkgY3JlYXRlZCBOb2RlIHdoZW4gcG9zc2libGUsIG5vIG5lZWQgdG9cbiAgICAgIC8vIHJlbW92ZS9jcmVhdGUgb24gdGhlIG1vc3QgY29tbW9uIGNhc2UgcmVwb3NpdGlvbiBjYXNlXG4gICAgICBjb25zdCByZWN0Tm9kZSA9IGxhc3ROb2Rlc1tpXSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnN0IHJlY3ROb2RlU3R5bGUgPSByZWN0Tm9kZS5zdHlsZTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIHJlY3ROb2RlU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVmdCA9IHB4KHJlY3QubGVmdCAtIHBhcmVudExlZnQpO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUubGVmdCAhPT0gbGVmdCkge1xuICAgICAgICByZWN0Tm9kZVN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9wID0gcHgocmVjdC50b3AgLSBwYXJlbnRUb3ApO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUudG9wICE9PSB0b3ApIHtcbiAgICAgICAgcmVjdE5vZGUuc3R5bGUudG9wID0gdG9wO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2lkdGggPSBweChyZWN0LndpZHRoKTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICByZWN0Tm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaGVpZ2h0ID0gcHgocmVjdC5oZWlnaHQpO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgcmVjdE5vZGUuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlY3ROb2RlLnBhcmVudE5vZGUgIT09IHdyYXBwZXJOb2RlKSB7XG4gICAgICAgIHdyYXBwZXJOb2RlLmFwcGVuZChyZWN0Tm9kZSk7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBsYXN0Tm9kZXNbaV0gPSByZWN0Tm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKGxhc3ROb2Rlcy5sZW5ndGggPiByZWN0cy5sZW5ndGgpIHtcbiAgICAgIGxhc3ROb2Rlcy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKGhhc1JlcG9zaXRpb25lZCkge1xuICAgICAgb25SZXBvc2l0aW9uKGxhc3ROb2Rlcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgcGFyZW50RE9NTm9kZSA9IG51bGw7XG4gICAgcm9vdERPTU5vZGUgPSBudWxsO1xuICAgIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICBvYnNlcnZlciA9IG51bGw7XG4gICAgd3JhcHBlck5vZGUucmVtb3ZlKCk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIGxhc3ROb2Rlcykge1xuICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICB9XG4gICAgbGFzdE5vZGVzID0gW107XG4gIH1cbiAgZnVuY3Rpb24gcmVzdGFydCgpIHtcbiAgICBjb25zdCBjdXJyZW50Um9vdERPTU5vZGUgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICBpZiAoY3VycmVudFJvb3RET01Ob2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3RvcCgpO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50UGFyZW50RE9NTm9kZSA9IGN1cnJlbnRSb290RE9NTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIGlmICghaXNIVE1MRWxlbWVudChjdXJyZW50UGFyZW50RE9NTm9kZSkpIHtcbiAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgfVxuICAgIHN0b3AoKTtcbiAgICByb290RE9NTm9kZSA9IGN1cnJlbnRSb290RE9NTm9kZTtcbiAgICBwYXJlbnRET01Ob2RlID0gY3VycmVudFBhcmVudERPTU5vZGU7XG4gICAgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgY29uc3QgbmV4dFJvb3RET01Ob2RlID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gICAgICBjb25zdCBuZXh0UGFyZW50RE9NTm9kZSA9IG5leHRSb290RE9NTm9kZSAmJiBuZXh0Um9vdERPTU5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgIGlmIChuZXh0Um9vdERPTU5vZGUgIT09IHJvb3RET01Ob2RlIHx8IG5leHRQYXJlbnRET01Ob2RlICE9PSBwYXJlbnRET01Ob2RlKSB7XG4gICAgICAgIHJldHVybiByZXN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICBpZiAoIXdyYXBwZXJOb2RlLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgICAgICAvLyBUT0RPIHRocm90dGxlXG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGN1cnJlbnRQYXJlbnRET01Ob2RlLCBtdXRhdGlvbk9ic2VydmVyQ29uZmlnKTtcbiAgICBwb3NpdGlvbigpO1xuICB9XG4gIGNvbnN0IHJlbW92ZVJvb3RMaXN0ZW5lciA9IGVkaXRvci5yZWdpc3RlclJvb3RMaXN0ZW5lcihyZXN0YXJ0KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZW1vdmVSb290TGlzdGVuZXIoKTtcbiAgICBzdG9wKCk7XG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcmFuZ2VUYXJnZXRGcm9tUG9pbnQocG9pbnQsIG5vZGUsIGRvbSkge1xuICBpZiAocG9pbnQudHlwZSA9PT0gJ3RleHQnIHx8ICEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IHRleHRET00gPSBnZXRET01UZXh0Tm9kZShkb20pIHx8IGRvbTtcbiAgICByZXR1cm4gW3RleHRET00sIHBvaW50Lm9mZnNldF07XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2xvdCA9IG5vZGUuZ2V0RE9NU2xvdChkb20pO1xuICAgIHJldHVybiBbc2xvdC5lbGVtZW50LCBzbG90LmdldEZpcnN0Q2hpbGRPZmZzZXQoKSArIHBvaW50Lm9mZnNldF07XG4gIH1cbn1cbmZ1bmN0aW9uIHJhbmdlRnJvbVBvaW50cyhlZGl0b3IsIGFuY2hvciwgYW5jaG9yTm9kZSwgYW5jaG9yRE9NLCBmb2N1cywgZm9jdXNOb2RlLCBmb2N1c0RPTSkge1xuICBjb25zdCBlZGl0b3JEb2N1bWVudCA9IGVkaXRvci5fd2luZG93ID8gZWRpdG9yLl93aW5kb3cuZG9jdW1lbnQgOiBkb2N1bWVudDtcbiAgY29uc3QgcmFuZ2UgPSBlZGl0b3JEb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBpZiAoZm9jdXNOb2RlLmlzQmVmb3JlKGFuY2hvck5vZGUpKSB7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoLi4ucmFuZ2VUYXJnZXRGcm9tUG9pbnQoZm9jdXMsIGZvY3VzTm9kZSwgZm9jdXNET00pKTtcbiAgICByYW5nZS5zZXRFbmQoLi4ucmFuZ2VUYXJnZXRGcm9tUG9pbnQoYW5jaG9yLCBhbmNob3JOb2RlLCBhbmNob3JET00pKTtcbiAgfSBlbHNlIHtcbiAgICByYW5nZS5zZXRTdGFydCguLi5yYW5nZVRhcmdldEZyb21Qb2ludChhbmNob3IsIGFuY2hvck5vZGUsIGFuY2hvckRPTSkpO1xuICAgIHJhbmdlLnNldEVuZCguLi5yYW5nZVRhcmdldEZyb21Qb2ludChmb2N1cywgZm9jdXNOb2RlLCBmb2N1c0RPTSkpO1xuICB9XG4gIHJldHVybiByYW5nZTtcbn1cbi8qKlxuICogUGxhY2Ugb25lIG9yIG11bHRpcGxlIG5ld2x5IGNyZWF0ZWQgTm9kZXMgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBNdWx0aXBsZVxuICogbm9kZXMgd2lsbCBvbmx5IGJlIGNyZWF0ZWQgd2hlbiB0aGUgc2VsZWN0aW9uIHNwYW5zIG11bHRpcGxlIGxpbmVzIChha2FcbiAqIGNsaWVudCByZWN0cykuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gY29tZSB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBzaG93IHRoZSBzZWxlY3Rpb24gYnV0IHRoZVxuICogZWRpdG9yIGhhcyBiZWVuIGZvY3VzZWQgYXdheS5cbiAqL1xuZnVuY3Rpb24gbWFya1NlbGVjdGlvbihlZGl0b3IsIG9uUmVwb3NpdGlvbikge1xuICBsZXQgcHJldmlvdXNBbmNob3JOb2RlID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzQW5jaG9yTm9kZURPTSA9IG51bGw7XG4gIGxldCBwcmV2aW91c0FuY2hvck9mZnNldCA9IG51bGw7XG4gIGxldCBwcmV2aW91c0ZvY3VzTm9kZSA9IG51bGw7XG4gIGxldCBwcmV2aW91c0ZvY3VzTm9kZURPTSA9IG51bGw7XG4gIGxldCBwcmV2aW91c0ZvY3VzT2Zmc2V0ID0gbnVsbDtcbiAgbGV0IHJlbW92ZVJhbmdlTGlzdGVuZXIgPSAoKSA9PiB7fTtcbiAgZnVuY3Rpb24gY29tcHV0ZShlZGl0b3JTdGF0ZSkge1xuICAgIGVkaXRvclN0YXRlLnJlYWQoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgcHJldmlvdXNBbmNob3JOb2RlID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXNBbmNob3JPZmZzZXQgPSBudWxsO1xuICAgICAgICBwcmV2aW91c0ZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzRm9jdXNPZmZzZXQgPSBudWxsO1xuICAgICAgICByZW1vdmVSYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIgPSAoKSA9PiB7fTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZvY3VzXG4gICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck5vZGVLZXkgPSBjdXJyZW50QW5jaG9yTm9kZS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRGb2N1c05vZGVLZXkgPSBjdXJyZW50Rm9jdXNOb2RlLmdldEtleSgpO1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck5vZGVET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGN1cnJlbnRBbmNob3JOb2RlS2V5KTtcbiAgICAgIGNvbnN0IGN1cnJlbnRGb2N1c05vZGVET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGN1cnJlbnRGb2N1c05vZGVLZXkpO1xuICAgICAgY29uc3QgZGlmZmVyZW50QW5jaG9yRE9NID0gcHJldmlvdXNBbmNob3JOb2RlID09PSBudWxsIHx8IGN1cnJlbnRBbmNob3JOb2RlRE9NICE9PSBwcmV2aW91c0FuY2hvck5vZGVET00gfHwgY3VycmVudEFuY2hvck9mZnNldCAhPT0gcHJldmlvdXNBbmNob3JPZmZzZXQgfHwgY3VycmVudEFuY2hvck5vZGVLZXkgIT09IHByZXZpb3VzQW5jaG9yTm9kZS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IGRpZmZlcmVudEZvY3VzRE9NID0gcHJldmlvdXNGb2N1c05vZGUgPT09IG51bGwgfHwgY3VycmVudEZvY3VzTm9kZURPTSAhPT0gcHJldmlvdXNGb2N1c05vZGVET00gfHwgY3VycmVudEZvY3VzT2Zmc2V0ICE9PSBwcmV2aW91c0ZvY3VzT2Zmc2V0IHx8IGN1cnJlbnRGb2N1c05vZGVLZXkgIT09IHByZXZpb3VzRm9jdXNOb2RlLmdldEtleSgpO1xuICAgICAgaWYgKChkaWZmZXJlbnRBbmNob3JET00gfHwgZGlmZmVyZW50Rm9jdXNET00pICYmIGN1cnJlbnRBbmNob3JOb2RlRE9NICE9PSBudWxsICYmIGN1cnJlbnRGb2N1c05vZGVET00gIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSByYW5nZUZyb21Qb2ludHMoZWRpdG9yLCBhbmNob3IsIGN1cnJlbnRBbmNob3JOb2RlLCBjdXJyZW50QW5jaG9yTm9kZURPTSwgZm9jdXMsIGN1cnJlbnRGb2N1c05vZGUsIGN1cnJlbnRGb2N1c05vZGVET00pO1xuICAgICAgICByZW1vdmVSYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIgPSBtbGNQb3NpdGlvbk5vZGVPblJhbmdlKGVkaXRvciwgcmFuZ2UsIGRvbU5vZGVzID0+IHtcbiAgICAgICAgICBpZiAob25SZXBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZG9tTm9kZSBvZiBkb21Ob2Rlcykge1xuICAgICAgICAgICAgICBjb25zdCBkb21Ob2RlU3R5bGUgPSBkb21Ob2RlLnN0eWxlO1xuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLmJhY2tncm91bmQgIT09ICdIaWdobGlnaHQnKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLmJhY2tncm91bmQgPSAnSGlnaGxpZ2h0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLmNvbG9yICE9PSAnSGlnaGxpZ2h0VGV4dCcpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUuY29sb3IgPSAnSGlnaGxpZ2h0VGV4dCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5tYXJnaW5Ub3AgIT09IHB4KC0xLjUpKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLm1hcmdpblRvcCA9IHB4KC0xLjUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucGFkZGluZ1RvcCAhPT0gcHgoNCkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUucGFkZGluZ1RvcCA9IHB4KDQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucGFkZGluZ0JvdHRvbSAhPT0gcHgoMCkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUucGFkZGluZ0JvdHRvbSA9IHB4KDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uUmVwb3NpdGlvbihkb21Ob2Rlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzQW5jaG9yTm9kZSA9IGN1cnJlbnRBbmNob3JOb2RlO1xuICAgICAgcHJldmlvdXNBbmNob3JOb2RlRE9NID0gY3VycmVudEFuY2hvck5vZGVET007XG4gICAgICBwcmV2aW91c0FuY2hvck9mZnNldCA9IGN1cnJlbnRBbmNob3JPZmZzZXQ7XG4gICAgICBwcmV2aW91c0ZvY3VzTm9kZSA9IGN1cnJlbnRGb2N1c05vZGU7XG4gICAgICBwcmV2aW91c0ZvY3VzTm9kZURPTSA9IGN1cnJlbnRGb2N1c05vZGVET007XG4gICAgICBwcmV2aW91c0ZvY3VzT2Zmc2V0ID0gY3VycmVudEZvY3VzT2Zmc2V0O1xuICAgIH0pO1xuICB9XG4gIGNvbXB1dGUoZWRpdG9yLmdldEVkaXRvclN0YXRlKCkpO1xuICByZXR1cm4gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoe1xuICAgIGVkaXRvclN0YXRlXG4gIH0pID0+IGNvbXB1dGUoZWRpdG9yU3RhdGUpKSwgKCkgPT4ge1xuICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0aW9uQWx3YXlzT25EaXNwbGF5KGVkaXRvcikge1xuICBsZXQgcmVtb3ZlU2VsZWN0aW9uTWFyayA9IG51bGw7XG4gIGNvbnN0IG9uU2VsZWN0aW9uQ2hhbmdlID0gKCkgPT4ge1xuICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IGRvbUFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24gJiYgZG9tU2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gICAgY29uc3QgZWRpdG9yUm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICBjb25zdCBpc1NlbGVjdGlvbkluc2lkZUVkaXRvciA9IGRvbUFuY2hvck5vZGUgIT09IG51bGwgJiYgZWRpdG9yUm9vdEVsZW1lbnQgIT09IG51bGwgJiYgZWRpdG9yUm9vdEVsZW1lbnQuY29udGFpbnMoZG9tQW5jaG9yTm9kZSk7XG4gICAgaWYgKGlzU2VsZWN0aW9uSW5zaWRlRWRpdG9yKSB7XG4gICAgICBpZiAocmVtb3ZlU2VsZWN0aW9uTWFyayAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmVTZWxlY3Rpb25NYXJrKCk7XG4gICAgICAgIHJlbW92ZVNlbGVjdGlvbk1hcmsgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVtb3ZlU2VsZWN0aW9uTWFyayA9PT0gbnVsbCkge1xuICAgICAgICByZW1vdmVTZWxlY3Rpb25NYXJrID0gbWFya1NlbGVjdGlvbihlZGl0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgb25TZWxlY3Rpb25DaGFuZ2UpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChyZW1vdmVTZWxlY3Rpb25NYXJrICE9PSBudWxsKSB7XG4gICAgICByZW1vdmVTZWxlY3Rpb25NYXJrKCk7XG4gICAgfVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIG9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgfTtcbn1cblxuLy8gSG90Zml4IHRvIGV4cG9ydCB0aGVzZSB3aXRoIGlubGluZWQgdHlwZXMgIzU5MThcbmNvbnN0IENBTl9VU0VfQkVGT1JFX0lOUFVUID0gQ0FOX1VTRV9CRUZPUkVfSU5QVVQkMTtcbmNvbnN0IENBTl9VU0VfRE9NID0gQ0FOX1VTRV9ET00kMTtcbmNvbnN0IElTX0FORFJPSUQgPSBJU19BTkRST0lEJDE7XG5jb25zdCBJU19BTkRST0lEX0NIUk9NRSA9IElTX0FORFJPSURfQ0hST01FJDE7XG5jb25zdCBJU19BUFBMRSA9IElTX0FQUExFJDE7XG5jb25zdCBJU19BUFBMRV9XRUJLSVQgPSBJU19BUFBMRV9XRUJLSVQkMTtcbmNvbnN0IElTX0NIUk9NRSA9IElTX0NIUk9NRSQxO1xuY29uc3QgSVNfRklSRUZPWCA9IElTX0ZJUkVGT1gkMTtcbmNvbnN0IElTX0lPUyA9IElTX0lPUyQxO1xuY29uc3QgSVNfU0FGQVJJID0gSVNfU0FGQVJJJDE7XG5cbi8qKlxuICogVGFrZXMgYW4gSFRNTCBlbGVtZW50IGFuZCBhZGRzIHRoZSBjbGFzc05hbWVzIHBhc3NlZCB3aXRoaW4gYW4gYXJyYXksXG4gKiBpZ25vcmluZyBhbnkgbm9uLXN0cmluZyB0eXBlcy4gQSBzcGFjZSBjYW4gYmUgdXNlZCB0byBhZGQgbXVsdGlwbGUgY2xhc3Nlc1xuICogZWcuIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgWydlbGVtZW50LWlubmVyIGFjdGl2ZScsIHRydWUsIG51bGxdKVxuICogd2lsbCBhZGQgYm90aCAnZWxlbWVudC1pbm5lcicgYW5kICdhY3RpdmUnIGFzIGNsYXNzZXMgdG8gdGhhdCBlbGVtZW50LlxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgY2xhc3NlcyBhcmUgYWRkZWRcbiAqIEBwYXJhbSBjbGFzc05hbWVzIC0gQW4gYXJyYXkgZGVmaW5pbmcgdGhlIGNsYXNzIG5hbWVzIHRvIGFkZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgY2xhc3Nlc1RvQWRkID0gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKTtcbiAgaWYgKGNsYXNzZXNUb0FkZC5sZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXNUb0FkZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBhbiBIVE1MIGVsZW1lbnQgYW5kIHJlbW92ZXMgdGhlIGNsYXNzTmFtZXMgcGFzc2VkIHdpdGhpbiBhbiBhcnJheSxcbiAqIGlnbm9yaW5nIGFueSBub24tc3RyaW5nIHR5cGVzLiBBIHNwYWNlIGNhbiBiZSB1c2VkIHRvIHJlbW92ZSBtdWx0aXBsZSBjbGFzc2VzXG4gKiBlZy4gcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGVsZW1lbnQsIFsnYWN0aXZlIHNtYWxsJywgdHJ1ZSwgbnVsbF0pXG4gKiB3aWxsIHJlbW92ZSBib3RoIHRoZSAnYWN0aXZlJyBhbmQgJ3NtYWxsJyBjbGFzc2VzIGZyb20gdGhhdCBlbGVtZW50LlxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgY2xhc3NlcyBhcmUgcmVtb3ZlZFxuICogQHBhcmFtIGNsYXNzTmFtZXMgLSBBbiBhcnJheSBkZWZpbmluZyB0aGUgY2xhc3MgbmFtZXMgdG8gcmVtb3ZlIGZyb20gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGVsZW1lbnQsIC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgY2xhc3Nlc1RvUmVtb3ZlID0gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKTtcbiAgaWYgKGNsYXNzZXNUb1JlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzZXNUb1JlbW92ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZpbGUgdHlwZSBtYXRjaGVzIHRoZSB0eXBlcyBwYXNzZWQgd2l0aGluIHRoZSBhY2NlcHRhYmxlTWltZVR5cGVzIGFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBUaGUgdHlwZXMgcGFzc2VkIG11c3QgYmUgc3RyaW5ncyBhbmQgYXJlIENBU0UtU0VOU0lUSVZFLlxuICogZWcuIGlmIGZpbGUgaXMgb2YgdHlwZSAndGV4dCcgYW5kIGFjY2VwdGFibGVNaW1lVHlwZXMgPSBbJ1RFWFQnLCAnSU1BR0UnXSB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gZmFsc2UuXG4gKiBAcGFyYW0gZmlsZSAtIFRoZSBmaWxlIHlvdSB3YW50IHRvIHR5cGUgY2hlY2suXG4gKiBAcGFyYW0gYWNjZXB0YWJsZU1pbWVUeXBlcyAtIEFuIGFycmF5IG9mIHN0cmluZ3Mgb2YgdHlwZXMgd2hpY2ggdGhlIGZpbGUgaXMgY2hlY2tlZCBhZ2FpbnN0LlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZmlsZSBpcyBhbiBhY2NlcHRhYmxlIG1pbWUgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc01pbWVUeXBlKGZpbGUsIGFjY2VwdGFibGVNaW1lVHlwZXMpIHtcbiAgZm9yIChjb25zdCBhY2NlcHRhYmxlVHlwZSBvZiBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gICAgaWYgKGZpbGUudHlwZS5zdGFydHNXaXRoKGFjY2VwdGFibGVUeXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBMZXhpY2FsIEZpbGUgUmVhZGVyIHdpdGg6XG4gKiAgMS4gTUlNRSB0eXBlIHN1cHBvcnRcbiAqICAyLiBiYXRjaGVkIHJlc3VsdHMgKEhpc3RvcnlQbHVnaW4gY29tcGF0aWJpbGl0eSlcbiAqICAzLiBPcmRlciBhd2FyZSAocmVzcGVjdHMgdGhlIG9yZGVyIHdoZW4gbXVsdGlwbGUgRmlsZXMgYXJlIHBhc3NlZClcbiAqXG4gKiBjb25zdCBmaWxlc1Jlc3VsdCA9IGF3YWl0IG1lZGlhRmlsZVJlYWRlcihmaWxlcywgWydpbWFnZS8nXSk7XG4gKiBmaWxlc1Jlc3VsdC5mb3JFYWNoKGZpbGUgPT4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZCgnSU5TRVJUX0lNQUdFJywgXFxcXHtcbiAqICAgc3JjOiBmaWxlLnJlc3VsdCxcbiAqIFxcXFx9KSk7XG4gKi9cbmZ1bmN0aW9uIG1lZGlhRmlsZVJlYWRlcihmaWxlcywgYWNjZXB0YWJsZU1pbWVUeXBlcykge1xuICBjb25zdCBmaWxlc0l0ZXJhdG9yID0gZmlsZXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHByb2Nlc3NlZCA9IFtdO1xuICAgIGNvbnN0IGhhbmRsZU5leHRGaWxlID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkb25lLFxuICAgICAgICB2YWx1ZTogZmlsZVxuICAgICAgfSA9IGZpbGVzSXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUocHJvY2Vzc2VkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICBmaWxlUmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbGVSZWFkZXIucmVzdWx0O1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwcm9jZXNzZWQucHVzaCh7XG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlTmV4dEZpbGUoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzTWltZVR5cGUoZmlsZSwgYWNjZXB0YWJsZU1pbWVUeXBlcykpIHtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlTmV4dEZpbGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGhhbmRsZU5leHRGaWxlKCk7XG4gIH0pO1xufVxuLyoqXG4gKiBcIkRlcHRoLUZpcnN0IFNlYXJjaFwiIHN0YXJ0cyBhdCB0aGUgcm9vdC90b3Agbm9kZSBvZiBhIHRyZWUgYW5kIGdvZXMgYXMgZmFyIGFzIGl0IGNhbiBkb3duIGEgYnJhbmNoIGVuZFxuICogYmVmb3JlIGJhY2t0cmFja2luZyBhbmQgZmluZGluZyBhIG5ldyBwYXRoLiBDb25zaWRlciBzb2x2aW5nIGEgbWF6ZSBieSBodWdnaW5nIGVpdGhlciB3YWxsLCBtb3ZpbmcgZG93biBhXG4gKiBicmFuY2ggdW50aWwgeW91IGhpdCBhIGRlYWQtZW5kIChsZWFmKSBhbmQgYmFja3RyYWNraW5nIHRvIGZpbmQgdGhlIG5lYXJlc3QgYnJhbmNoaW5nIHBhdGggYW5kIHJlcGVhdC5cbiAqIEl0IHdpbGwgdGhlbiByZXR1cm4gYWxsIHRoZSBub2RlcyBmb3VuZCBpbiB0aGUgc2VhcmNoIGluIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIG5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBzdGFydCBhdCB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIGVuZE5vZGUgLSBUaGUgbm9kZSB0byBlbmQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBmaW5kIGFsbCBkZXNjZW5kYW50cyBvZiB0aGUgc3RhcnRpbmdOb2RlLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygb2JqZWN0cyBvZiBhbGwgdGhlIG5vZGVzIGZvdW5kIGJ5IHRoZSBzZWFyY2gsIGluY2x1ZGluZyB0aGVpciBkZXB0aCBpbnRvIHRoZSB0cmVlLlxuICogXFxcXHtkZXB0aDogbnVtYmVyLCBub2RlOiBMZXhpY2FsTm9kZVxcXFx9IEl0IHdpbGwgYWx3YXlzIHJldHVybiBhdCBsZWFzdCAxIG5vZGUgKHRoZSBzdGFydCBub2RlKS5cbiAqL1xuZnVuY3Rpb24gJGRmcyhzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oJGRmc0l0ZXJhdG9yKHN0YXJ0Tm9kZSwgZW5kTm9kZSkpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYWRqYWNlbnQgY2FyZXQgaW4gdGhlIHNhbWUgZGlyZWN0aW9uXG4gKlxuICogQHBhcmFtIGNhcmV0IEEgY2FyZXQgb3IgbnVsbFxuICogQHJldHVybnMgYGNhcmV0LmdldEFkamFjZW50Q2FyZXQoKWAgb3IgYG51bGxgXG4gKi9cbmZ1bmN0aW9uICRnZXRBZGphY2VudENhcmV0KGNhcmV0KSB7XG4gIHJldHVybiBjYXJldCA/IGNhcmV0LmdldEFkamFjZW50Q2FyZXQoKSA6IG51bGw7XG59XG5cbi8qKlxuICogJGRmcyBpdGVyYXRvciAocmlnaHQgdG8gbGVmdCkuIFRyZWUgdHJhdmVyc2FsIGlzIGRvbmUgb24gdGhlIGZseSBhcyBuZXcgdmFsdWVzIGFyZSByZXF1ZXN0ZWQgd2l0aCBPKDEpIG1lbW9yeS5cbiAqIEBwYXJhbSBzdGFydE5vZGUgLSBUaGUgbm9kZSB0byBzdGFydCB0aGUgc2VhcmNoLCBpZiBvbWl0dGVkLCBpdCB3aWxsIHN0YXJ0IGF0IHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0gZW5kTm9kZSAtIFRoZSBub2RlIHRvIGVuZCB0aGUgc2VhcmNoLCBpZiBvbWl0dGVkLCBpdCB3aWxsIGZpbmQgYWxsIGRlc2NlbmRhbnRzIG9mIHRoZSBzdGFydGluZ05vZGUuXG4gKiBAcmV0dXJucyBBbiBpdGVyYXRvciwgZWFjaCB5aWVsZGVkIHZhbHVlIGlzIGEgREZTTm9kZS4gSXQgd2lsbCBhbHdheXMgcmV0dXJuIGF0IGxlYXN0IDEgbm9kZSAodGhlIHN0YXJ0IG5vZGUpLlxuICovXG5mdW5jdGlvbiAkcmV2ZXJzZURmcyhzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oJHJldmVyc2VEZnNJdGVyYXRvcihzdGFydE5vZGUsIGVuZE5vZGUpKTtcbn1cblxuLyoqXG4gKiAkZGZzIGl0ZXJhdG9yIChsZWZ0IHRvIHJpZ2h0KS4gVHJlZSB0cmF2ZXJzYWwgaXMgZG9uZSBvbiB0aGUgZmx5IGFzIG5ldyB2YWx1ZXMgYXJlIHJlcXVlc3RlZCB3aXRoIE8oMSkgbWVtb3J5LlxuICogQHBhcmFtIHN0YXJ0Tm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgc3RhcnQgYXQgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSBlbmROb2RlIC0gVGhlIG5vZGUgdG8gZW5kIHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgZmluZCBhbGwgZGVzY2VuZGFudHMgb2YgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yLCBlYWNoIHlpZWxkZWQgdmFsdWUgaXMgYSBERlNOb2RlLiBJdCB3aWxsIGFsd2F5cyByZXR1cm4gYXQgbGVhc3QgMSBub2RlICh0aGUgc3RhcnQgbm9kZSkuXG4gKi9cbmZ1bmN0aW9uICRkZnNJdGVyYXRvcihzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgcmV0dXJuICRkZnNDYXJldEl0ZXJhdG9yKCduZXh0Jywgc3RhcnROb2RlLCBlbmROb2RlKTtcbn1cbmZ1bmN0aW9uICRnZXRFbmRDYXJldChzdGFydE5vZGUsIGRpcmVjdGlvbikge1xuICBjb25zdCBydmFsID0gJGdldEFkamFjZW50U2libGluZ09yUGFyZW50U2libGluZ0NhcmV0KCRnZXRTaWJsaW5nQ2FyZXQoc3RhcnROb2RlLCBkaXJlY3Rpb24pKTtcbiAgcmV0dXJuIHJ2YWwgJiYgcnZhbFswXTtcbn1cbmZ1bmN0aW9uICRkZnNDYXJldEl0ZXJhdG9yKGRpcmVjdGlvbiwgc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICBjb25zdCBzdGFydCA9IHN0YXJ0Tm9kZSB8fCByb290O1xuICBjb25zdCBzdGFydENhcmV0ID0gJGlzRWxlbWVudE5vZGUoc3RhcnQpID8gJGdldENoaWxkQ2FyZXQoc3RhcnQsIGRpcmVjdGlvbikgOiAkZ2V0U2libGluZ0NhcmV0KHN0YXJ0LCBkaXJlY3Rpb24pO1xuICBjb25zdCBzdGFydERlcHRoID0gJGdldERlcHRoKHN0YXJ0KTtcbiAgY29uc3QgZW5kQ2FyZXQgPSBlbmROb2RlID8gJGdldEFkamFjZW50Q2hpbGRDYXJldCgkZ2V0Q2hpbGRDYXJldE9yU2VsZigkZ2V0U2libGluZ0NhcmV0KGVuZE5vZGUsIGRpcmVjdGlvbikpKSA6ICRnZXRFbmRDYXJldChzdGFydCwgZGlyZWN0aW9uKTtcbiAgbGV0IGRlcHRoID0gc3RhcnREZXB0aDtcbiAgcmV0dXJuIG1ha2VTdGVwd2lzZUl0ZXJhdG9yKHtcbiAgICBoYXNOZXh0OiBzdGF0ZSA9PiBzdGF0ZSAhPT0gbnVsbCxcbiAgICBpbml0aWFsOiBzdGFydENhcmV0LFxuICAgIG1hcDogc3RhdGUgPT4gKHtcbiAgICAgIGRlcHRoLFxuICAgICAgbm9kZTogc3RhdGUub3JpZ2luXG4gICAgfSksXG4gICAgc3RlcDogc3RhdGUgPT4ge1xuICAgICAgaWYgKHN0YXRlLmlzU2FtZU5vZGVDYXJldChlbmRDYXJldCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoJGlzQ2hpbGRDYXJldChzdGF0ZSkpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJ2YWwgPSAkZ2V0QWRqYWNlbnRTaWJsaW5nT3JQYXJlbnRTaWJsaW5nQ2FyZXQoc3RhdGUpO1xuICAgICAgaWYgKCFydmFsIHx8IHJ2YWxbMF0uaXNTYW1lTm9kZUNhcmV0KGVuZENhcmV0KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGRlcHRoICs9IHJ2YWxbMV07XG4gICAgICByZXR1cm4gcnZhbFswXTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIE5vZGUgc2libGluZyB3aGVuIHRoaXMgZXhpc3RzLCBvdGhlcndpc2UgdGhlIGNsb3Nlc3QgcGFyZW50IHNpYmxpbmcuIEZvciBleGFtcGxlXG4gKiBSIC0+IFAgLT4gVDEsIFQyXG4gKiAgIC0+IFAyXG4gKiByZXR1cm5zIFQyIGZvciBub2RlIFQxLCBQMiBmb3Igbm9kZSBUMiwgYW5kIG51bGwgZm9yIG5vZGUgUDIuXG4gKiBAcGFyYW0gbm9kZSBMZXhpY2FsTm9kZS5cbiAqIEByZXR1cm5zIEFuIGFycmF5ICh0dXBsZSkgY29udGFpbmluZyB0aGUgZm91bmQgTGV4aWNhbCBub2RlIGFuZCB0aGUgZGVwdGggZGlmZmVyZW5jZSwgb3IgbnVsbCwgaWYgdGhpcyBub2RlIGRvZXNuJ3QgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uICRnZXROZXh0U2libGluZ09yUGFyZW50U2libGluZyhub2RlKSB7XG4gIGNvbnN0IHJ2YWwgPSAkZ2V0QWRqYWNlbnRTaWJsaW5nT3JQYXJlbnRTaWJsaW5nQ2FyZXQoJGdldFNpYmxpbmdDYXJldChub2RlLCAnbmV4dCcpKTtcbiAgcmV0dXJuIHJ2YWwgJiYgW3J2YWxbMF0ub3JpZ2luLCBydmFsWzFdXTtcbn1cbmZ1bmN0aW9uICRnZXREZXB0aChub2RlKSB7XG4gIGxldCBkZXB0aCA9IC0xO1xuICBmb3IgKGxldCBpbm5lck5vZGUgPSBub2RlOyBpbm5lck5vZGUgIT09IG51bGw7IGlubmVyTm9kZSA9IGlubmVyTm9kZS5nZXRQYXJlbnQoKSkge1xuICAgIGRlcHRoKys7XG4gIH1cbiAgcmV0dXJuIGRlcHRoO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgcmlnaHQtdG8tbGVmdCBwcmVvcmRlciB0cmVlIHRyYXZlcnNhbC5cbiAqIEZyb20gdGhlIHN0YXJ0aW5nIG5vZGUgaXQgZ29lcyB0byB0aGUgcmlnaHRtb3N0IGNoaWxkLCB0aGFuIGJhY2t0cmFja3MgdG8gcGFyZW50IGFuZCBmaW5kcyBuZXcgcmlnaHRtb3N0IHBhdGguXG4gKiBJdCB3aWxsIHJldHVybiB0aGUgbmV4dCBub2RlIGluIHRyYXZlcnNhbCBzZXF1ZW5jZSBhZnRlciB0aGUgc3RhcnRpbmdOb2RlLlxuICogVGhlIHRyYXZlcnNhbCBpcyBzaW1pbGFyIHRvICRkZnMgZnVuY3Rpb25zIGFib3ZlLCBidXQgdGhlIG5vZGVzIGFyZSB2aXNpdGVkIHJpZ2h0LXRvLWxlZnQsIG5vdCBsZWZ0LXRvLXJpZ2h0LlxuICogQHBhcmFtIHN0YXJ0aW5nTm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2guXG4gKiBAcmV0dXJucyBUaGUgbmV4dCBub2RlIGluIHByZS1vcmRlciByaWdodCB0byBsZWZ0IHRyYXZlcnNhbCBzZXF1ZW5jZSBvciBgbnVsbGAsIGlmIHRoZSBub2RlIGRvZXMgbm90IGV4aXN0XG4gKi9cbmZ1bmN0aW9uICRnZXROZXh0UmlnaHRQcmVvcmRlck5vZGUoc3RhcnRpbmdOb2RlKSB7XG4gIGNvbnN0IHN0YXJ0Q2FyZXQgPSAkZ2V0Q2hpbGRDYXJldE9yU2VsZigkZ2V0U2libGluZ0NhcmV0KHN0YXJ0aW5nTm9kZSwgJ3ByZXZpb3VzJykpO1xuICBjb25zdCBuZXh0ID0gJGdldEFkamFjZW50U2libGluZ09yUGFyZW50U2libGluZ0NhcmV0KHN0YXJ0Q2FyZXQsICdyb290Jyk7XG4gIHJldHVybiBuZXh0ICYmIG5leHRbMF0ub3JpZ2luO1xufVxuXG4vKipcbiAqICRkZnMgaXRlcmF0b3IgKHJpZ2h0IHRvIGxlZnQpLiBUcmVlIHRyYXZlcnNhbCBpcyBkb25lIG9uIHRoZSBmbHkgYXMgbmV3IHZhbHVlcyBhcmUgcmVxdWVzdGVkIHdpdGggTygxKSBtZW1vcnkuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIG5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBzdGFydCBhdCB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIGVuZE5vZGUgLSBUaGUgbm9kZSB0byBlbmQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBmaW5kIGFsbCBkZXNjZW5kYW50cyBvZiB0aGUgc3RhcnRpbmdOb2RlLlxuICogQHJldHVybnMgQW4gaXRlcmF0b3IsIGVhY2ggeWllbGRlZCB2YWx1ZSBpcyBhIERGU05vZGUuIEl0IHdpbGwgYWx3YXlzIHJldHVybiBhdCBsZWFzdCAxIG5vZGUgKHRoZSBzdGFydCBub2RlKS5cbiAqL1xuZnVuY3Rpb24gJHJldmVyc2VEZnNJdGVyYXRvcihzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgcmV0dXJuICRkZnNDYXJldEl0ZXJhdG9yKCdwcmV2aW91cycsIHN0YXJ0Tm9kZSwgZW5kTm9kZSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBub2RlIGFuZCB0cmF2ZXJzZXMgdXAgaXRzIGFuY2VzdG9ycyAodG93YXJkIHRoZSByb290IG5vZGUpXG4gKiBpbiBvcmRlciB0byBmaW5kIGEgc3BlY2lmaWMgdHlwZSBvZiBub2RlLlxuICogQHBhcmFtIG5vZGUgLSB0aGUgbm9kZSB0byBiZWdpbiBzZWFyY2hpbmcuXG4gKiBAcGFyYW0ga2xhc3MgLSBhbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBvZiBub2RlIHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgdGhlIG5vZGUgb2YgdHlwZSBrbGFzcyB0aGF0IHdhcyBwYXNzZWQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3ROb2RlT2ZUeXBlKG5vZGUsIGtsYXNzKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2Yga2xhc3MpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IG5vZGUgb2YgdGhlIG5lYXJlc3QgYW5jZXN0b3IsIG90aGVyd2lzZSB0aHJvd3MgYW4gZXJyb3IuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIHN0YXJ0aW5nIG5vZGUgb2YgdGhlIHNlYXJjaFxuICogQHJldHVybnMgVGhlIGFuY2VzdG9yIG5vZGUgZm91bmRcbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3coc3RhcnROb2RlKSB7XG4gIGNvbnN0IGJsb2NrTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnROb2RlLCBub2RlID0+ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuICBpZiAoISRpc0VsZW1lbnROb2RlKGJsb2NrTm9kZSkpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIG5vZGUgJHtzdGFydE5vZGUuX19rZXl9IHRvIGhhdmUgY2xvc2VzdCBibG9jayBlbGVtZW50IG5vZGUuYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBibG9ja05vZGU7XG59XG4vKipcbiAqIFN0YXJ0cyB3aXRoIGEgbm9kZSBhbmQgbW92ZXMgdXAgdGhlIHRyZWUgKHRvd2FyZCB0aGUgcm9vdCBub2RlKSB0byBmaW5kIGEgbWF0Y2hpbmcgbm9kZSBiYXNlZCBvblxuICogdGhlIHNlYXJjaCBwYXJhbWV0ZXJzIG9mIHRoZSBmaW5kRm4uIChDb25zaWRlciBKYXZhU2NyaXB0cycgLmZpbmQoKSBmdW5jdGlvbiB3aGVyZSBhIHRlc3RpbmcgZnVuY3Rpb24gbXVzdCBiZVxuICogcGFzc2VkIGFzIGFuIGFyZ3VtZW50LiBlZy4gaWYoIChub2RlKSA9PiBub2RlLl9fdHlwZSA9PT0gJ2RpdicpICkgcmV0dXJuIHRydWU7IG90aGVyd2lzZSByZXR1cm4gZmFsc2VcbiAqIEBwYXJhbSBzdGFydGluZ05vZGUgLSBUaGUgbm9kZSB3aGVyZSB0aGUgc2VhcmNoIHN0YXJ0cy5cbiAqIEBwYXJhbSBmaW5kRm4gLSBBIHRlc3RpbmcgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgbm9kZSBzYXRpc2ZpZXMgdGhlIHRlc3RpbmcgcGFyYW1ldGVycy5cbiAqIEByZXR1cm5zIEEgcGFyZW50IG5vZGUgdGhhdCBtYXRjaGVzIHRoZSBmaW5kRm4gcGFyYW1ldGVycywgb3IgbnVsbCBpZiBvbmUgd2Fzbid0IGZvdW5kLlxuICovXG5jb25zdCAkZmluZE1hdGNoaW5nUGFyZW50ID0gKHN0YXJ0aW5nTm9kZSwgZmluZEZuKSA9PiB7XG4gIGxldCBjdXJyID0gc3RhcnRpbmdOb2RlO1xuICB3aGlsZSAoY3VyciAhPT0gJGdldFJvb3QoKSAmJiBjdXJyICE9IG51bGwpIHtcbiAgICBpZiAoZmluZEZuKGN1cnIpKSB7XG4gICAgICByZXR1cm4gY3VycjtcbiAgICB9XG4gICAgY3VyciA9IGN1cnIuZ2V0UGFyZW50KCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHJlc29sdmUgbmVzdGVkIGVsZW1lbnQgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZSBpbnRvIGEgc2luZ2xlIG5vZGUgb2YgdGhhdCB0eXBlLlxuICogSXQgaXMgZ2VuZXJhbGx5IHVzZWQgZm9yIG1hcmtzL2NvbW1lbnRpbmdcbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3JcbiAqIEBwYXJhbSB0YXJnZXROb2RlIC0gVGhlIHRhcmdldCBmb3IgdGhlIG5lc3RlZCBlbGVtZW50IHRvIGJlIGV4dHJhY3RlZCBmcm9tLlxuICogQHBhcmFtIGNsb25lTm9kZSAtIFNlZSB7QGxpbmsgJGNyZWF0ZU1hcmtOb2RlfVxuICogQHBhcmFtIGhhbmRsZU92ZXJsYXAgLSBIYW5kbGVzIGFueSBvdmVybGFwIGJldHdlZW4gdGhlIG5vZGUgdG8gZXh0cmFjdCBhbmQgdGhlIHRhcmdldE5vZGVcbiAqIEByZXR1cm5zIFRoZSBsZXhpY2FsIGVkaXRvclxuICovXG5mdW5jdGlvbiByZWdpc3Rlck5lc3RlZEVsZW1lbnRSZXNvbHZlcihlZGl0b3IsIHRhcmdldE5vZGUsIGNsb25lTm9kZSwgaGFuZGxlT3ZlcmxhcCkge1xuICBjb25zdCAkaXNUYXJnZXROb2RlID0gbm9kZSA9PiB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiB0YXJnZXROb2RlO1xuICB9O1xuICBjb25zdCAkZmluZE1hdGNoID0gbm9kZSA9PiB7XG4gICAgLy8gRmlyc3QgdmFsaWRhdGUgd2UgZG9uJ3QgaGF2ZSBhbnkgY2hpbGRyZW4gdGhhdCBhcmUgb2YgdGhlIHRhcmdldCxcbiAgICAvLyBhcyB3ZSBuZWVkIHRvIGhhbmRsZSB0aGVtIGZpcnN0LlxuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoJGlzVGFyZ2V0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBwYXJlbnROb2RlID0gbm9kZTtcbiAgICBsZXQgY2hpbGROb2RlID0gbm9kZTtcbiAgICB3aGlsZSAocGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2hpbGROb2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKCRpc1RhcmdldE5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGlsZDogY2hpbGROb2RlLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50Tm9kZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgY29uc3QgJGVsZW1lbnROb2RlVHJhbnNmb3JtID0gbm9kZSA9PiB7XG4gICAgY29uc3QgbWF0Y2ggPSAkZmluZE1hdGNoKG5vZGUpO1xuICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjaGlsZCxcbiAgICAgICAgcGFyZW50XG4gICAgICB9ID0gbWF0Y2g7XG5cbiAgICAgIC8vIFNpbXBsZSBwYXRoLCB3ZSBjYW4gbW92ZSBjaGlsZCBvdXQgYW5kIHNpYmxpbmdzIGludG8gYSBuZXcgcGFyZW50LlxuXG4gICAgICBpZiAoY2hpbGQuaXMobm9kZSkpIHtcbiAgICAgICAgaGFuZGxlT3ZlcmxhcChwYXJlbnQsIG5vZGUpO1xuICAgICAgICBjb25zdCBuZXh0U2libGluZ3MgPSBjaGlsZC5nZXROZXh0U2libGluZ3MoKTtcbiAgICAgICAgY29uc3QgbmV4dFNpYmxpbmdzTGVuZ3RoID0gbmV4dFNpYmxpbmdzLmxlbmd0aDtcbiAgICAgICAgcGFyZW50Lmluc2VydEFmdGVyKGNoaWxkKTtcbiAgICAgICAgaWYgKG5leHRTaWJsaW5nc0xlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGNvbnN0IG5ld1BhcmVudCA9IGNsb25lTm9kZShwYXJlbnQpO1xuICAgICAgICAgIGNoaWxkLmluc2VydEFmdGVyKG5ld1BhcmVudCk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U2libGluZ3NMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3UGFyZW50LmFwcGVuZChuZXh0U2libGluZ3NbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5jYW5CZUVtcHR5KCkgJiYgcGFyZW50LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybSh0YXJnZXROb2RlLCAkZWxlbWVudE5vZGVUcmFuc2Zvcm0pO1xufVxuXG4vKipcbiAqIENsb25lcyB0aGUgZWRpdG9yIGFuZCBtYXJrcyBpdCBhcyBkaXJ0eSB0byBiZSByZWNvbmNpbGVkLiBJZiB0aGVyZSB3YXMgYSBzZWxlY3Rpb24sXG4gKiBpdCB3b3VsZCBiZSBzZXQgYmFjayB0byBpdHMgcHJldmlvdXMgc3RhdGUsIG9yIG51bGwgb3RoZXJ3aXNlLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIGVkaXRvclN0YXRlIC0gVGhlIGVkaXRvcidzIHN0YXRlXG4gKi9cbmZ1bmN0aW9uICRyZXN0b3JlRWRpdG9yU3RhdGUoZWRpdG9yLCBlZGl0b3JTdGF0ZSkge1xuICBjb25zdCBGVUxMX1JFQ09OQ0lMRSA9IDI7XG4gIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGFjdGl2ZUVkaXRvclN0YXRlID0gZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGU7XG4gIGZvciAoY29uc3QgW2tleSwgbm9kZV0gb2YgZWRpdG9yU3RhdGUuX25vZGVNYXApIHtcbiAgICBub2RlTWFwLnNldChrZXksICRjbG9uZVdpdGhQcm9wZXJ0aWVzKG5vZGUpKTtcbiAgfVxuICBpZiAoYWN0aXZlRWRpdG9yU3RhdGUpIHtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZS5fbm9kZU1hcCA9IG5vZGVNYXA7XG4gIH1cbiAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBGVUxMX1JFQ09OQ0lMRTtcbiAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgJHNldFNlbGVjdGlvbihzZWxlY3Rpb24gPT09IG51bGwgPyBudWxsIDogc2VsZWN0aW9uLmNsb25lKCkpO1xufVxuXG4vKipcbiAqIElmIHRoZSBzZWxlY3RlZCBpbnNlcnRpb24gYXJlYSBpcyB0aGUgcm9vdC9zaGFkb3cgcm9vdCBub2RlIChzZWUge0BsaW5rIGxleGljYWwhJGlzUm9vdE9yU2hhZG93Um9vdH0pLFxuICogdGhlIG5vZGUgd2lsbCBiZSBhcHBlbmRlZCB0aGVyZSwgb3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGluc2VydGVkIGJlZm9yZSB0aGUgaW5zZXJ0aW9uIGFyZWEuXG4gKiBJZiB0aGVyZSBpcyBubyBzZWxlY3Rpb24gd2hlcmUgdGhlIG5vZGUgaXMgdG8gYmUgaW5zZXJ0ZWQsIGl0IHdpbGwgYmUgYXBwZW5kZWQgYWZ0ZXIgYW55IGN1cnJlbnQgbm9kZXNcbiAqIHdpdGhpbiB0aGUgdHJlZSwgYXMgYSBjaGlsZCBvZiB0aGUgcm9vdCBub2RlLiBBIHBhcmFncmFwaCB3aWxsIHRoZW4gYmUgYWRkZWQgYWZ0ZXIgdGhlIGluc2VydGVkIG5vZGUgYW5kIHNlbGVjdGVkLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBpbnNlcnRlZFxuICogQHJldHVybnMgVGhlIG5vZGUgYWZ0ZXIgaXRzIGluc2VydGlvblxuICovXG5mdW5jdGlvbiAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3Qobm9kZSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkgfHwgJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gIGxldCBpbml0aWFsQ2FyZXQ7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgaW5pdGlhbENhcmV0ID0gJGNhcmV0RnJvbVBvaW50KHNlbGVjdGlvbi5mb2N1cywgJ25leHQnKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc2VsZWN0aW9uICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgICBjb25zdCBsYXN0Tm9kZSA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlKSB7XG4gICAgICAgIGluaXRpYWxDYXJldCA9ICRnZXRTaWJsaW5nQ2FyZXQobGFzdE5vZGUsICduZXh0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIGluaXRpYWxDYXJldCA9IGluaXRpYWxDYXJldCB8fCAkZ2V0Q2hpbGRDYXJldCgkZ2V0Um9vdCgpLCAncHJldmlvdXMnKS5nZXRGbGlwcGVkKCkuaW5zZXJ0KCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICB9XG4gIGNvbnN0IGluc2VydENhcmV0ID0gJGluc2VydE5vZGVUb05lYXJlc3RSb290QXRDYXJldChub2RlLCBpbml0aWFsQ2FyZXQpO1xuICBjb25zdCBhZGphY2VudCA9ICRnZXRBZGphY2VudENoaWxkQ2FyZXQoaW5zZXJ0Q2FyZXQpO1xuICBjb25zdCBzZWxlY3Rpb25DYXJldCA9ICRpc0NoaWxkQ2FyZXQoYWRqYWNlbnQpID8gJG5vcm1hbGl6ZUNhcmV0KGFkamFjZW50KSA6IGluc2VydENhcmV0O1xuICAkc2V0U2VsZWN0aW9uRnJvbUNhcmV0UmFuZ2UoJGdldENvbGxhcHNlZENhcmV0UmFuZ2Uoc2VsZWN0aW9uQ2FyZXQpKTtcbiAgcmV0dXJuIG5vZGUuZ2V0TGF0ZXN0KCk7XG59XG5cbi8qKlxuICogSWYgdGhlIGluc2VydGlvbiBjYXJldCBpcyB0aGUgcm9vdC9zaGFkb3cgcm9vdCBub2RlIChzZWUge0BsaW5rIGxleGljYWwhJGlzUm9vdE9yU2hhZG93Um9vdH0pLFxuICogdGhlIG5vZGUgd2lsbCBiZSBpbnNlcnRlZCB0aGVyZSwgb3RoZXJ3aXNlIHRoZSBwYXJlbnQgbm9kZXMgd2lsbCBiZSBzcGxpdCBhY2NvcmRpbmcgdG8gdGhlXG4gKiBnaXZlbiBvcHRpb25zLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBpbnNlcnRlZFxuICogQHBhcmFtIGNhcmV0IC0gVGhlIGxvY2F0aW9uIHRvIGluc2VydCBvciBzcGxpdCBmcm9tXG4gKiBAcmV0dXJucyBUaGUgbm9kZSBhZnRlciBpdHMgaW5zZXJ0aW9uXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdEF0Q2FyZXQobm9kZSwgY2FyZXQsIG9wdGlvbnMpIHtcbiAgbGV0IGluc2VydENhcmV0ID0gJGdldENhcmV0SW5EaXJlY3Rpb24oY2FyZXQsICduZXh0Jyk7XG4gIGZvciAobGV0IG5leHRDYXJldCA9IGluc2VydENhcmV0OyBuZXh0Q2FyZXQ7IG5leHRDYXJldCA9ICRzcGxpdEF0UG9pbnRDYXJldE5leHQobmV4dENhcmV0LCBvcHRpb25zKSkge1xuICAgIGluc2VydENhcmV0ID0gbmV4dENhcmV0O1xuICB9XG4gIGlmICghISRpc1RleHRQb2ludENhcmV0KGluc2VydENhcmV0KSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGluc2VydE5vZGVUb05lYXJlc3RSb290QXRDYXJldDogQW4gdW5hdHRhY2hlZCBUZXh0Tm9kZSBjYW4gbm90IGJlIHNwbGl0YCk7XG4gIH1cbiAgaW5zZXJ0Q2FyZXQuaW5zZXJ0KG5vZGUuaXNJbmxpbmUoKSA/ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkuYXBwZW5kKG5vZGUpIDogbm9kZSk7XG4gIHJldHVybiAkZ2V0Q2FyZXRJbkRpcmVjdGlvbigkZ2V0U2libGluZ0NhcmV0KG5vZGUuZ2V0TGF0ZXN0KCksICduZXh0JyksIGNhcmV0LmRpcmVjdGlvbik7XG59XG5cbi8qKlxuICogV3JhcHMgdGhlIG5vZGUgaW50byBhbm90aGVyIG5vZGUgY3JlYXRlZCBmcm9tIGEgY3JlYXRlRWxlbWVudE5vZGUgZnVuY3Rpb24sIGVnLiAkY3JlYXRlUGFyYWdyYXBoTm9kZVxuICogQHBhcmFtIG5vZGUgLSBOb2RlIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudE5vZGUgLSBDcmVhdGVzIGEgbmV3IGxleGljYWwgZWxlbWVudCB0byB3cmFwIHRoZSB0by1iZS13cmFwcGVkIG5vZGUgYW5kIHJldHVybnMgaXQuXG4gKiBAcmV0dXJucyBBIG5ldyBsZXhpY2FsIGVsZW1lbnQgd2l0aCB0aGUgcHJldmlvdXMgbm9kZSBhcHBlbmRlZCB3aXRoaW4gKGFzIGEgY2hpbGQsIGluY2x1ZGluZyBpdHMgY2hpbGRyZW4pLlxuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVJbkVsZW1lbnQobm9kZSwgY3JlYXRlRWxlbWVudE5vZGUpIHtcbiAgY29uc3QgZWxlbWVudE5vZGUgPSBjcmVhdGVFbGVtZW50Tm9kZSgpO1xuICBub2RlLnJlcGxhY2UoZWxlbWVudE5vZGUpO1xuICBlbGVtZW50Tm9kZS5hcHBlbmQobm9kZSk7XG4gIHJldHVybiBlbGVtZW50Tm9kZTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuLyoqXG4gKiBAcGFyYW0gb2JqZWN0ID0gVGhlIGluc3RhbmNlIG9mIHRoZSB0eXBlXG4gKiBAcGFyYW0gb2JqZWN0Q2xhc3MgPSBUaGUgY2xhc3Mgb2YgdGhlIHR5cGVcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG9iamVjdCBpcyBoYXMgdGhlIHNhbWUgS2xhc3Mgb2YgdGhlIG9iamVjdENsYXNzLCBpZ25vcmluZyB0aGUgZGlmZmVyZW5jZSBhY3Jvc3Mgd2luZG93IChlLmcuIGRpZmZlcmVudCBpZnJhbXMpXG4gKi9cbmZ1bmN0aW9uIG9iamVjdEtsYXNzRXF1YWxzKG9iamVjdCwgb2JqZWN0Q2xhc3MpIHtcbiAgcmV0dXJuIG9iamVjdCAhPT0gbnVsbCA/IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpLmNvbnN0cnVjdG9yLm5hbWUgPT09IG9iamVjdENsYXNzLm5hbWUgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgdGhlIG5vZGVzXG4gKiBAcGFyYW0gbm9kZXMgQXJyYXkgb2Ygbm9kZXMgdGhhdCBuZWVkcyB0byBiZSBmaWx0ZXJlZFxuICogQHBhcmFtIGZpbHRlckZuIEEgZmlsdGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBub2RlIGlmIHRoZSBjdXJyZW50IG5vZGUgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gb3RoZXJ3aXNlIG51bGxcbiAqIEByZXR1cm5zIEFycmF5IG9mIGZpbHRlcmVkIG5vZGVzXG4gKi9cblxuZnVuY3Rpb24gJGZpbHRlcihub2RlcywgZmlsdGVyRm4pIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gZmlsdGVyRm4obm9kZXNbaV0pO1xuICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQXBwZW5kcyB0aGUgbm9kZSBiZWZvcmUgdGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBwYXJlbnQgbm9kZVxuICogQHBhcmFtIHBhcmVudCBBIHBhcmVudCBub2RlXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHRoYXQgbmVlZHMgdG8gYmUgYXBwZW5kZWRcbiAqL1xuZnVuY3Rpb24gJGluc2VydEZpcnN0KHBhcmVudCwgbm9kZSkge1xuICAkZ2V0Q2hpbGRDYXJldChwYXJlbnQsICduZXh0JykuaW5zZXJ0KG5vZGUpO1xufVxubGV0IE5FRURTX01BTlVBTF9aT09NID0gSVNfRklSRUZPWCB8fCAhQ0FOX1VTRV9ET00gPyBmYWxzZSA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIG5lZWRzTWFudWFsWm9vbSgpIHtcbiAgaWYgKE5FRURTX01BTlVBTF9aT09NID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBJZiB0aGUgYnJvd3NlciBpbXBsZW1lbnRzIHN0YW5kYXJkaXplZCBDU1Mgem9vbSwgdGhlbiB0aGUgY2xpZW50IHJlY3RcbiAgICAvLyB3aWxsIGJlIHdpZGVyIGFmdGVyIHpvb20gaXMgYXBwbGllZFxuICAgIC8vIGh0dHBzOi8vY2hyb21lc3RhdHVzLmNvbS9mZWF0dXJlLzUxOTgyNTQ4Njg1MjkxNTJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svbGV4aWNhbC9pc3N1ZXMvNjg2M1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgb3BhY2l0eTogMDsgd2lkdGg6IDEwMHB4OyBsZWZ0OiAtMTAwMHB4Oyc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgIGNvbnN0IG5vWm9vbSA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBkaXYuc3R5bGUuc2V0UHJvcGVydHkoJ3pvb20nLCAnMicpO1xuICAgIE5FRURTX01BTlVBTF9aT09NID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoID09PSBub1pvb20ud2lkdGg7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICB9XG4gIHJldHVybiBORUVEU19NQU5VQUxfWk9PTTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB6b29tIGxldmVsIG9mIGFuIGVsZW1lbnQgYXMgYSByZXN1bHQgb2YgdXNpbmdcbiAqIGNzcyB6b29tIHByb3BlcnR5LiBGb3IgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnQgc3RhbmRhcmRpemVkIENTU1xuICogem9vbSAoRmlyZWZveCwgQ2hyb21lID49IDEyOCksIHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIDEuXG4gKiBAcGFyYW0gZWxlbWVudFxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVab29tTGV2ZWwoZWxlbWVudCkge1xuICBsZXQgem9vbSA9IDE7XG4gIGlmIChuZWVkc01hbnVhbFpvb20oKSkge1xuICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICB6b29tICo9IE51bWJlcih3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCd6b29tJykpO1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHpvb207XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBlZGl0b3IgaXMgYSBuZXN0ZWQgZWRpdG9yIGNyZWF0ZWQgYnkgTGV4aWNhbE5lc3RlZENvbXBvc2VyXG4gKi9cbmZ1bmN0aW9uICRpc0VkaXRvcklzTmVzdGVkRWRpdG9yKGVkaXRvcikge1xuICByZXR1cm4gZWRpdG9yLl9wYXJlbnRFZGl0b3IgIT09IG51bGw7XG59XG5cbi8qKlxuICogQSBkZXB0aCBmaXJzdCBsYXN0LXRvLWZpcnN0IHRyYXZlcnNhbCBvZiByb290IHRoYXQgc3RvcHMgYXQgZWFjaCBub2RlIHRoYXQgbWF0Y2hlc1xuICogJHByZWRpY2F0ZSBhbmQgZW5zdXJlcyB0aGF0IGl0cyBwYXJlbnQgaXMgcm9vdC4gVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCB0byBkaXNjYXJkXG4gKiBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIHdyYXBwaW5nIG5vZGVzLiBGb3IgZXhhbXBsZSwgYSBUYWJsZU5vZGUgbXVzdCBvbmx5IGhhdmVcbiAqIFRhYmxlUm93Tm9kZSBhcyBjaGlsZHJlbiwgYnV0IGFuIGltcG9ydGVyIG1pZ2h0IGFkZCBpbnZhbGlkIG5vZGVzIGJhc2VkIG9uXG4gKiBjYXB0aW9uLCB0Ym9keSwgdGhlYWQsIGV0Yy4gYW5kIHRoaXMgd2lsbCB1bndyYXAgYW5kIGRpc2NhcmQgdGhvc2UuXG4gKlxuICogQHBhcmFtIHJvb3QgVGhlIHJvb3QgdG8gc3RhcnQgdGhlIHRyYXZlcnNhbFxuICogQHBhcmFtICRwcmVkaWNhdGUgU2hvdWxkIHJldHVybiB0cnVlIGZvciBub2RlcyB0aGF0IGFyZSBwZXJtaXR0ZWQgdG8gYmUgY2hpbGRyZW4gb2Ygcm9vdFxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIHVud3JhcHBlZCBvciByZW1vdmVkIGFueSBub2Rlc1xuICovXG5mdW5jdGlvbiAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHMocm9vdCwgJHByZWRpY2F0ZSkge1xuICByZXR1cm4gJHVud3JhcEFuZEZpbHRlckRlc2NlbmRhbnRzSW1wbChyb290LCAkcHJlZGljYXRlLCBudWxsKTtcbn1cbmZ1bmN0aW9uICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50c0ltcGwocm9vdCwgJHByZWRpY2F0ZSwgJG9uU3VjY2Vzcykge1xuICBsZXQgZGlkTXV0YXRlID0gZmFsc2U7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiAkbGFzdFRvRmlyc3RJdGVyYXRvcihyb290KSkge1xuICAgIGlmICgkcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICBpZiAoJG9uU3VjY2VzcyAhPT0gbnVsbCkge1xuICAgICAgICAkb25TdWNjZXNzKG5vZGUpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGRpZE11dGF0ZSA9IHRydWU7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHNJbXBsKG5vZGUsICRwcmVkaWNhdGUsICRvblN1Y2Nlc3MgfHwgKGNoaWxkID0+IG5vZGUuaW5zZXJ0QWZ0ZXIoY2hpbGQpKSk7XG4gICAgfVxuICAgIG5vZGUucmVtb3ZlKCk7XG4gIH1cbiAgcmV0dXJuIGRpZE11dGF0ZTtcbn1cblxuLyoqXG4gKiBBIGRlcHRoIGZpcnN0IHRyYXZlcnNhbCBvZiB0aGUgY2hpbGRyZW4gYXJyYXkgdGhhdCBzdG9wcyBhdCBhbmQgY29sbGVjdHNcbiAqIGVhY2ggbm9kZSB0aGF0IGAkcHJlZGljYXRlYCBtYXRjaGVzLiBUaGlzIGlzIHR5cGljYWxseSB1c2VkIHRvIGRpc2NhcmRcbiAqIGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgd3JhcHBpbmcgbm9kZXMgb24gYSBjaGlsZHJlbiBhcnJheSBpbiB0aGUgYGFmdGVyYFxuICogb2YgYW4ge0BsaW5rIGxleGljYWwhRE9NQ29udmVyc2lvbk91dHB1dH0uIEZvciBleGFtcGxlLCBhIFRhYmxlTm9kZSBtdXN0IG9ubHkgaGF2ZVxuICogVGFibGVSb3dOb2RlIGFzIGNoaWxkcmVuLCBidXQgYW4gaW1wb3J0ZXIgbWlnaHQgYWRkIGludmFsaWQgbm9kZXMgYmFzZWQgb25cbiAqIGNhcHRpb24sIHRib2R5LCB0aGVhZCwgZXRjLiBhbmQgdGhpcyB3aWxsIHVud3JhcCBhbmQgZGlzY2FyZCB0aG9zZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHJlYWQtb25seSBhbmQgcGVyZm9ybXMgbm8gbXV0YXRpb24gb3BlcmF0aW9ucywgd2hpY2ggbWFrZXNcbiAqIGl0IHN1aXRhYmxlIGZvciBpbXBvcnQgYW5kIGV4cG9ydCBwdXJwb3NlcyBidXQgbGlrZWx5IG5vdCBmb3IgYW55IGluLXBsYWNlXG4gKiBtdXRhdGlvbi4gWW91IHNob3VsZCB1c2Uge0BsaW5rICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50c30gZm9yIGluLXBsYWNlXG4gKiBtdXRhdGlvbnMgc3VjaCBhcyBub2RlIHRyYW5zZm9ybXMuXG4gKlxuICogQHBhcmFtIGNoaWxkcmVuIFRoZSBjaGlsZHJlbiB0byB0cmF2ZXJzZVxuICogQHBhcmFtICRwcmVkaWNhdGUgU2hvdWxkIHJldHVybiB0cnVlIGZvciBub2RlcyB0aGF0IGFyZSBwZXJtaXR0ZWQgdG8gYmUgY2hpbGRyZW4gb2Ygcm9vdFxuICogQHJldHVybnMgVGhlIGNoaWxkcmVuIG9yIHRoZWlyIGRlc2NlbmRhbnRzIHRoYXQgbWF0Y2ggJHByZWRpY2F0ZVxuICovXG5cbmZ1bmN0aW9uICRkZXNjZW5kYW50c01hdGNoaW5nKGNoaWxkcmVuLCAkcHJlZGljYXRlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzdGFjayA9IEFycmF5LmZyb20oY2hpbGRyZW4pLnJldmVyc2UoKTtcbiAgZm9yIChsZXQgY2hpbGQgPSBzdGFjay5wb3AoKTsgY2hpbGQgIT09IHVuZGVmaW5lZDsgY2hpbGQgPSBzdGFjay5wb3AoKSkge1xuICAgIGlmICgkcHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgIH0gZWxzZSBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyYW5kY2hpbGQgb2YgJGxhc3RUb0ZpcnN0SXRlcmF0b3IoY2hpbGQpKSB7XG4gICAgICAgIHN0YWNrLnB1c2goZ3JhbmRjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGl0ZXJhdG9yIHRoYXQgeWllbGRzIGVhY2ggY2hpbGQgb2Ygbm9kZSBmcm9tIGZpcnN0IHRvIGxhc3QsIHRha2luZ1xuICogY2FyZSB0byBwcmVzZXJ2ZSB0aGUgbmV4dCBzaWJsaW5nIGJlZm9yZSB5aWVsZGluZyB0aGUgdmFsdWUgaW4gY2FzZSB0aGUgY2FsbGVyXG4gKiByZW1vdmVzIHRoZSB5aWVsZGVkIG5vZGUuXG4gKlxuICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgd2hvc2UgY2hpbGRyZW4gdG8gaXRlcmF0ZVxuICogQHJldHVybnMgQW4gaXRlcmF0b3Igb2YgdGhlIG5vZGUncyBjaGlsZHJlblxuICovXG5mdW5jdGlvbiAkZmlyc3RUb0xhc3RJdGVyYXRvcihub2RlKSB7XG4gIHJldHVybiAkY2hpbGRJdGVyYXRvcigkZ2V0Q2hpbGRDYXJldChub2RlLCAnbmV4dCcpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gaXRlcmF0b3IgdGhhdCB5aWVsZHMgZWFjaCBjaGlsZCBvZiBub2RlIGZyb20gbGFzdCB0byBmaXJzdCwgdGFraW5nXG4gKiBjYXJlIHRvIHByZXNlcnZlIHRoZSBwcmV2aW91cyBzaWJsaW5nIGJlZm9yZSB5aWVsZGluZyB0aGUgdmFsdWUgaW4gY2FzZSB0aGUgY2FsbGVyXG4gKiByZW1vdmVzIHRoZSB5aWVsZGVkIG5vZGUuXG4gKlxuICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgd2hvc2UgY2hpbGRyZW4gdG8gaXRlcmF0ZVxuICogQHJldHVybnMgQW4gaXRlcmF0b3Igb2YgdGhlIG5vZGUncyBjaGlsZHJlblxuICovXG5mdW5jdGlvbiAkbGFzdFRvRmlyc3RJdGVyYXRvcihub2RlKSB7XG4gIHJldHVybiAkY2hpbGRJdGVyYXRvcigkZ2V0Q2hpbGRDYXJldChub2RlLCAncHJldmlvdXMnKSk7XG59XG5mdW5jdGlvbiAkY2hpbGRJdGVyYXRvcihzdGFydENhcmV0KSB7XG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCkgO1xuICByZXR1cm4gbWFrZVN0ZXB3aXNlSXRlcmF0b3Ioe1xuICAgIGhhc05leHQ6ICRpc1NpYmxpbmdDYXJldCxcbiAgICBpbml0aWFsOiBzdGFydENhcmV0LmdldEFkamFjZW50Q2FyZXQoKSxcbiAgICBtYXA6IGNhcmV0ID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbiA9IGNhcmV0Lm9yaWdpbi5nZXRMYXRlc3QoKTtcbiAgICAgIGlmIChzZWVuICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG9yaWdpbi5nZXRLZXkoKTtcbiAgICAgICAgaWYgKCEhc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGNoaWxkSXRlcmF0b3I6IEN5Y2xlIGRldGVjdGVkLCBub2RlIHdpdGgga2V5ICR7U3RyaW5nKGtleSl9IGhhcyBhbHJlYWR5IGJlZW4gdHJhdmVyc2VkYCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfSxcbiAgICBzdGVwOiBjYXJldCA9PiBjYXJldC5nZXRBZGphY2VudENhcmV0KClcbiAgfSk7XG59XG5cbi8qKlxuICogUmVwbGFjZSB0aGlzIG5vZGUgd2l0aCBpdHMgY2hpbGRyZW5cbiAqXG4gKiBAcGFyYW0gbm9kZSBUaGUgRWxlbWVudE5vZGUgdG8gdW53cmFwIGFuZCByZW1vdmVcbiAqL1xuZnVuY3Rpb24gJHVud3JhcE5vZGUobm9kZSkge1xuICAkcmV3aW5kU2libGluZ0NhcmV0KCRnZXRTaWJsaW5nQ2FyZXQobm9kZSwgJ25leHQnKSkuc3BsaWNlKDEsIG5vZGUuZ2V0Q2hpbGRyZW4oKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgTm9kZSBzaWJsaW5nIHdoZW4gdGhpcyBleGlzdHMsIG90aGVyd2lzZSB0aGUgY2xvc2VzdCBwYXJlbnQgc2libGluZy4gRm9yIGV4YW1wbGVcbiAqIFIgLT4gUCAtPiBUMSwgVDJcbiAqICAgLT4gUDJcbiAqIHJldHVybnMgVDIgZm9yIG5vZGUgVDEsIFAyIGZvciBub2RlIFQyLCBhbmQgbnVsbCBmb3Igbm9kZSBQMi5cbiAqIEBwYXJhbSBub2RlIExleGljYWxOb2RlLlxuICogQHJldHVybnMgQW4gYXJyYXkgKHR1cGxlKSBjb250YWluaW5nIHRoZSBmb3VuZCBMZXhpY2FsIG5vZGUgYW5kIHRoZSBkZXB0aCBkaWZmZXJlbmNlLCBvciBudWxsLCBpZiB0aGlzIG5vZGUgZG9lc24ndCBleGlzdC5cbiAqL1xuZnVuY3Rpb24gJGdldEFkamFjZW50U2libGluZ09yUGFyZW50U2libGluZ0NhcmV0KHN0YXJ0Q2FyZXQsIHJvb3RNb2RlID0gJ3Jvb3QnKSB7XG4gIGxldCBkZXB0aERpZmYgPSAwO1xuICBsZXQgY2FyZXQgPSBzdGFydENhcmV0O1xuICBsZXQgbmV4dENhcmV0ID0gJGdldEFkamFjZW50Q2hpbGRDYXJldChjYXJldCk7XG4gIHdoaWxlIChuZXh0Q2FyZXQgPT09IG51bGwpIHtcbiAgICBkZXB0aERpZmYtLTtcbiAgICBuZXh0Q2FyZXQgPSBjYXJldC5nZXRQYXJlbnRDYXJldChyb290TW9kZSk7XG4gICAgaWYgKCFuZXh0Q2FyZXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjYXJldCA9IG5leHRDYXJldDtcbiAgICBuZXh0Q2FyZXQgPSAkZ2V0QWRqYWNlbnRDaGlsZENhcmV0KGNhcmV0KTtcbiAgfVxuICByZXR1cm4gbmV4dENhcmV0ICYmIFtuZXh0Q2FyZXQsIGRlcHRoRGlmZl07XG59XG5cbi8qKlxuICogQSB3cmFwcGVyIHRoYXQgY3JlYXRlcyBib3VuZCBmdW5jdGlvbnMgYW5kIG1ldGhvZHMgZm9yIHRoZVxuICogU3RhdGVDb25maWcgdG8gc2F2ZSBzb21lIGJvaWxlcnBsYXRlIHdoZW4gZGVmaW5pbmcgbWV0aG9kc1xuICogb3IgZXhwb3J0aW5nIG9ubHkgdGhlIGFjY2Vzc29ycyBmcm9tIHlvdXIgbW9kdWxlcyByYXRoZXJcbiAqIHRoYW4gZXhwb3NpbmcgdGhlIFN0YXRlQ29uZmlnIGRpcmVjdGx5LlxuICovXG5cbi8qKlxuICogRVhQRVJJTUVOVEFMXG4gKlxuICogQSBjb252ZW5pZW5jZSBpbnRlcmZhY2UgZm9yIHdvcmtpbmcgd2l0aCB7QGxpbmsgJGdldFN0YXRlfSBhbmRcbiAqIHtAbGluayAkc2V0U3RhdGV9LlxuICpcbiAqIEBwYXJhbSBzdGF0ZUNvbmZpZyBUaGUgc3RhdGVDb25maWcgdG8gd3JhcCB3aXRoIGNvbnZlbmllbmNlIGZ1bmN0aW9uYWxpdHlcbiAqIEByZXR1cm5zIGEgU3RhdGVXcmFwcGVyXG4gKi9cbmZ1bmN0aW9uIG1ha2VTdGF0ZVdyYXBwZXIoc3RhdGVDb25maWcpIHtcbiAgY29uc3QgJGdldCA9IG5vZGUgPT4gJGdldFN0YXRlKG5vZGUsIHN0YXRlQ29uZmlnKTtcbiAgY29uc3QgJHNldCA9IChub2RlLCB2YWx1ZU9yVXBkYXRlcikgPT4gJHNldFN0YXRlKG5vZGUsIHN0YXRlQ29uZmlnLCB2YWx1ZU9yVXBkYXRlcik7XG4gIHJldHVybiB7XG4gICAgJGdldCxcbiAgICAkc2V0LFxuICAgIGFjY2Vzc29yczogWyRnZXQsICRzZXRdLFxuICAgIG1ha2VHZXR0ZXJNZXRob2Q6ICgpID0+IGZ1bmN0aW9uICRnZXR0ZXIoKSB7XG4gICAgICByZXR1cm4gJGdldCh0aGlzKTtcbiAgICB9LFxuICAgIG1ha2VTZXR0ZXJNZXRob2Q6ICgpID0+IGZ1bmN0aW9uICRzZXR0ZXIodmFsdWVPclVwZGF0ZXIpIHtcbiAgICAgIHJldHVybiAkc2V0KHRoaXMsIHZhbHVlT3JVcGRhdGVyKTtcbiAgICB9LFxuICAgIHN0YXRlQ29uZmlnXG4gIH07XG59XG5cbmV4cG9ydCB7ICRkZXNjZW5kYW50c01hdGNoaW5nLCAkZGZzLCAkZGZzSXRlcmF0b3IsICRmaWx0ZXIsICRmaW5kTWF0Y2hpbmdQYXJlbnQsICRmaXJzdFRvTGFzdEl0ZXJhdG9yLCAkZ2V0QWRqYWNlbnRDYXJldCwgJGdldEFkamFjZW50U2libGluZ09yUGFyZW50U2libGluZ0NhcmV0LCAkZ2V0RGVwdGgsICRnZXROZWFyZXN0QmxvY2tFbGVtZW50QW5jZXN0b3JPclRocm93LCAkZ2V0TmVhcmVzdE5vZGVPZlR5cGUsICRnZXROZXh0UmlnaHRQcmVvcmRlck5vZGUsICRnZXROZXh0U2libGluZ09yUGFyZW50U2libGluZywgJGluc2VydEZpcnN0LCAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3QsICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdEF0Q2FyZXQsICRpc0VkaXRvcklzTmVzdGVkRWRpdG9yLCAkbGFzdFRvRmlyc3RJdGVyYXRvciwgJHJlc3RvcmVFZGl0b3JTdGF0ZSwgJHJldmVyc2VEZnMsICRyZXZlcnNlRGZzSXRlcmF0b3IsICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50cywgJHVud3JhcE5vZGUsICR3cmFwTm9kZUluRWxlbWVudCwgQ0FOX1VTRV9CRUZPUkVfSU5QVVQsIENBTl9VU0VfRE9NLCBJU19BTkRST0lELCBJU19BTkRST0lEX0NIUk9NRSwgSVNfQVBQTEUsIElTX0FQUExFX1dFQktJVCwgSVNfQ0hST01FLCBJU19GSVJFRk9YLCBJU19JT1MsIElTX1NBRkFSSSwgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCwgY2FsY3VsYXRlWm9vbUxldmVsLCBpc01pbWVUeXBlLCBtYWtlU3RhdGVXcmFwcGVyLCBtYXJrU2VsZWN0aW9uLCBtZWRpYUZpbGVSZWFkZXIsIG1lcmdlUmVnaXN0ZXIsIG9iamVjdEtsYXNzRXF1YWxzLCBtbGNQb3NpdGlvbk5vZGVPblJhbmdlIGFzIHBvc2l0aW9uTm9kZU9uUmFuZ2UsIHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyLCByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQsIHNlbGVjdGlvbkFsd2F5c09uRGlzcGxheSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@lexical+utils@0.28.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@lexical+utils@0.28.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+utils@0.28.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $descendantsMatching: () => (/* binding */ $descendantsMatching),\n/* harmony export */   $dfs: () => (/* binding */ $dfs),\n/* harmony export */   $dfsIterator: () => (/* binding */ $dfsIterator),\n/* harmony export */   $filter: () => (/* binding */ $filter),\n/* harmony export */   $findMatchingParent: () => (/* binding */ $findMatchingParent),\n/* harmony export */   $firstToLastIterator: () => (/* binding */ $firstToLastIterator),\n/* harmony export */   $getAdjacentCaret: () => (/* binding */ $getAdjacentCaret),\n/* harmony export */   $getAdjacentSiblingOrParentSiblingCaret: () => (/* binding */ $getAdjacentSiblingOrParentSiblingCaret),\n/* harmony export */   $getDepth: () => (/* binding */ $getDepth),\n/* harmony export */   $getNearestBlockElementAncestorOrThrow: () => (/* binding */ $getNearestBlockElementAncestorOrThrow),\n/* harmony export */   $getNearestNodeOfType: () => (/* binding */ $getNearestNodeOfType),\n/* harmony export */   $getNextRightPreorderNode: () => (/* binding */ $getNextRightPreorderNode),\n/* harmony export */   $getNextSiblingOrParentSibling: () => (/* binding */ $getNextSiblingOrParentSibling),\n/* harmony export */   $insertFirst: () => (/* binding */ $insertFirst),\n/* harmony export */   $insertNodeToNearestRoot: () => (/* binding */ $insertNodeToNearestRoot),\n/* harmony export */   $insertNodeToNearestRootAtCaret: () => (/* binding */ $insertNodeToNearestRootAtCaret),\n/* harmony export */   $isEditorIsNestedEditor: () => (/* binding */ $isEditorIsNestedEditor),\n/* harmony export */   $lastToFirstIterator: () => (/* binding */ $lastToFirstIterator),\n/* harmony export */   $restoreEditorState: () => (/* binding */ $restoreEditorState),\n/* harmony export */   $reverseDfs: () => (/* binding */ $reverseDfs),\n/* harmony export */   $reverseDfsIterator: () => (/* binding */ $reverseDfsIterator),\n/* harmony export */   $splitNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode),\n/* harmony export */   $unwrapAndFilterDescendants: () => (/* binding */ $unwrapAndFilterDescendants),\n/* harmony export */   $unwrapNode: () => (/* binding */ $unwrapNode),\n/* harmony export */   $wrapNodeInElement: () => (/* binding */ $wrapNodeInElement),\n/* harmony export */   CAN_USE_BEFORE_INPUT: () => (/* binding */ CAN_USE_BEFORE_INPUT),\n/* harmony export */   CAN_USE_DOM: () => (/* binding */ CAN_USE_DOM),\n/* harmony export */   IS_ANDROID: () => (/* binding */ IS_ANDROID),\n/* harmony export */   IS_ANDROID_CHROME: () => (/* binding */ IS_ANDROID_CHROME),\n/* harmony export */   IS_APPLE: () => (/* binding */ IS_APPLE),\n/* harmony export */   IS_APPLE_WEBKIT: () => (/* binding */ IS_APPLE_WEBKIT),\n/* harmony export */   IS_CHROME: () => (/* binding */ IS_CHROME),\n/* harmony export */   IS_FIREFOX: () => (/* binding */ IS_FIREFOX),\n/* harmony export */   IS_IOS: () => (/* binding */ IS_IOS),\n/* harmony export */   IS_SAFARI: () => (/* binding */ IS_SAFARI),\n/* harmony export */   addClassNamesToElement: () => (/* binding */ addClassNamesToElement),\n/* harmony export */   calculateZoomLevel: () => (/* binding */ calculateZoomLevel),\n/* harmony export */   isBlockDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode),\n/* harmony export */   isHTMLAnchorElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement),\n/* harmony export */   isHTMLElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement),\n/* harmony export */   isInlineDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode),\n/* harmony export */   isMimeType: () => (/* binding */ isMimeType),\n/* harmony export */   makeStateWrapper: () => (/* binding */ makeStateWrapper),\n/* harmony export */   markSelection: () => (/* binding */ markSelection),\n/* harmony export */   mediaFileReader: () => (/* binding */ mediaFileReader),\n/* harmony export */   mergeRegister: () => (/* binding */ mergeRegister),\n/* harmony export */   objectKlassEquals: () => (/* binding */ objectKlassEquals),\n/* harmony export */   positionNodeOnRange: () => (/* binding */ mlcPositionNodeOnRange),\n/* harmony export */   registerNestedElementResolver: () => (/* binding */ registerNestedElementResolver),\n/* harmony export */   removeClassNamesFromElement: () => (/* binding */ removeClassNamesFromElement),\n/* harmony export */   selectionAlwaysOnDisplay: () => (/* binding */ selectionAlwaysOnDisplay)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/.pnpm/lexical@0.28.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/.pnpm/@lexical+selection@0.28.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction prependDOMNode(parent, node) {\n  parent.insertBefore(node, parent.firstChild);\n}\n\n/**\n * Place one or multiple newly created Nodes at the passed Range's position.\n * Multiple nodes will only be created when the Range spans multiple lines (aka\n * client rects).\n *\n * This function can come particularly useful to highlight particular parts of\n * the text without interfering with the EditorState, that will often replicate\n * the state across collab and clipboard.\n *\n * This function accounts for DOM updates which can modify the passed Range.\n * Hence, the function return to remove the listener.\n */\nfunction mlcPositionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  wrapperNode.style.position = 'relative';\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: parentLeft,\n      top: parentTop\n    } = parentDOMNode.getBoundingClientRect();\n    const rects = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.createRectsFromDOMRange)(editor, range);\n    if (!wrapperNode.isConnected) {\n      prependDOMNode(parentDOMNode, wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - parentLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - parentTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(currentParentDOMNode)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction rangeTargetFromPoint(point, node, dom) {\n  if (point.type === 'text' || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    const textDOM = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMTextNode)(dom) || dom;\n    return [textDOM, point.offset];\n  } else {\n    const slot = node.getDOMSlot(dom);\n    return [slot.element, slot.getFirstChildOffset() + point.offset];\n  }\n}\nfunction rangeFromPoints(editor, anchor, anchorNode, anchorDOM, focus, focusNode, focusDOM) {\n  const editorDocument = editor._window ? editor._window.document : document;\n  const range = editorDocument.createRange();\n  if (focusNode.isBefore(anchorNode)) {\n    range.setStart(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n    range.setEnd(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n  } else {\n    range.setStart(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n    range.setEnd(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n  }\n  return range;\n}\n/**\n * Place one or multiple newly created Nodes at the current selection. Multiple\n * nodes will only be created when the selection spans multiple lines (aka\n * client rects).\n *\n * This function can come useful when you want to show the selection but the\n * editor has been focused away.\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorNodeDOM = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusNodeDOM = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM !== previousAnchorNodeDOM || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey();\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM !== previousFocusNodeDOM || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey();\n      if ((differentAnchorDOM || differentFocusDOM) && currentAnchorNodeDOM !== null && currentFocusNodeDOM !== null) {\n        const range = rangeFromPoints(editor, anchor, currentAnchorNode, currentAnchorNodeDOM, focus, currentFocusNode, currentFocusNodeDOM);\n        removeRangeListener();\n        removeRangeListener = mlcPositionNodeOnRange(editor, range, domNodes => {\n          if (onReposition === undefined) {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n          } else {\n            onReposition(domNodes);\n          }\n        });\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorNodeDOM = currentAnchorNodeDOM;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusNodeDOM = currentFocusNodeDOM;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction selectionAlwaysOnDisplay(editor) {\n  let removeSelectionMark = null;\n  const onSelectionChange = () => {\n    const domSelection = getSelection();\n    const domAnchorNode = domSelection && domSelection.anchorNode;\n    const editorRootElement = editor.getRootElement();\n    const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);\n    if (isSelectionInsideEditor) {\n      if (removeSelectionMark !== null) {\n        removeSelectionMark();\n        removeSelectionMark = null;\n      }\n    } else {\n      if (removeSelectionMark === null) {\n        removeSelectionMark = markSelection(editor);\n      }\n    }\n  };\n  document.addEventListener('selectionchange', onSelectionChange);\n  return () => {\n    if (removeSelectionMark !== null) {\n      removeSelectionMark();\n    }\n    document.removeEventListener('selectionchange', onSelectionChange);\n  };\n}\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the start node).\n */\nfunction $dfs(startNode, endNode) {\n  return Array.from($dfsIterator(startNode, endNode));\n}\n\n/**\n * Get the adjacent caret in the same direction\n *\n * @param caret A caret or null\n * @returns `caret.getAdjacentCaret()` or `null`\n */\nfunction $getAdjacentCaret(caret) {\n  return caret ? caret.getAdjacentCaret() : null;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfs(startNode, endNode) {\n  return Array.from($reverseDfsIterator(startNode, endNode));\n}\n\n/**\n * $dfs iterator (left to right). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $dfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('next', startNode, endNode);\n}\nfunction $getEndCaret(startNode, direction) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(startNode, direction));\n  return rval && rval[0];\n}\nfunction $dfsCaretIterator(direction, startNode, endNode) {\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const start = startNode || root;\n  const startCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(start) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(start, direction) : (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(start, direction);\n  const startDepth = $getDepth(start);\n  const endCaret = endNode ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaretOrSelf)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(endNode, direction))) : $getEndCaret(start, direction);\n  let depth = startDepth;\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.makeStepwiseIterator)({\n    hasNext: state => state !== null,\n    initial: startCaret,\n    map: state => ({\n      depth,\n      node: state.origin\n    }),\n    step: state => {\n      if (state.isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(state)) {\n        depth++;\n      }\n      const rval = $getAdjacentSiblingOrParentSiblingCaret(state);\n      if (!rval || rval[0].isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      depth += rval[1];\n      return rval[0];\n    }\n  });\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getNextSiblingOrParentSibling(node) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(node, 'next'));\n  return rval && [rval[0].origin, rval[1]];\n}\nfunction $getDepth(node) {\n  let depth = -1;\n  for (let innerNode = node; innerNode !== null; innerNode = innerNode.getParent()) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to parent and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  const startCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaretOrSelf)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(startingNode, 'previous'));\n  const next = $getAdjacentSiblingOrParentSiblingCaret(startCaret, 'root');\n  return next && next[0].origin;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('previous', startNode, endNode);\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(blockNode)) {\n    {\n      formatDevErrorMessage(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  let initialCaret;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    initialCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$caretFromPoint)(selection.focus, 'next');\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      const lastNode = nodes[nodes.length - 1];\n      if (lastNode) {\n        initialCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(lastNode, 'next');\n      }\n    }\n    initialCaret = initialCaret || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)(), 'previous').getFlipped().insert((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n  }\n  const insertCaret = $insertNodeToNearestRootAtCaret(node, initialCaret);\n  const adjacent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(insertCaret);\n  const selectionCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(adjacent) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)(adjacent) : insertCaret;\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelectionFromCaretRange)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCollapsedCaretRange)(selectionCaret));\n  return node.getLatest();\n}\n\n/**\n * If the insertion caret is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be inserted there, otherwise the parent nodes will be split according to the\n * given options.\n * @param node - The node to be inserted\n * @param caret - The location to insert or split from\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRootAtCaret(node, caret, options) {\n  let insertCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCaretInDirection)(caret, 'next');\n  for (let nextCaret = insertCaret; nextCaret; nextCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$splitAtPointCaretNext)(nextCaret, options)) {\n    insertCaret = nextCaret;\n  }\n  if (!!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextPointCaret)(insertCaret)) {\n    formatDevErrorMessage(`$insertNodeToNearestRootAtCaret: An unattached TextNode can not be split`);\n  }\n  insertCaret.insert(node.isInline() ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)().append(node) : node);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCaretInDirection)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(node.getLatest(), 'next'), caret.direction);\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(parent, 'next').insert(node);\n}\nlet NEEDS_MANUAL_ZOOM = IS_FIREFOX || !CAN_USE_DOM ? false : undefined;\nfunction needsManualZoom() {\n  if (NEEDS_MANUAL_ZOOM === undefined) {\n    // If the browser implements standardized CSS zoom, then the client rect\n    // will be wider after zoom is applied\n    // https://chromestatus.com/feature/5198254868529152\n    // https://github.com/facebook/lexical/issues/6863\n    const div = document.createElement('div');\n    div.style.cssText = 'position: absolute; opacity: 0; width: 100px; left: -1000px;';\n    document.body.appendChild(div);\n    const noZoom = div.getBoundingClientRect();\n    div.style.setProperty('zoom', '2');\n    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;\n    document.body.removeChild(div);\n  }\n  return NEEDS_MANUAL_ZOOM;\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property. For browsers that implement standardized CSS\n * zoom (Firefox, Chrome >= 128), this will always return 1.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  let zoom = 1;\n  if (needsManualZoom()) {\n    while (element) {\n      zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n      element = element.parentElement;\n    }\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\n/**\n * A depth first last-to-first traversal of root that stops at each node that matches\n * $predicate and ensures that its parent is root. This is typically used to discard\n * invalid or unsupported wrapping nodes. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * @param root The root to start the traversal\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns true if this unwrapped or removed any nodes\n */\nfunction $unwrapAndFilterDescendants(root, $predicate) {\n  return $unwrapAndFilterDescendantsImpl(root, $predicate, null);\n}\nfunction $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {\n  let didMutate = false;\n  for (const node of $lastToFirstIterator(root)) {\n    if ($predicate(node)) {\n      if ($onSuccess !== null) {\n        $onSuccess(node);\n      }\n      continue;\n    }\n    didMutate = true;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess || (child => node.insertAfter(child)));\n    }\n    node.remove();\n  }\n  return didMutate;\n}\n\n/**\n * A depth first traversal of the children array that stops at and collects\n * each node that `$predicate` matches. This is typically used to discard\n * invalid or unsupported wrapping nodes on a children array in the `after`\n * of an {@link lexical!DOMConversionOutput}. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * This function is read-only and performs no mutation operations, which makes\n * it suitable for import and export purposes but likely not for any in-place\n * mutation. You should use {@link $unwrapAndFilterDescendants} for in-place\n * mutations such as node transforms.\n *\n * @param children The children to traverse\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns The children or their descendants that match $predicate\n */\n\nfunction $descendantsMatching(children, $predicate) {\n  const result = [];\n  const stack = Array.from(children).reverse();\n  for (let child = stack.pop(); child !== undefined; child = stack.pop()) {\n    if ($predicate(child)) {\n      result.push(child);\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n      for (const grandchild of $lastToFirstIterator(child)) {\n        stack.push(grandchild);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Return an iterator that yields each child of node from first to last, taking\n * care to preserve the next sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $firstToLastIterator(node) {\n  return $childIterator((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(node, 'next'));\n}\n\n/**\n * Return an iterator that yields each child of node from last to first, taking\n * care to preserve the previous sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $lastToFirstIterator(node) {\n  return $childIterator((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(node, 'previous'));\n}\nfunction $childIterator(startCaret) {\n  const seen = new Set() ;\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.makeStepwiseIterator)({\n    hasNext: lexical__WEBPACK_IMPORTED_MODULE_0__.$isSiblingCaret,\n    initial: startCaret.getAdjacentCaret(),\n    map: caret => {\n      const origin = caret.origin.getLatest();\n      if (seen !== null) {\n        const key = origin.getKey();\n        if (!!seen.has(key)) {\n          formatDevErrorMessage(`$childIterator: Cycle detected, node with key ${String(key)} has already been traversed`);\n        }\n        seen.add(key);\n      }\n      return origin;\n    },\n    step: caret => caret.getAdjacentCaret()\n  });\n}\n\n/**\n * Replace this node with its children\n *\n * @param node The ElementNode to unwrap and remove\n */\nfunction $unwrapNode(node) {\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$rewindSiblingCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(node, 'next')).splice(1, node.getChildren());\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getAdjacentSiblingOrParentSiblingCaret(startCaret, rootMode = 'root') {\n  let depthDiff = 0;\n  let caret = startCaret;\n  let nextCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(caret);\n  while (nextCaret === null) {\n    depthDiff--;\n    nextCaret = caret.getParentCaret(rootMode);\n    if (!nextCaret) {\n      return null;\n    }\n    caret = nextCaret;\n    nextCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(caret);\n  }\n  return nextCaret && [nextCaret, depthDiff];\n}\n\n/**\n * A wrapper that creates bound functions and methods for the\n * StateConfig to save some boilerplate when defining methods\n * or exporting only the accessors from your modules rather\n * than exposing the StateConfig directly.\n */\n\n/**\n * EXPERIMENTAL\n *\n * A convenience interface for working with {@link $getState} and\n * {@link $setState}.\n *\n * @param stateConfig The stateConfig to wrap with convenience functionality\n * @returns a StateWrapper\n */\nfunction makeStateWrapper(stateConfig) {\n  const $get = node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getState)(node, stateConfig);\n  const $set = (node, valueOrUpdater) => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setState)(node, stateConfig, valueOrUpdater);\n  return {\n    $get,\n    $set,\n    accessors: [$get, $set],\n    makeGetterMethod: () => function $getter() {\n      return $get(this);\n    },\n    makeSetterMethod: () => function $setter(valueOrUpdater) {\n      return $set(this, valueOrUpdater);\n    },\n    stateConfig\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrdXRpbHNAMC4yOC4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC91dGlscy9MZXhpY2FsVXRpbHMuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnaEI7QUFDdGE7QUFDN0M7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0JBQWtCLDJFQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNEQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLHVEQUFjO0FBQzlDLG9CQUFvQix1REFBYztBQUNsQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFhO0FBQ3JDLFdBQVcsMERBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrREFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQXNCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlCQUFpQjtBQUM5RCxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtEQUFTO0FBQ2hDLHlDQUF5QyxrREFBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRTg2QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxoYXNoaVxcRGVza3RvcFxcZnVzaW9uaXF4LXByb2plY3RzXFxmdXNpb25pcXhcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBsZXhpY2FsK3V0aWxzQDAuMjguMFxcbm9kZV9tb2R1bGVzXFxAbGV4aWNhbFxcdXRpbHNcXExleGljYWxVdGlscy5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgJGdldFNlbGVjdGlvbiwgJGlzUmFuZ2VTZWxlY3Rpb24sICRpc0VsZW1lbnROb2RlLCBnZXRET01UZXh0Tm9kZSwgJGdldFJvb3QsICRnZXRDaGlsZENhcmV0LCAkZ2V0U2libGluZ0NhcmV0LCAkZ2V0QWRqYWNlbnRDaGlsZENhcmV0LCAkZ2V0Q2hpbGRDYXJldE9yU2VsZiwgbWFrZVN0ZXB3aXNlSXRlcmF0b3IsICRpc0NoaWxkQ2FyZXQsICRjbG9uZVdpdGhQcm9wZXJ0aWVzLCAkc2V0U2VsZWN0aW9uLCAkZ2V0UHJldmlvdXNTZWxlY3Rpb24sICRjYXJldEZyb21Qb2ludCwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRub3JtYWxpemVDYXJldCwgJHNldFNlbGVjdGlvbkZyb21DYXJldFJhbmdlLCAkZ2V0Q29sbGFwc2VkQ2FyZXRSYW5nZSwgJGdldENhcmV0SW5EaXJlY3Rpb24sICRzcGxpdEF0UG9pbnRDYXJldE5leHQsICRpc1RleHRQb2ludENhcmV0LCAkaXNTaWJsaW5nQ2FyZXQsICRyZXdpbmRTaWJsaW5nQ2FyZXQsICRnZXRTdGF0ZSwgJHNldFN0YXRlIH0gZnJvbSAnbGV4aWNhbCc7XG5leHBvcnQgeyAkc3BsaXROb2RlLCBpc0Jsb2NrRG9tTm9kZSwgaXNIVE1MQW5jaG9yRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNJbmxpbmVEb21Ob2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5pbXBvcnQgeyBjcmVhdGVSZWN0c0Zyb21ET01SYW5nZSB9IGZyb20gJ0BsZXhpY2FsL3NlbGVjdGlvbic7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgYGludmFyaWFudGAgY2FsbHMuXG5cbmZ1bmN0aW9uIGZvcm1hdERldkVycm9yTWVzc2FnZShtZXNzYWdlKSB7XG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSQxID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSQxICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogbnVsbDtcbmNvbnN0IElTX0FQUExFJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfRklSRUZPWCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCQxID0gQ0FOX1VTRV9ET00kMSAmJiAnSW5wdXRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgPyAnZ2V0VGFyZ2V0UmFuZ2VzJyBpbiBuZXcgd2luZG93LklucHV0RXZlbnQoJ2lucHV0JykgOiBmYWxzZTtcbmNvbnN0IElTX1NBRkFSSSQxID0gQ0FOX1VTRV9ET00kMSAmJiAvVmVyc2lvblxcL1tcXGQuXSsuKlNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0lPUyQxID0gQ0FOX1VTRV9ET00kMSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuY29uc3QgSVNfQU5EUk9JRCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvQW5kcm9pZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLy8gS2VlcCB0aGVzZSBpbiBjYXNlIHdlIG5lZWQgdG8gdXNlIHRoZW0gaW4gdGhlIGZ1dHVyZS5cbi8vIGV4cG9ydCBjb25zdCBJU19XSU5ET1dTOiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfQ0hST01FJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9eKD89LipDaHJvbWUpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gZXhwb3J0IGNvbnN0IGNhblVzZVRleHRJbnB1dEV2ZW50OiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbmNvbnN0IElTX0FORFJPSURfQ0hST01FJDEgPSBDQU5fVVNFX0RPTSQxICYmIElTX0FORFJPSUQkMSAmJiBJU19DSFJPTUUkMTtcbmNvbnN0IElTX0FQUExFX1dFQktJVCQxID0gQ0FOX1VTRV9ET00kMSAmJiAvQXBwbGVXZWJLaXRcXC9bXFxkLl0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFJU19DSFJPTUUkMTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc05hbWVzKC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgcnZhbCA9IFtdO1xuICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG4gICAgaWYgKGNsYXNzTmFtZSAmJiB0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZm9yIChjb25zdCBbc10gb2YgY2xhc3NOYW1lLm1hdGNoQWxsKC9cXFMrL2cpKSB7XG4gICAgICAgIHJ2YWwucHVzaChzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgYWxsIGZ1bmN0aW9ucyBwYXNzZWQgd2hlbiBjYWxsZWQuIEl0IGlzIGdlbmVyYWxseSB1c2VkXG4gKiB0byByZWdpc3RlciBtdWx0aXBsZSBsZXhpY2FsIGxpc3RlbmVycyBhbmQgdGhlbiB0ZWFyIHRoZW0gZG93biB3aXRoIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGwsIHN1Y2hcbiAqIGFzIFJlYWN0J3MgdXNlRWZmZWN0IGhvb2suXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKFxuICogICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoLi4ucmVnaXN0ZXJDb21tYW5kMSBsb2dpYyksXG4gKiAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZCguLi5yZWdpc3RlckNvbW1hbmQyIGxvZ2ljKSxcbiAqICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKC4uLnJlZ2lzdGVyQ29tbWFuZDMgbG9naWMpXG4gKiAgIClcbiAqIH0sIFtlZGl0b3JdKVxuICogYGBgXG4gKiBJbiB0aGlzIGNhc2UsIHVzZUVmZmVjdCBpcyByZXR1cm5pbmcgdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IG1lcmdlUmVnaXN0ZXIgYXMgYSBjbGVhbnVwXG4gKiBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBlaXRoZXIgdGhlIHVzZUVmZmVjdCBydW5zIGFnYWluIChkdWUgdG8gb25lIG9mIGl0cyBkZXBlbmRlbmNpZXNcbiAqIHVwZGF0aW5nKSBvciB0aGUgY29tcG9uZW50IGl0IHJlc2lkZXMgaW4gdW5tb3VudHMuXG4gKiBOb3RlIHRoZSBmdW5jdGlvbnMgZG9uJ3QgbmVjY2VzYXJpbHkgbmVlZCB0byBiZSBpbiBhbiBhcnJheSBhcyBhbGwgYXJndW1lbnRzXG4gKiBhcmUgY29uc2lkZXJlZCB0byBiZSB0aGUgZnVuYyBhcmd1bWVudCBhbmQgc3ByZWFkIGZyb20gdGhlcmUuXG4gKiBUaGUgb3JkZXIgb2YgY2xlYW51cCBpcyB0aGUgcmV2ZXJzZSBvZiB0aGUgYXJndW1lbnQgb3JkZXIuIEdlbmVyYWxseSBpdCBpc1xuICogZXhwZWN0ZWQgdGhhdCB0aGUgZmlyc3QgXCJhY3F1aXJlXCIgd2lsbCBiZSBcInJlbGVhc2VkXCIgbGFzdCAoTElGTyBvcmRlciksXG4gKiBiZWNhdXNlIGEgbGF0ZXIgc3RlcCBtYXkgaGF2ZSBzb21lIGRlcGVuZGVuY3kgb24gYW4gZWFybGllciBvbmUuXG4gKiBAcGFyYW0gZnVuYyAtIEFuIGFycmF5IG9mIGNsZWFudXAgZnVuY3Rpb25zIG1lYW50IHRvIGJlIGV4ZWN1dGVkIGJ5IHRoZSByZXR1cm5lZCBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHRoZSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBhbGwgdGhlIHBhc3NlZCBjbGVhbnVwIGZ1bmN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VSZWdpc3RlciguLi5mdW5jKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IGZ1bmMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGZ1bmNbaV0oKTtcbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgdGhlIHJlZmVyZW5jZXMgYW5kIG1ha2UgZnV0dXJlIGNhbGxzIGEgbm8tb3BcbiAgICBmdW5jLmxlbmd0aCA9IDA7XG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcHgodmFsdWUpIHtcbiAgcmV0dXJuIGAke3ZhbHVlfXB4YDtcbn1cblxuY29uc3QgbXV0YXRpb25PYnNlcnZlckNvbmZpZyA9IHtcbiAgYXR0cmlidXRlczogdHJ1ZSxcbiAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgY2hpbGRMaXN0OiB0cnVlLFxuICBzdWJ0cmVlOiB0cnVlXG59O1xuZnVuY3Rpb24gcHJlcGVuZERPTU5vZGUocGFyZW50LCBub2RlKSB7XG4gIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgcGFyZW50LmZpcnN0Q2hpbGQpO1xufVxuXG4vKipcbiAqIFBsYWNlIG9uZSBvciBtdWx0aXBsZSBuZXdseSBjcmVhdGVkIE5vZGVzIGF0IHRoZSBwYXNzZWQgUmFuZ2UncyBwb3NpdGlvbi5cbiAqIE11bHRpcGxlIG5vZGVzIHdpbGwgb25seSBiZSBjcmVhdGVkIHdoZW4gdGhlIFJhbmdlIHNwYW5zIG11bHRpcGxlIGxpbmVzIChha2FcbiAqIGNsaWVudCByZWN0cykuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gY29tZSBwYXJ0aWN1bGFybHkgdXNlZnVsIHRvIGhpZ2hsaWdodCBwYXJ0aWN1bGFyIHBhcnRzIG9mXG4gKiB0aGUgdGV4dCB3aXRob3V0IGludGVyZmVyaW5nIHdpdGggdGhlIEVkaXRvclN0YXRlLCB0aGF0IHdpbGwgb2Z0ZW4gcmVwbGljYXRlXG4gKiB0aGUgc3RhdGUgYWNyb3NzIGNvbGxhYiBhbmQgY2xpcGJvYXJkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWNjb3VudHMgZm9yIERPTSB1cGRhdGVzIHdoaWNoIGNhbiBtb2RpZnkgdGhlIHBhc3NlZCBSYW5nZS5cbiAqIEhlbmNlLCB0aGUgZnVuY3Rpb24gcmV0dXJuIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIG1sY1Bvc2l0aW9uTm9kZU9uUmFuZ2UoZWRpdG9yLCByYW5nZSwgb25SZXBvc2l0aW9uKSB7XG4gIGxldCByb290RE9NTm9kZSA9IG51bGw7XG4gIGxldCBwYXJlbnRET01Ob2RlID0gbnVsbDtcbiAgbGV0IG9ic2VydmVyID0gbnVsbDtcbiAgbGV0IGxhc3ROb2RlcyA9IFtdO1xuICBjb25zdCB3cmFwcGVyTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB3cmFwcGVyTm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgIGlmICghKHJvb3RET01Ob2RlICE9PSBudWxsKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBVbmV4cGVjdGVkIG51bGwgcm9vdERPTU5vZGVgKTtcbiAgICB9XG4gICAgaWYgKCEocGFyZW50RE9NTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgVW5leHBlY3RlZCBudWxsIHBhcmVudERPTU5vZGVgKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbGVmdDogcGFyZW50TGVmdCxcbiAgICAgIHRvcDogcGFyZW50VG9wXG4gICAgfSA9IHBhcmVudERPTU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgcmVjdHMgPSBjcmVhdGVSZWN0c0Zyb21ET01SYW5nZShlZGl0b3IsIHJhbmdlKTtcbiAgICBpZiAoIXdyYXBwZXJOb2RlLmlzQ29ubmVjdGVkKSB7XG4gICAgICBwcmVwZW5kRE9NTm9kZShwYXJlbnRET01Ob2RlLCB3cmFwcGVyTm9kZSk7XG4gICAgfVxuICAgIGxldCBoYXNSZXBvc2l0aW9uZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAvLyBUcnkgdG8gcmV1c2UgdGhlIHByZXZpb3VzbHkgY3JlYXRlZCBOb2RlIHdoZW4gcG9zc2libGUsIG5vIG5lZWQgdG9cbiAgICAgIC8vIHJlbW92ZS9jcmVhdGUgb24gdGhlIG1vc3QgY29tbW9uIGNhc2UgcmVwb3NpdGlvbiBjYXNlXG4gICAgICBjb25zdCByZWN0Tm9kZSA9IGxhc3ROb2Rlc1tpXSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnN0IHJlY3ROb2RlU3R5bGUgPSByZWN0Tm9kZS5zdHlsZTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIHJlY3ROb2RlU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVmdCA9IHB4KHJlY3QubGVmdCAtIHBhcmVudExlZnQpO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUubGVmdCAhPT0gbGVmdCkge1xuICAgICAgICByZWN0Tm9kZVN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9wID0gcHgocmVjdC50b3AgLSBwYXJlbnRUb3ApO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUudG9wICE9PSB0b3ApIHtcbiAgICAgICAgcmVjdE5vZGUuc3R5bGUudG9wID0gdG9wO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2lkdGggPSBweChyZWN0LndpZHRoKTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICByZWN0Tm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaGVpZ2h0ID0gcHgocmVjdC5oZWlnaHQpO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgcmVjdE5vZGUuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlY3ROb2RlLnBhcmVudE5vZGUgIT09IHdyYXBwZXJOb2RlKSB7XG4gICAgICAgIHdyYXBwZXJOb2RlLmFwcGVuZChyZWN0Tm9kZSk7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBsYXN0Tm9kZXNbaV0gPSByZWN0Tm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKGxhc3ROb2Rlcy5sZW5ndGggPiByZWN0cy5sZW5ndGgpIHtcbiAgICAgIGxhc3ROb2Rlcy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKGhhc1JlcG9zaXRpb25lZCkge1xuICAgICAgb25SZXBvc2l0aW9uKGxhc3ROb2Rlcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgcGFyZW50RE9NTm9kZSA9IG51bGw7XG4gICAgcm9vdERPTU5vZGUgPSBudWxsO1xuICAgIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICBvYnNlcnZlciA9IG51bGw7XG4gICAgd3JhcHBlck5vZGUucmVtb3ZlKCk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIGxhc3ROb2Rlcykge1xuICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICB9XG4gICAgbGFzdE5vZGVzID0gW107XG4gIH1cbiAgZnVuY3Rpb24gcmVzdGFydCgpIHtcbiAgICBjb25zdCBjdXJyZW50Um9vdERPTU5vZGUgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICBpZiAoY3VycmVudFJvb3RET01Ob2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc3RvcCgpO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50UGFyZW50RE9NTm9kZSA9IGN1cnJlbnRSb290RE9NTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIGlmICghaXNIVE1MRWxlbWVudChjdXJyZW50UGFyZW50RE9NTm9kZSkpIHtcbiAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgfVxuICAgIHN0b3AoKTtcbiAgICByb290RE9NTm9kZSA9IGN1cnJlbnRSb290RE9NTm9kZTtcbiAgICBwYXJlbnRET01Ob2RlID0gY3VycmVudFBhcmVudERPTU5vZGU7XG4gICAgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgY29uc3QgbmV4dFJvb3RET01Ob2RlID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gICAgICBjb25zdCBuZXh0UGFyZW50RE9NTm9kZSA9IG5leHRSb290RE9NTm9kZSAmJiBuZXh0Um9vdERPTU5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgIGlmIChuZXh0Um9vdERPTU5vZGUgIT09IHJvb3RET01Ob2RlIHx8IG5leHRQYXJlbnRET01Ob2RlICE9PSBwYXJlbnRET01Ob2RlKSB7XG4gICAgICAgIHJldHVybiByZXN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICBpZiAoIXdyYXBwZXJOb2RlLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgICAgICAvLyBUT0RPIHRocm90dGxlXG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGN1cnJlbnRQYXJlbnRET01Ob2RlLCBtdXRhdGlvbk9ic2VydmVyQ29uZmlnKTtcbiAgICBwb3NpdGlvbigpO1xuICB9XG4gIGNvbnN0IHJlbW92ZVJvb3RMaXN0ZW5lciA9IGVkaXRvci5yZWdpc3RlclJvb3RMaXN0ZW5lcihyZXN0YXJ0KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZW1vdmVSb290TGlzdGVuZXIoKTtcbiAgICBzdG9wKCk7XG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcmFuZ2VUYXJnZXRGcm9tUG9pbnQocG9pbnQsIG5vZGUsIGRvbSkge1xuICBpZiAocG9pbnQudHlwZSA9PT0gJ3RleHQnIHx8ICEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IHRleHRET00gPSBnZXRET01UZXh0Tm9kZShkb20pIHx8IGRvbTtcbiAgICByZXR1cm4gW3RleHRET00sIHBvaW50Lm9mZnNldF07XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2xvdCA9IG5vZGUuZ2V0RE9NU2xvdChkb20pO1xuICAgIHJldHVybiBbc2xvdC5lbGVtZW50LCBzbG90LmdldEZpcnN0Q2hpbGRPZmZzZXQoKSArIHBvaW50Lm9mZnNldF07XG4gIH1cbn1cbmZ1bmN0aW9uIHJhbmdlRnJvbVBvaW50cyhlZGl0b3IsIGFuY2hvciwgYW5jaG9yTm9kZSwgYW5jaG9yRE9NLCBmb2N1cywgZm9jdXNOb2RlLCBmb2N1c0RPTSkge1xuICBjb25zdCBlZGl0b3JEb2N1bWVudCA9IGVkaXRvci5fd2luZG93ID8gZWRpdG9yLl93aW5kb3cuZG9jdW1lbnQgOiBkb2N1bWVudDtcbiAgY29uc3QgcmFuZ2UgPSBlZGl0b3JEb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBpZiAoZm9jdXNOb2RlLmlzQmVmb3JlKGFuY2hvck5vZGUpKSB7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoLi4ucmFuZ2VUYXJnZXRGcm9tUG9pbnQoZm9jdXMsIGZvY3VzTm9kZSwgZm9jdXNET00pKTtcbiAgICByYW5nZS5zZXRFbmQoLi4ucmFuZ2VUYXJnZXRGcm9tUG9pbnQoYW5jaG9yLCBhbmNob3JOb2RlLCBhbmNob3JET00pKTtcbiAgfSBlbHNlIHtcbiAgICByYW5nZS5zZXRTdGFydCguLi5yYW5nZVRhcmdldEZyb21Qb2ludChhbmNob3IsIGFuY2hvck5vZGUsIGFuY2hvckRPTSkpO1xuICAgIHJhbmdlLnNldEVuZCguLi5yYW5nZVRhcmdldEZyb21Qb2ludChmb2N1cywgZm9jdXNOb2RlLCBmb2N1c0RPTSkpO1xuICB9XG4gIHJldHVybiByYW5nZTtcbn1cbi8qKlxuICogUGxhY2Ugb25lIG9yIG11bHRpcGxlIG5ld2x5IGNyZWF0ZWQgTm9kZXMgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBNdWx0aXBsZVxuICogbm9kZXMgd2lsbCBvbmx5IGJlIGNyZWF0ZWQgd2hlbiB0aGUgc2VsZWN0aW9uIHNwYW5zIG11bHRpcGxlIGxpbmVzIChha2FcbiAqIGNsaWVudCByZWN0cykuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gY29tZSB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBzaG93IHRoZSBzZWxlY3Rpb24gYnV0IHRoZVxuICogZWRpdG9yIGhhcyBiZWVuIGZvY3VzZWQgYXdheS5cbiAqL1xuZnVuY3Rpb24gbWFya1NlbGVjdGlvbihlZGl0b3IsIG9uUmVwb3NpdGlvbikge1xuICBsZXQgcHJldmlvdXNBbmNob3JOb2RlID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzQW5jaG9yTm9kZURPTSA9IG51bGw7XG4gIGxldCBwcmV2aW91c0FuY2hvck9mZnNldCA9IG51bGw7XG4gIGxldCBwcmV2aW91c0ZvY3VzTm9kZSA9IG51bGw7XG4gIGxldCBwcmV2aW91c0ZvY3VzTm9kZURPTSA9IG51bGw7XG4gIGxldCBwcmV2aW91c0ZvY3VzT2Zmc2V0ID0gbnVsbDtcbiAgbGV0IHJlbW92ZVJhbmdlTGlzdGVuZXIgPSAoKSA9PiB7fTtcbiAgZnVuY3Rpb24gY29tcHV0ZShlZGl0b3JTdGF0ZSkge1xuICAgIGVkaXRvclN0YXRlLnJlYWQoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgcHJldmlvdXNBbmNob3JOb2RlID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXNBbmNob3JPZmZzZXQgPSBudWxsO1xuICAgICAgICBwcmV2aW91c0ZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzRm9jdXNPZmZzZXQgPSBudWxsO1xuICAgICAgICByZW1vdmVSYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIgPSAoKSA9PiB7fTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZvY3VzXG4gICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck5vZGVLZXkgPSBjdXJyZW50QW5jaG9yTm9kZS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRGb2N1c05vZGVLZXkgPSBjdXJyZW50Rm9jdXNOb2RlLmdldEtleSgpO1xuICAgICAgY29uc3QgY3VycmVudEZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICAgICAgY29uc3QgY3VycmVudEFuY2hvck5vZGVET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGN1cnJlbnRBbmNob3JOb2RlS2V5KTtcbiAgICAgIGNvbnN0IGN1cnJlbnRGb2N1c05vZGVET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGN1cnJlbnRGb2N1c05vZGVLZXkpO1xuICAgICAgY29uc3QgZGlmZmVyZW50QW5jaG9yRE9NID0gcHJldmlvdXNBbmNob3JOb2RlID09PSBudWxsIHx8IGN1cnJlbnRBbmNob3JOb2RlRE9NICE9PSBwcmV2aW91c0FuY2hvck5vZGVET00gfHwgY3VycmVudEFuY2hvck9mZnNldCAhPT0gcHJldmlvdXNBbmNob3JPZmZzZXQgfHwgY3VycmVudEFuY2hvck5vZGVLZXkgIT09IHByZXZpb3VzQW5jaG9yTm9kZS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IGRpZmZlcmVudEZvY3VzRE9NID0gcHJldmlvdXNGb2N1c05vZGUgPT09IG51bGwgfHwgY3VycmVudEZvY3VzTm9kZURPTSAhPT0gcHJldmlvdXNGb2N1c05vZGVET00gfHwgY3VycmVudEZvY3VzT2Zmc2V0ICE9PSBwcmV2aW91c0ZvY3VzT2Zmc2V0IHx8IGN1cnJlbnRGb2N1c05vZGVLZXkgIT09IHByZXZpb3VzRm9jdXNOb2RlLmdldEtleSgpO1xuICAgICAgaWYgKChkaWZmZXJlbnRBbmNob3JET00gfHwgZGlmZmVyZW50Rm9jdXNET00pICYmIGN1cnJlbnRBbmNob3JOb2RlRE9NICE9PSBudWxsICYmIGN1cnJlbnRGb2N1c05vZGVET00gIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSByYW5nZUZyb21Qb2ludHMoZWRpdG9yLCBhbmNob3IsIGN1cnJlbnRBbmNob3JOb2RlLCBjdXJyZW50QW5jaG9yTm9kZURPTSwgZm9jdXMsIGN1cnJlbnRGb2N1c05vZGUsIGN1cnJlbnRGb2N1c05vZGVET00pO1xuICAgICAgICByZW1vdmVSYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIgPSBtbGNQb3NpdGlvbk5vZGVPblJhbmdlKGVkaXRvciwgcmFuZ2UsIGRvbU5vZGVzID0+IHtcbiAgICAgICAgICBpZiAob25SZXBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZG9tTm9kZSBvZiBkb21Ob2Rlcykge1xuICAgICAgICAgICAgICBjb25zdCBkb21Ob2RlU3R5bGUgPSBkb21Ob2RlLnN0eWxlO1xuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLmJhY2tncm91bmQgIT09ICdIaWdobGlnaHQnKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLmJhY2tncm91bmQgPSAnSGlnaGxpZ2h0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLmNvbG9yICE9PSAnSGlnaGxpZ2h0VGV4dCcpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUuY29sb3IgPSAnSGlnaGxpZ2h0VGV4dCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5tYXJnaW5Ub3AgIT09IHB4KC0xLjUpKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLm1hcmdpblRvcCA9IHB4KC0xLjUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucGFkZGluZ1RvcCAhPT0gcHgoNCkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUucGFkZGluZ1RvcCA9IHB4KDQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucGFkZGluZ0JvdHRvbSAhPT0gcHgoMCkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUucGFkZGluZ0JvdHRvbSA9IHB4KDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uUmVwb3NpdGlvbihkb21Ob2Rlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzQW5jaG9yTm9kZSA9IGN1cnJlbnRBbmNob3JOb2RlO1xuICAgICAgcHJldmlvdXNBbmNob3JOb2RlRE9NID0gY3VycmVudEFuY2hvck5vZGVET007XG4gICAgICBwcmV2aW91c0FuY2hvck9mZnNldCA9IGN1cnJlbnRBbmNob3JPZmZzZXQ7XG4gICAgICBwcmV2aW91c0ZvY3VzTm9kZSA9IGN1cnJlbnRGb2N1c05vZGU7XG4gICAgICBwcmV2aW91c0ZvY3VzTm9kZURPTSA9IGN1cnJlbnRGb2N1c05vZGVET007XG4gICAgICBwcmV2aW91c0ZvY3VzT2Zmc2V0ID0gY3VycmVudEZvY3VzT2Zmc2V0O1xuICAgIH0pO1xuICB9XG4gIGNvbXB1dGUoZWRpdG9yLmdldEVkaXRvclN0YXRlKCkpO1xuICByZXR1cm4gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoe1xuICAgIGVkaXRvclN0YXRlXG4gIH0pID0+IGNvbXB1dGUoZWRpdG9yU3RhdGUpKSwgKCkgPT4ge1xuICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0aW9uQWx3YXlzT25EaXNwbGF5KGVkaXRvcikge1xuICBsZXQgcmVtb3ZlU2VsZWN0aW9uTWFyayA9IG51bGw7XG4gIGNvbnN0IG9uU2VsZWN0aW9uQ2hhbmdlID0gKCkgPT4ge1xuICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IGRvbUFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24gJiYgZG9tU2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gICAgY29uc3QgZWRpdG9yUm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICBjb25zdCBpc1NlbGVjdGlvbkluc2lkZUVkaXRvciA9IGRvbUFuY2hvck5vZGUgIT09IG51bGwgJiYgZWRpdG9yUm9vdEVsZW1lbnQgIT09IG51bGwgJiYgZWRpdG9yUm9vdEVsZW1lbnQuY29udGFpbnMoZG9tQW5jaG9yTm9kZSk7XG4gICAgaWYgKGlzU2VsZWN0aW9uSW5zaWRlRWRpdG9yKSB7XG4gICAgICBpZiAocmVtb3ZlU2VsZWN0aW9uTWFyayAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmVTZWxlY3Rpb25NYXJrKCk7XG4gICAgICAgIHJlbW92ZVNlbGVjdGlvbk1hcmsgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVtb3ZlU2VsZWN0aW9uTWFyayA9PT0gbnVsbCkge1xuICAgICAgICByZW1vdmVTZWxlY3Rpb25NYXJrID0gbWFya1NlbGVjdGlvbihlZGl0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgb25TZWxlY3Rpb25DaGFuZ2UpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChyZW1vdmVTZWxlY3Rpb25NYXJrICE9PSBudWxsKSB7XG4gICAgICByZW1vdmVTZWxlY3Rpb25NYXJrKCk7XG4gICAgfVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIG9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgfTtcbn1cblxuLy8gSG90Zml4IHRvIGV4cG9ydCB0aGVzZSB3aXRoIGlubGluZWQgdHlwZXMgIzU5MThcbmNvbnN0IENBTl9VU0VfQkVGT1JFX0lOUFVUID0gQ0FOX1VTRV9CRUZPUkVfSU5QVVQkMTtcbmNvbnN0IENBTl9VU0VfRE9NID0gQ0FOX1VTRV9ET00kMTtcbmNvbnN0IElTX0FORFJPSUQgPSBJU19BTkRST0lEJDE7XG5jb25zdCBJU19BTkRST0lEX0NIUk9NRSA9IElTX0FORFJPSURfQ0hST01FJDE7XG5jb25zdCBJU19BUFBMRSA9IElTX0FQUExFJDE7XG5jb25zdCBJU19BUFBMRV9XRUJLSVQgPSBJU19BUFBMRV9XRUJLSVQkMTtcbmNvbnN0IElTX0NIUk9NRSA9IElTX0NIUk9NRSQxO1xuY29uc3QgSVNfRklSRUZPWCA9IElTX0ZJUkVGT1gkMTtcbmNvbnN0IElTX0lPUyA9IElTX0lPUyQxO1xuY29uc3QgSVNfU0FGQVJJID0gSVNfU0FGQVJJJDE7XG5cbi8qKlxuICogVGFrZXMgYW4gSFRNTCBlbGVtZW50IGFuZCBhZGRzIHRoZSBjbGFzc05hbWVzIHBhc3NlZCB3aXRoaW4gYW4gYXJyYXksXG4gKiBpZ25vcmluZyBhbnkgbm9uLXN0cmluZyB0eXBlcy4gQSBzcGFjZSBjYW4gYmUgdXNlZCB0byBhZGQgbXVsdGlwbGUgY2xhc3Nlc1xuICogZWcuIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgWydlbGVtZW50LWlubmVyIGFjdGl2ZScsIHRydWUsIG51bGxdKVxuICogd2lsbCBhZGQgYm90aCAnZWxlbWVudC1pbm5lcicgYW5kICdhY3RpdmUnIGFzIGNsYXNzZXMgdG8gdGhhdCBlbGVtZW50LlxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgY2xhc3NlcyBhcmUgYWRkZWRcbiAqIEBwYXJhbSBjbGFzc05hbWVzIC0gQW4gYXJyYXkgZGVmaW5pbmcgdGhlIGNsYXNzIG5hbWVzIHRvIGFkZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgY2xhc3Nlc1RvQWRkID0gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKTtcbiAgaWYgKGNsYXNzZXNUb0FkZC5sZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXNUb0FkZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBhbiBIVE1MIGVsZW1lbnQgYW5kIHJlbW92ZXMgdGhlIGNsYXNzTmFtZXMgcGFzc2VkIHdpdGhpbiBhbiBhcnJheSxcbiAqIGlnbm9yaW5nIGFueSBub24tc3RyaW5nIHR5cGVzLiBBIHNwYWNlIGNhbiBiZSB1c2VkIHRvIHJlbW92ZSBtdWx0aXBsZSBjbGFzc2VzXG4gKiBlZy4gcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGVsZW1lbnQsIFsnYWN0aXZlIHNtYWxsJywgdHJ1ZSwgbnVsbF0pXG4gKiB3aWxsIHJlbW92ZSBib3RoIHRoZSAnYWN0aXZlJyBhbmQgJ3NtYWxsJyBjbGFzc2VzIGZyb20gdGhhdCBlbGVtZW50LlxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgY2xhc3NlcyBhcmUgcmVtb3ZlZFxuICogQHBhcmFtIGNsYXNzTmFtZXMgLSBBbiBhcnJheSBkZWZpbmluZyB0aGUgY2xhc3MgbmFtZXMgdG8gcmVtb3ZlIGZyb20gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGVsZW1lbnQsIC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgY2xhc3Nlc1RvUmVtb3ZlID0gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKTtcbiAgaWYgKGNsYXNzZXNUb1JlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzZXNUb1JlbW92ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZpbGUgdHlwZSBtYXRjaGVzIHRoZSB0eXBlcyBwYXNzZWQgd2l0aGluIHRoZSBhY2NlcHRhYmxlTWltZVR5cGVzIGFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBUaGUgdHlwZXMgcGFzc2VkIG11c3QgYmUgc3RyaW5ncyBhbmQgYXJlIENBU0UtU0VOU0lUSVZFLlxuICogZWcuIGlmIGZpbGUgaXMgb2YgdHlwZSAndGV4dCcgYW5kIGFjY2VwdGFibGVNaW1lVHlwZXMgPSBbJ1RFWFQnLCAnSU1BR0UnXSB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gZmFsc2UuXG4gKiBAcGFyYW0gZmlsZSAtIFRoZSBmaWxlIHlvdSB3YW50IHRvIHR5cGUgY2hlY2suXG4gKiBAcGFyYW0gYWNjZXB0YWJsZU1pbWVUeXBlcyAtIEFuIGFycmF5IG9mIHN0cmluZ3Mgb2YgdHlwZXMgd2hpY2ggdGhlIGZpbGUgaXMgY2hlY2tlZCBhZ2FpbnN0LlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZmlsZSBpcyBhbiBhY2NlcHRhYmxlIG1pbWUgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc01pbWVUeXBlKGZpbGUsIGFjY2VwdGFibGVNaW1lVHlwZXMpIHtcbiAgZm9yIChjb25zdCBhY2NlcHRhYmxlVHlwZSBvZiBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gICAgaWYgKGZpbGUudHlwZS5zdGFydHNXaXRoKGFjY2VwdGFibGVUeXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBMZXhpY2FsIEZpbGUgUmVhZGVyIHdpdGg6XG4gKiAgMS4gTUlNRSB0eXBlIHN1cHBvcnRcbiAqICAyLiBiYXRjaGVkIHJlc3VsdHMgKEhpc3RvcnlQbHVnaW4gY29tcGF0aWJpbGl0eSlcbiAqICAzLiBPcmRlciBhd2FyZSAocmVzcGVjdHMgdGhlIG9yZGVyIHdoZW4gbXVsdGlwbGUgRmlsZXMgYXJlIHBhc3NlZClcbiAqXG4gKiBjb25zdCBmaWxlc1Jlc3VsdCA9IGF3YWl0IG1lZGlhRmlsZVJlYWRlcihmaWxlcywgWydpbWFnZS8nXSk7XG4gKiBmaWxlc1Jlc3VsdC5mb3JFYWNoKGZpbGUgPT4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZCgnSU5TRVJUX0lNQUdFJywgXFxcXHtcbiAqICAgc3JjOiBmaWxlLnJlc3VsdCxcbiAqIFxcXFx9KSk7XG4gKi9cbmZ1bmN0aW9uIG1lZGlhRmlsZVJlYWRlcihmaWxlcywgYWNjZXB0YWJsZU1pbWVUeXBlcykge1xuICBjb25zdCBmaWxlc0l0ZXJhdG9yID0gZmlsZXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHByb2Nlc3NlZCA9IFtdO1xuICAgIGNvbnN0IGhhbmRsZU5leHRGaWxlID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkb25lLFxuICAgICAgICB2YWx1ZTogZmlsZVxuICAgICAgfSA9IGZpbGVzSXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUocHJvY2Vzc2VkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICBmaWxlUmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbGVSZWFkZXIucmVzdWx0O1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwcm9jZXNzZWQucHVzaCh7XG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlTmV4dEZpbGUoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzTWltZVR5cGUoZmlsZSwgYWNjZXB0YWJsZU1pbWVUeXBlcykpIHtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlTmV4dEZpbGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGhhbmRsZU5leHRGaWxlKCk7XG4gIH0pO1xufVxuLyoqXG4gKiBcIkRlcHRoLUZpcnN0IFNlYXJjaFwiIHN0YXJ0cyBhdCB0aGUgcm9vdC90b3Agbm9kZSBvZiBhIHRyZWUgYW5kIGdvZXMgYXMgZmFyIGFzIGl0IGNhbiBkb3duIGEgYnJhbmNoIGVuZFxuICogYmVmb3JlIGJhY2t0cmFja2luZyBhbmQgZmluZGluZyBhIG5ldyBwYXRoLiBDb25zaWRlciBzb2x2aW5nIGEgbWF6ZSBieSBodWdnaW5nIGVpdGhlciB3YWxsLCBtb3ZpbmcgZG93biBhXG4gKiBicmFuY2ggdW50aWwgeW91IGhpdCBhIGRlYWQtZW5kIChsZWFmKSBhbmQgYmFja3RyYWNraW5nIHRvIGZpbmQgdGhlIG5lYXJlc3QgYnJhbmNoaW5nIHBhdGggYW5kIHJlcGVhdC5cbiAqIEl0IHdpbGwgdGhlbiByZXR1cm4gYWxsIHRoZSBub2RlcyBmb3VuZCBpbiB0aGUgc2VhcmNoIGluIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIG5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBzdGFydCBhdCB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIGVuZE5vZGUgLSBUaGUgbm9kZSB0byBlbmQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBmaW5kIGFsbCBkZXNjZW5kYW50cyBvZiB0aGUgc3RhcnRpbmdOb2RlLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygb2JqZWN0cyBvZiBhbGwgdGhlIG5vZGVzIGZvdW5kIGJ5IHRoZSBzZWFyY2gsIGluY2x1ZGluZyB0aGVpciBkZXB0aCBpbnRvIHRoZSB0cmVlLlxuICogXFxcXHtkZXB0aDogbnVtYmVyLCBub2RlOiBMZXhpY2FsTm9kZVxcXFx9IEl0IHdpbGwgYWx3YXlzIHJldHVybiBhdCBsZWFzdCAxIG5vZGUgKHRoZSBzdGFydCBub2RlKS5cbiAqL1xuZnVuY3Rpb24gJGRmcyhzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oJGRmc0l0ZXJhdG9yKHN0YXJ0Tm9kZSwgZW5kTm9kZSkpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYWRqYWNlbnQgY2FyZXQgaW4gdGhlIHNhbWUgZGlyZWN0aW9uXG4gKlxuICogQHBhcmFtIGNhcmV0IEEgY2FyZXQgb3IgbnVsbFxuICogQHJldHVybnMgYGNhcmV0LmdldEFkamFjZW50Q2FyZXQoKWAgb3IgYG51bGxgXG4gKi9cbmZ1bmN0aW9uICRnZXRBZGphY2VudENhcmV0KGNhcmV0KSB7XG4gIHJldHVybiBjYXJldCA/IGNhcmV0LmdldEFkamFjZW50Q2FyZXQoKSA6IG51bGw7XG59XG5cbi8qKlxuICogJGRmcyBpdGVyYXRvciAocmlnaHQgdG8gbGVmdCkuIFRyZWUgdHJhdmVyc2FsIGlzIGRvbmUgb24gdGhlIGZseSBhcyBuZXcgdmFsdWVzIGFyZSByZXF1ZXN0ZWQgd2l0aCBPKDEpIG1lbW9yeS5cbiAqIEBwYXJhbSBzdGFydE5vZGUgLSBUaGUgbm9kZSB0byBzdGFydCB0aGUgc2VhcmNoLCBpZiBvbWl0dGVkLCBpdCB3aWxsIHN0YXJ0IGF0IHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0gZW5kTm9kZSAtIFRoZSBub2RlIHRvIGVuZCB0aGUgc2VhcmNoLCBpZiBvbWl0dGVkLCBpdCB3aWxsIGZpbmQgYWxsIGRlc2NlbmRhbnRzIG9mIHRoZSBzdGFydGluZ05vZGUuXG4gKiBAcmV0dXJucyBBbiBpdGVyYXRvciwgZWFjaCB5aWVsZGVkIHZhbHVlIGlzIGEgREZTTm9kZS4gSXQgd2lsbCBhbHdheXMgcmV0dXJuIGF0IGxlYXN0IDEgbm9kZSAodGhlIHN0YXJ0IG5vZGUpLlxuICovXG5mdW5jdGlvbiAkcmV2ZXJzZURmcyhzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oJHJldmVyc2VEZnNJdGVyYXRvcihzdGFydE5vZGUsIGVuZE5vZGUpKTtcbn1cblxuLyoqXG4gKiAkZGZzIGl0ZXJhdG9yIChsZWZ0IHRvIHJpZ2h0KS4gVHJlZSB0cmF2ZXJzYWwgaXMgZG9uZSBvbiB0aGUgZmx5IGFzIG5ldyB2YWx1ZXMgYXJlIHJlcXVlc3RlZCB3aXRoIE8oMSkgbWVtb3J5LlxuICogQHBhcmFtIHN0YXJ0Tm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgc3RhcnQgYXQgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSBlbmROb2RlIC0gVGhlIG5vZGUgdG8gZW5kIHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgZmluZCBhbGwgZGVzY2VuZGFudHMgb2YgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yLCBlYWNoIHlpZWxkZWQgdmFsdWUgaXMgYSBERlNOb2RlLiBJdCB3aWxsIGFsd2F5cyByZXR1cm4gYXQgbGVhc3QgMSBub2RlICh0aGUgc3RhcnQgbm9kZSkuXG4gKi9cbmZ1bmN0aW9uICRkZnNJdGVyYXRvcihzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgcmV0dXJuICRkZnNDYXJldEl0ZXJhdG9yKCduZXh0Jywgc3RhcnROb2RlLCBlbmROb2RlKTtcbn1cbmZ1bmN0aW9uICRnZXRFbmRDYXJldChzdGFydE5vZGUsIGRpcmVjdGlvbikge1xuICBjb25zdCBydmFsID0gJGdldEFkamFjZW50U2libGluZ09yUGFyZW50U2libGluZ0NhcmV0KCRnZXRTaWJsaW5nQ2FyZXQoc3RhcnROb2RlLCBkaXJlY3Rpb24pKTtcbiAgcmV0dXJuIHJ2YWwgJiYgcnZhbFswXTtcbn1cbmZ1bmN0aW9uICRkZnNDYXJldEl0ZXJhdG9yKGRpcmVjdGlvbiwgc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICBjb25zdCBzdGFydCA9IHN0YXJ0Tm9kZSB8fCByb290O1xuICBjb25zdCBzdGFydENhcmV0ID0gJGlzRWxlbWVudE5vZGUoc3RhcnQpID8gJGdldENoaWxkQ2FyZXQoc3RhcnQsIGRpcmVjdGlvbikgOiAkZ2V0U2libGluZ0NhcmV0KHN0YXJ0LCBkaXJlY3Rpb24pO1xuICBjb25zdCBzdGFydERlcHRoID0gJGdldERlcHRoKHN0YXJ0KTtcbiAgY29uc3QgZW5kQ2FyZXQgPSBlbmROb2RlID8gJGdldEFkamFjZW50Q2hpbGRDYXJldCgkZ2V0Q2hpbGRDYXJldE9yU2VsZigkZ2V0U2libGluZ0NhcmV0KGVuZE5vZGUsIGRpcmVjdGlvbikpKSA6ICRnZXRFbmRDYXJldChzdGFydCwgZGlyZWN0aW9uKTtcbiAgbGV0IGRlcHRoID0gc3RhcnREZXB0aDtcbiAgcmV0dXJuIG1ha2VTdGVwd2lzZUl0ZXJhdG9yKHtcbiAgICBoYXNOZXh0OiBzdGF0ZSA9PiBzdGF0ZSAhPT0gbnVsbCxcbiAgICBpbml0aWFsOiBzdGFydENhcmV0LFxuICAgIG1hcDogc3RhdGUgPT4gKHtcbiAgICAgIGRlcHRoLFxuICAgICAgbm9kZTogc3RhdGUub3JpZ2luXG4gICAgfSksXG4gICAgc3RlcDogc3RhdGUgPT4ge1xuICAgICAgaWYgKHN0YXRlLmlzU2FtZU5vZGVDYXJldChlbmRDYXJldCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoJGlzQ2hpbGRDYXJldChzdGF0ZSkpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJ2YWwgPSAkZ2V0QWRqYWNlbnRTaWJsaW5nT3JQYXJlbnRTaWJsaW5nQ2FyZXQoc3RhdGUpO1xuICAgICAgaWYgKCFydmFsIHx8IHJ2YWxbMF0uaXNTYW1lTm9kZUNhcmV0KGVuZENhcmV0KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGRlcHRoICs9IHJ2YWxbMV07XG4gICAgICByZXR1cm4gcnZhbFswXTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIE5vZGUgc2libGluZyB3aGVuIHRoaXMgZXhpc3RzLCBvdGhlcndpc2UgdGhlIGNsb3Nlc3QgcGFyZW50IHNpYmxpbmcuIEZvciBleGFtcGxlXG4gKiBSIC0+IFAgLT4gVDEsIFQyXG4gKiAgIC0+IFAyXG4gKiByZXR1cm5zIFQyIGZvciBub2RlIFQxLCBQMiBmb3Igbm9kZSBUMiwgYW5kIG51bGwgZm9yIG5vZGUgUDIuXG4gKiBAcGFyYW0gbm9kZSBMZXhpY2FsTm9kZS5cbiAqIEByZXR1cm5zIEFuIGFycmF5ICh0dXBsZSkgY29udGFpbmluZyB0aGUgZm91bmQgTGV4aWNhbCBub2RlIGFuZCB0aGUgZGVwdGggZGlmZmVyZW5jZSwgb3IgbnVsbCwgaWYgdGhpcyBub2RlIGRvZXNuJ3QgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uICRnZXROZXh0U2libGluZ09yUGFyZW50U2libGluZyhub2RlKSB7XG4gIGNvbnN0IHJ2YWwgPSAkZ2V0QWRqYWNlbnRTaWJsaW5nT3JQYXJlbnRTaWJsaW5nQ2FyZXQoJGdldFNpYmxpbmdDYXJldChub2RlLCAnbmV4dCcpKTtcbiAgcmV0dXJuIHJ2YWwgJiYgW3J2YWxbMF0ub3JpZ2luLCBydmFsWzFdXTtcbn1cbmZ1bmN0aW9uICRnZXREZXB0aChub2RlKSB7XG4gIGxldCBkZXB0aCA9IC0xO1xuICBmb3IgKGxldCBpbm5lck5vZGUgPSBub2RlOyBpbm5lck5vZGUgIT09IG51bGw7IGlubmVyTm9kZSA9IGlubmVyTm9kZS5nZXRQYXJlbnQoKSkge1xuICAgIGRlcHRoKys7XG4gIH1cbiAgcmV0dXJuIGRlcHRoO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgcmlnaHQtdG8tbGVmdCBwcmVvcmRlciB0cmVlIHRyYXZlcnNhbC5cbiAqIEZyb20gdGhlIHN0YXJ0aW5nIG5vZGUgaXQgZ29lcyB0byB0aGUgcmlnaHRtb3N0IGNoaWxkLCB0aGFuIGJhY2t0cmFja3MgdG8gcGFyZW50IGFuZCBmaW5kcyBuZXcgcmlnaHRtb3N0IHBhdGguXG4gKiBJdCB3aWxsIHJldHVybiB0aGUgbmV4dCBub2RlIGluIHRyYXZlcnNhbCBzZXF1ZW5jZSBhZnRlciB0aGUgc3RhcnRpbmdOb2RlLlxuICogVGhlIHRyYXZlcnNhbCBpcyBzaW1pbGFyIHRvICRkZnMgZnVuY3Rpb25zIGFib3ZlLCBidXQgdGhlIG5vZGVzIGFyZSB2aXNpdGVkIHJpZ2h0LXRvLWxlZnQsIG5vdCBsZWZ0LXRvLXJpZ2h0LlxuICogQHBhcmFtIHN0YXJ0aW5nTm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2guXG4gKiBAcmV0dXJucyBUaGUgbmV4dCBub2RlIGluIHByZS1vcmRlciByaWdodCB0byBsZWZ0IHRyYXZlcnNhbCBzZXF1ZW5jZSBvciBgbnVsbGAsIGlmIHRoZSBub2RlIGRvZXMgbm90IGV4aXN0XG4gKi9cbmZ1bmN0aW9uICRnZXROZXh0UmlnaHRQcmVvcmRlck5vZGUoc3RhcnRpbmdOb2RlKSB7XG4gIGNvbnN0IHN0YXJ0Q2FyZXQgPSAkZ2V0Q2hpbGRDYXJldE9yU2VsZigkZ2V0U2libGluZ0NhcmV0KHN0YXJ0aW5nTm9kZSwgJ3ByZXZpb3VzJykpO1xuICBjb25zdCBuZXh0ID0gJGdldEFkamFjZW50U2libGluZ09yUGFyZW50U2libGluZ0NhcmV0KHN0YXJ0Q2FyZXQsICdyb290Jyk7XG4gIHJldHVybiBuZXh0ICYmIG5leHRbMF0ub3JpZ2luO1xufVxuXG4vKipcbiAqICRkZnMgaXRlcmF0b3IgKHJpZ2h0IHRvIGxlZnQpLiBUcmVlIHRyYXZlcnNhbCBpcyBkb25lIG9uIHRoZSBmbHkgYXMgbmV3IHZhbHVlcyBhcmUgcmVxdWVzdGVkIHdpdGggTygxKSBtZW1vcnkuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIG5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBzdGFydCBhdCB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIGVuZE5vZGUgLSBUaGUgbm9kZSB0byBlbmQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBmaW5kIGFsbCBkZXNjZW5kYW50cyBvZiB0aGUgc3RhcnRpbmdOb2RlLlxuICogQHJldHVybnMgQW4gaXRlcmF0b3IsIGVhY2ggeWllbGRlZCB2YWx1ZSBpcyBhIERGU05vZGUuIEl0IHdpbGwgYWx3YXlzIHJldHVybiBhdCBsZWFzdCAxIG5vZGUgKHRoZSBzdGFydCBub2RlKS5cbiAqL1xuZnVuY3Rpb24gJHJldmVyc2VEZnNJdGVyYXRvcihzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgcmV0dXJuICRkZnNDYXJldEl0ZXJhdG9yKCdwcmV2aW91cycsIHN0YXJ0Tm9kZSwgZW5kTm9kZSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBub2RlIGFuZCB0cmF2ZXJzZXMgdXAgaXRzIGFuY2VzdG9ycyAodG93YXJkIHRoZSByb290IG5vZGUpXG4gKiBpbiBvcmRlciB0byBmaW5kIGEgc3BlY2lmaWMgdHlwZSBvZiBub2RlLlxuICogQHBhcmFtIG5vZGUgLSB0aGUgbm9kZSB0byBiZWdpbiBzZWFyY2hpbmcuXG4gKiBAcGFyYW0ga2xhc3MgLSBhbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBvZiBub2RlIHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgdGhlIG5vZGUgb2YgdHlwZSBrbGFzcyB0aGF0IHdhcyBwYXNzZWQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3ROb2RlT2ZUeXBlKG5vZGUsIGtsYXNzKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2Yga2xhc3MpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IG5vZGUgb2YgdGhlIG5lYXJlc3QgYW5jZXN0b3IsIG90aGVyd2lzZSB0aHJvd3MgYW4gZXJyb3IuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIHN0YXJ0aW5nIG5vZGUgb2YgdGhlIHNlYXJjaFxuICogQHJldHVybnMgVGhlIGFuY2VzdG9yIG5vZGUgZm91bmRcbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3coc3RhcnROb2RlKSB7XG4gIGNvbnN0IGJsb2NrTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnROb2RlLCBub2RlID0+ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuICBpZiAoISRpc0VsZW1lbnROb2RlKGJsb2NrTm9kZSkpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIG5vZGUgJHtzdGFydE5vZGUuX19rZXl9IHRvIGhhdmUgY2xvc2VzdCBibG9jayBlbGVtZW50IG5vZGUuYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBibG9ja05vZGU7XG59XG4vKipcbiAqIFN0YXJ0cyB3aXRoIGEgbm9kZSBhbmQgbW92ZXMgdXAgdGhlIHRyZWUgKHRvd2FyZCB0aGUgcm9vdCBub2RlKSB0byBmaW5kIGEgbWF0Y2hpbmcgbm9kZSBiYXNlZCBvblxuICogdGhlIHNlYXJjaCBwYXJhbWV0ZXJzIG9mIHRoZSBmaW5kRm4uIChDb25zaWRlciBKYXZhU2NyaXB0cycgLmZpbmQoKSBmdW5jdGlvbiB3aGVyZSBhIHRlc3RpbmcgZnVuY3Rpb24gbXVzdCBiZVxuICogcGFzc2VkIGFzIGFuIGFyZ3VtZW50LiBlZy4gaWYoIChub2RlKSA9PiBub2RlLl9fdHlwZSA9PT0gJ2RpdicpICkgcmV0dXJuIHRydWU7IG90aGVyd2lzZSByZXR1cm4gZmFsc2VcbiAqIEBwYXJhbSBzdGFydGluZ05vZGUgLSBUaGUgbm9kZSB3aGVyZSB0aGUgc2VhcmNoIHN0YXJ0cy5cbiAqIEBwYXJhbSBmaW5kRm4gLSBBIHRlc3RpbmcgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgbm9kZSBzYXRpc2ZpZXMgdGhlIHRlc3RpbmcgcGFyYW1ldGVycy5cbiAqIEByZXR1cm5zIEEgcGFyZW50IG5vZGUgdGhhdCBtYXRjaGVzIHRoZSBmaW5kRm4gcGFyYW1ldGVycywgb3IgbnVsbCBpZiBvbmUgd2Fzbid0IGZvdW5kLlxuICovXG5jb25zdCAkZmluZE1hdGNoaW5nUGFyZW50ID0gKHN0YXJ0aW5nTm9kZSwgZmluZEZuKSA9PiB7XG4gIGxldCBjdXJyID0gc3RhcnRpbmdOb2RlO1xuICB3aGlsZSAoY3VyciAhPT0gJGdldFJvb3QoKSAmJiBjdXJyICE9IG51bGwpIHtcbiAgICBpZiAoZmluZEZuKGN1cnIpKSB7XG4gICAgICByZXR1cm4gY3VycjtcbiAgICB9XG4gICAgY3VyciA9IGN1cnIuZ2V0UGFyZW50KCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHJlc29sdmUgbmVzdGVkIGVsZW1lbnQgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZSBpbnRvIGEgc2luZ2xlIG5vZGUgb2YgdGhhdCB0eXBlLlxuICogSXQgaXMgZ2VuZXJhbGx5IHVzZWQgZm9yIG1hcmtzL2NvbW1lbnRpbmdcbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3JcbiAqIEBwYXJhbSB0YXJnZXROb2RlIC0gVGhlIHRhcmdldCBmb3IgdGhlIG5lc3RlZCBlbGVtZW50IHRvIGJlIGV4dHJhY3RlZCBmcm9tLlxuICogQHBhcmFtIGNsb25lTm9kZSAtIFNlZSB7QGxpbmsgJGNyZWF0ZU1hcmtOb2RlfVxuICogQHBhcmFtIGhhbmRsZU92ZXJsYXAgLSBIYW5kbGVzIGFueSBvdmVybGFwIGJldHdlZW4gdGhlIG5vZGUgdG8gZXh0cmFjdCBhbmQgdGhlIHRhcmdldE5vZGVcbiAqIEByZXR1cm5zIFRoZSBsZXhpY2FsIGVkaXRvclxuICovXG5mdW5jdGlvbiByZWdpc3Rlck5lc3RlZEVsZW1lbnRSZXNvbHZlcihlZGl0b3IsIHRhcmdldE5vZGUsIGNsb25lTm9kZSwgaGFuZGxlT3ZlcmxhcCkge1xuICBjb25zdCAkaXNUYXJnZXROb2RlID0gbm9kZSA9PiB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiB0YXJnZXROb2RlO1xuICB9O1xuICBjb25zdCAkZmluZE1hdGNoID0gbm9kZSA9PiB7XG4gICAgLy8gRmlyc3QgdmFsaWRhdGUgd2UgZG9uJ3QgaGF2ZSBhbnkgY2hpbGRyZW4gdGhhdCBhcmUgb2YgdGhlIHRhcmdldCxcbiAgICAvLyBhcyB3ZSBuZWVkIHRvIGhhbmRsZSB0aGVtIGZpcnN0LlxuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoJGlzVGFyZ2V0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBwYXJlbnROb2RlID0gbm9kZTtcbiAgICBsZXQgY2hpbGROb2RlID0gbm9kZTtcbiAgICB3aGlsZSAocGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2hpbGROb2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKCRpc1RhcmdldE5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGlsZDogY2hpbGROb2RlLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50Tm9kZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgY29uc3QgJGVsZW1lbnROb2RlVHJhbnNmb3JtID0gbm9kZSA9PiB7XG4gICAgY29uc3QgbWF0Y2ggPSAkZmluZE1hdGNoKG5vZGUpO1xuICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjaGlsZCxcbiAgICAgICAgcGFyZW50XG4gICAgICB9ID0gbWF0Y2g7XG5cbiAgICAgIC8vIFNpbXBsZSBwYXRoLCB3ZSBjYW4gbW92ZSBjaGlsZCBvdXQgYW5kIHNpYmxpbmdzIGludG8gYSBuZXcgcGFyZW50LlxuXG4gICAgICBpZiAoY2hpbGQuaXMobm9kZSkpIHtcbiAgICAgICAgaGFuZGxlT3ZlcmxhcChwYXJlbnQsIG5vZGUpO1xuICAgICAgICBjb25zdCBuZXh0U2libGluZ3MgPSBjaGlsZC5nZXROZXh0U2libGluZ3MoKTtcbiAgICAgICAgY29uc3QgbmV4dFNpYmxpbmdzTGVuZ3RoID0gbmV4dFNpYmxpbmdzLmxlbmd0aDtcbiAgICAgICAgcGFyZW50Lmluc2VydEFmdGVyKGNoaWxkKTtcbiAgICAgICAgaWYgKG5leHRTaWJsaW5nc0xlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGNvbnN0IG5ld1BhcmVudCA9IGNsb25lTm9kZShwYXJlbnQpO1xuICAgICAgICAgIGNoaWxkLmluc2VydEFmdGVyKG5ld1BhcmVudCk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U2libGluZ3NMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3UGFyZW50LmFwcGVuZChuZXh0U2libGluZ3NbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5jYW5CZUVtcHR5KCkgJiYgcGFyZW50LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybSh0YXJnZXROb2RlLCAkZWxlbWVudE5vZGVUcmFuc2Zvcm0pO1xufVxuXG4vKipcbiAqIENsb25lcyB0aGUgZWRpdG9yIGFuZCBtYXJrcyBpdCBhcyBkaXJ0eSB0byBiZSByZWNvbmNpbGVkLiBJZiB0aGVyZSB3YXMgYSBzZWxlY3Rpb24sXG4gKiBpdCB3b3VsZCBiZSBzZXQgYmFjayB0byBpdHMgcHJldmlvdXMgc3RhdGUsIG9yIG51bGwgb3RoZXJ3aXNlLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIGVkaXRvclN0YXRlIC0gVGhlIGVkaXRvcidzIHN0YXRlXG4gKi9cbmZ1bmN0aW9uICRyZXN0b3JlRWRpdG9yU3RhdGUoZWRpdG9yLCBlZGl0b3JTdGF0ZSkge1xuICBjb25zdCBGVUxMX1JFQ09OQ0lMRSA9IDI7XG4gIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGFjdGl2ZUVkaXRvclN0YXRlID0gZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGU7XG4gIGZvciAoY29uc3QgW2tleSwgbm9kZV0gb2YgZWRpdG9yU3RhdGUuX25vZGVNYXApIHtcbiAgICBub2RlTWFwLnNldChrZXksICRjbG9uZVdpdGhQcm9wZXJ0aWVzKG5vZGUpKTtcbiAgfVxuICBpZiAoYWN0aXZlRWRpdG9yU3RhdGUpIHtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZS5fbm9kZU1hcCA9IG5vZGVNYXA7XG4gIH1cbiAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBGVUxMX1JFQ09OQ0lMRTtcbiAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgJHNldFNlbGVjdGlvbihzZWxlY3Rpb24gPT09IG51bGwgPyBudWxsIDogc2VsZWN0aW9uLmNsb25lKCkpO1xufVxuXG4vKipcbiAqIElmIHRoZSBzZWxlY3RlZCBpbnNlcnRpb24gYXJlYSBpcyB0aGUgcm9vdC9zaGFkb3cgcm9vdCBub2RlIChzZWUge0BsaW5rIGxleGljYWwhJGlzUm9vdE9yU2hhZG93Um9vdH0pLFxuICogdGhlIG5vZGUgd2lsbCBiZSBhcHBlbmRlZCB0aGVyZSwgb3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGluc2VydGVkIGJlZm9yZSB0aGUgaW5zZXJ0aW9uIGFyZWEuXG4gKiBJZiB0aGVyZSBpcyBubyBzZWxlY3Rpb24gd2hlcmUgdGhlIG5vZGUgaXMgdG8gYmUgaW5zZXJ0ZWQsIGl0IHdpbGwgYmUgYXBwZW5kZWQgYWZ0ZXIgYW55IGN1cnJlbnQgbm9kZXNcbiAqIHdpdGhpbiB0aGUgdHJlZSwgYXMgYSBjaGlsZCBvZiB0aGUgcm9vdCBub2RlLiBBIHBhcmFncmFwaCB3aWxsIHRoZW4gYmUgYWRkZWQgYWZ0ZXIgdGhlIGluc2VydGVkIG5vZGUgYW5kIHNlbGVjdGVkLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBpbnNlcnRlZFxuICogQHJldHVybnMgVGhlIG5vZGUgYWZ0ZXIgaXRzIGluc2VydGlvblxuICovXG5mdW5jdGlvbiAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3Qobm9kZSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkgfHwgJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gIGxldCBpbml0aWFsQ2FyZXQ7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgaW5pdGlhbENhcmV0ID0gJGNhcmV0RnJvbVBvaW50KHNlbGVjdGlvbi5mb2N1cywgJ25leHQnKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc2VsZWN0aW9uICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgICBjb25zdCBsYXN0Tm9kZSA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlKSB7XG4gICAgICAgIGluaXRpYWxDYXJldCA9ICRnZXRTaWJsaW5nQ2FyZXQobGFzdE5vZGUsICduZXh0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIGluaXRpYWxDYXJldCA9IGluaXRpYWxDYXJldCB8fCAkZ2V0Q2hpbGRDYXJldCgkZ2V0Um9vdCgpLCAncHJldmlvdXMnKS5nZXRGbGlwcGVkKCkuaW5zZXJ0KCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICB9XG4gIGNvbnN0IGluc2VydENhcmV0ID0gJGluc2VydE5vZGVUb05lYXJlc3RSb290QXRDYXJldChub2RlLCBpbml0aWFsQ2FyZXQpO1xuICBjb25zdCBhZGphY2VudCA9ICRnZXRBZGphY2VudENoaWxkQ2FyZXQoaW5zZXJ0Q2FyZXQpO1xuICBjb25zdCBzZWxlY3Rpb25DYXJldCA9ICRpc0NoaWxkQ2FyZXQoYWRqYWNlbnQpID8gJG5vcm1hbGl6ZUNhcmV0KGFkamFjZW50KSA6IGluc2VydENhcmV0O1xuICAkc2V0U2VsZWN0aW9uRnJvbUNhcmV0UmFuZ2UoJGdldENvbGxhcHNlZENhcmV0UmFuZ2Uoc2VsZWN0aW9uQ2FyZXQpKTtcbiAgcmV0dXJuIG5vZGUuZ2V0TGF0ZXN0KCk7XG59XG5cbi8qKlxuICogSWYgdGhlIGluc2VydGlvbiBjYXJldCBpcyB0aGUgcm9vdC9zaGFkb3cgcm9vdCBub2RlIChzZWUge0BsaW5rIGxleGljYWwhJGlzUm9vdE9yU2hhZG93Um9vdH0pLFxuICogdGhlIG5vZGUgd2lsbCBiZSBpbnNlcnRlZCB0aGVyZSwgb3RoZXJ3aXNlIHRoZSBwYXJlbnQgbm9kZXMgd2lsbCBiZSBzcGxpdCBhY2NvcmRpbmcgdG8gdGhlXG4gKiBnaXZlbiBvcHRpb25zLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBpbnNlcnRlZFxuICogQHBhcmFtIGNhcmV0IC0gVGhlIGxvY2F0aW9uIHRvIGluc2VydCBvciBzcGxpdCBmcm9tXG4gKiBAcmV0dXJucyBUaGUgbm9kZSBhZnRlciBpdHMgaW5zZXJ0aW9uXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdEF0Q2FyZXQobm9kZSwgY2FyZXQsIG9wdGlvbnMpIHtcbiAgbGV0IGluc2VydENhcmV0ID0gJGdldENhcmV0SW5EaXJlY3Rpb24oY2FyZXQsICduZXh0Jyk7XG4gIGZvciAobGV0IG5leHRDYXJldCA9IGluc2VydENhcmV0OyBuZXh0Q2FyZXQ7IG5leHRDYXJldCA9ICRzcGxpdEF0UG9pbnRDYXJldE5leHQobmV4dENhcmV0LCBvcHRpb25zKSkge1xuICAgIGluc2VydENhcmV0ID0gbmV4dENhcmV0O1xuICB9XG4gIGlmICghISRpc1RleHRQb2ludENhcmV0KGluc2VydENhcmV0KSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGluc2VydE5vZGVUb05lYXJlc3RSb290QXRDYXJldDogQW4gdW5hdHRhY2hlZCBUZXh0Tm9kZSBjYW4gbm90IGJlIHNwbGl0YCk7XG4gIH1cbiAgaW5zZXJ0Q2FyZXQuaW5zZXJ0KG5vZGUuaXNJbmxpbmUoKSA/ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkuYXBwZW5kKG5vZGUpIDogbm9kZSk7XG4gIHJldHVybiAkZ2V0Q2FyZXRJbkRpcmVjdGlvbigkZ2V0U2libGluZ0NhcmV0KG5vZGUuZ2V0TGF0ZXN0KCksICduZXh0JyksIGNhcmV0LmRpcmVjdGlvbik7XG59XG5cbi8qKlxuICogV3JhcHMgdGhlIG5vZGUgaW50byBhbm90aGVyIG5vZGUgY3JlYXRlZCBmcm9tIGEgY3JlYXRlRWxlbWVudE5vZGUgZnVuY3Rpb24sIGVnLiAkY3JlYXRlUGFyYWdyYXBoTm9kZVxuICogQHBhcmFtIG5vZGUgLSBOb2RlIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudE5vZGUgLSBDcmVhdGVzIGEgbmV3IGxleGljYWwgZWxlbWVudCB0byB3cmFwIHRoZSB0by1iZS13cmFwcGVkIG5vZGUgYW5kIHJldHVybnMgaXQuXG4gKiBAcmV0dXJucyBBIG5ldyBsZXhpY2FsIGVsZW1lbnQgd2l0aCB0aGUgcHJldmlvdXMgbm9kZSBhcHBlbmRlZCB3aXRoaW4gKGFzIGEgY2hpbGQsIGluY2x1ZGluZyBpdHMgY2hpbGRyZW4pLlxuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVJbkVsZW1lbnQobm9kZSwgY3JlYXRlRWxlbWVudE5vZGUpIHtcbiAgY29uc3QgZWxlbWVudE5vZGUgPSBjcmVhdGVFbGVtZW50Tm9kZSgpO1xuICBub2RlLnJlcGxhY2UoZWxlbWVudE5vZGUpO1xuICBlbGVtZW50Tm9kZS5hcHBlbmQobm9kZSk7XG4gIHJldHVybiBlbGVtZW50Tm9kZTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuLyoqXG4gKiBAcGFyYW0gb2JqZWN0ID0gVGhlIGluc3RhbmNlIG9mIHRoZSB0eXBlXG4gKiBAcGFyYW0gb2JqZWN0Q2xhc3MgPSBUaGUgY2xhc3Mgb2YgdGhlIHR5cGVcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG9iamVjdCBpcyBoYXMgdGhlIHNhbWUgS2xhc3Mgb2YgdGhlIG9iamVjdENsYXNzLCBpZ25vcmluZyB0aGUgZGlmZmVyZW5jZSBhY3Jvc3Mgd2luZG93IChlLmcuIGRpZmZlcmVudCBpZnJhbXMpXG4gKi9cbmZ1bmN0aW9uIG9iamVjdEtsYXNzRXF1YWxzKG9iamVjdCwgb2JqZWN0Q2xhc3MpIHtcbiAgcmV0dXJuIG9iamVjdCAhPT0gbnVsbCA/IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpLmNvbnN0cnVjdG9yLm5hbWUgPT09IG9iamVjdENsYXNzLm5hbWUgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgdGhlIG5vZGVzXG4gKiBAcGFyYW0gbm9kZXMgQXJyYXkgb2Ygbm9kZXMgdGhhdCBuZWVkcyB0byBiZSBmaWx0ZXJlZFxuICogQHBhcmFtIGZpbHRlckZuIEEgZmlsdGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBub2RlIGlmIHRoZSBjdXJyZW50IG5vZGUgc2F0aXNmaWVzIHRoZSBjb25kaXRpb24gb3RoZXJ3aXNlIG51bGxcbiAqIEByZXR1cm5zIEFycmF5IG9mIGZpbHRlcmVkIG5vZGVzXG4gKi9cblxuZnVuY3Rpb24gJGZpbHRlcihub2RlcywgZmlsdGVyRm4pIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gZmlsdGVyRm4obm9kZXNbaV0pO1xuICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQXBwZW5kcyB0aGUgbm9kZSBiZWZvcmUgdGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBwYXJlbnQgbm9kZVxuICogQHBhcmFtIHBhcmVudCBBIHBhcmVudCBub2RlXG4gKiBAcGFyYW0gbm9kZSBOb2RlIHRoYXQgbmVlZHMgdG8gYmUgYXBwZW5kZWRcbiAqL1xuZnVuY3Rpb24gJGluc2VydEZpcnN0KHBhcmVudCwgbm9kZSkge1xuICAkZ2V0Q2hpbGRDYXJldChwYXJlbnQsICduZXh0JykuaW5zZXJ0KG5vZGUpO1xufVxubGV0IE5FRURTX01BTlVBTF9aT09NID0gSVNfRklSRUZPWCB8fCAhQ0FOX1VTRV9ET00gPyBmYWxzZSA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIG5lZWRzTWFudWFsWm9vbSgpIHtcbiAgaWYgKE5FRURTX01BTlVBTF9aT09NID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBJZiB0aGUgYnJvd3NlciBpbXBsZW1lbnRzIHN0YW5kYXJkaXplZCBDU1Mgem9vbSwgdGhlbiB0aGUgY2xpZW50IHJlY3RcbiAgICAvLyB3aWxsIGJlIHdpZGVyIGFmdGVyIHpvb20gaXMgYXBwbGllZFxuICAgIC8vIGh0dHBzOi8vY2hyb21lc3RhdHVzLmNvbS9mZWF0dXJlLzUxOTgyNTQ4Njg1MjkxNTJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svbGV4aWNhbC9pc3N1ZXMvNjg2M1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgb3BhY2l0eTogMDsgd2lkdGg6IDEwMHB4OyBsZWZ0OiAtMTAwMHB4Oyc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgIGNvbnN0IG5vWm9vbSA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBkaXYuc3R5bGUuc2V0UHJvcGVydHkoJ3pvb20nLCAnMicpO1xuICAgIE5FRURTX01BTlVBTF9aT09NID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoID09PSBub1pvb20ud2lkdGg7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICB9XG4gIHJldHVybiBORUVEU19NQU5VQUxfWk9PTTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB6b29tIGxldmVsIG9mIGFuIGVsZW1lbnQgYXMgYSByZXN1bHQgb2YgdXNpbmdcbiAqIGNzcyB6b29tIHByb3BlcnR5LiBGb3IgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnQgc3RhbmRhcmRpemVkIENTU1xuICogem9vbSAoRmlyZWZveCwgQ2hyb21lID49IDEyOCksIHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIDEuXG4gKiBAcGFyYW0gZWxlbWVudFxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVab29tTGV2ZWwoZWxlbWVudCkge1xuICBsZXQgem9vbSA9IDE7XG4gIGlmIChuZWVkc01hbnVhbFpvb20oKSkge1xuICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICB6b29tICo9IE51bWJlcih3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCd6b29tJykpO1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHpvb207XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBlZGl0b3IgaXMgYSBuZXN0ZWQgZWRpdG9yIGNyZWF0ZWQgYnkgTGV4aWNhbE5lc3RlZENvbXBvc2VyXG4gKi9cbmZ1bmN0aW9uICRpc0VkaXRvcklzTmVzdGVkRWRpdG9yKGVkaXRvcikge1xuICByZXR1cm4gZWRpdG9yLl9wYXJlbnRFZGl0b3IgIT09IG51bGw7XG59XG5cbi8qKlxuICogQSBkZXB0aCBmaXJzdCBsYXN0LXRvLWZpcnN0IHRyYXZlcnNhbCBvZiByb290IHRoYXQgc3RvcHMgYXQgZWFjaCBub2RlIHRoYXQgbWF0Y2hlc1xuICogJHByZWRpY2F0ZSBhbmQgZW5zdXJlcyB0aGF0IGl0cyBwYXJlbnQgaXMgcm9vdC4gVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCB0byBkaXNjYXJkXG4gKiBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIHdyYXBwaW5nIG5vZGVzLiBGb3IgZXhhbXBsZSwgYSBUYWJsZU5vZGUgbXVzdCBvbmx5IGhhdmVcbiAqIFRhYmxlUm93Tm9kZSBhcyBjaGlsZHJlbiwgYnV0IGFuIGltcG9ydGVyIG1pZ2h0IGFkZCBpbnZhbGlkIG5vZGVzIGJhc2VkIG9uXG4gKiBjYXB0aW9uLCB0Ym9keSwgdGhlYWQsIGV0Yy4gYW5kIHRoaXMgd2lsbCB1bndyYXAgYW5kIGRpc2NhcmQgdGhvc2UuXG4gKlxuICogQHBhcmFtIHJvb3QgVGhlIHJvb3QgdG8gc3RhcnQgdGhlIHRyYXZlcnNhbFxuICogQHBhcmFtICRwcmVkaWNhdGUgU2hvdWxkIHJldHVybiB0cnVlIGZvciBub2RlcyB0aGF0IGFyZSBwZXJtaXR0ZWQgdG8gYmUgY2hpbGRyZW4gb2Ygcm9vdFxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIHVud3JhcHBlZCBvciByZW1vdmVkIGFueSBub2Rlc1xuICovXG5mdW5jdGlvbiAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHMocm9vdCwgJHByZWRpY2F0ZSkge1xuICByZXR1cm4gJHVud3JhcEFuZEZpbHRlckRlc2NlbmRhbnRzSW1wbChyb290LCAkcHJlZGljYXRlLCBudWxsKTtcbn1cbmZ1bmN0aW9uICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50c0ltcGwocm9vdCwgJHByZWRpY2F0ZSwgJG9uU3VjY2Vzcykge1xuICBsZXQgZGlkTXV0YXRlID0gZmFsc2U7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiAkbGFzdFRvRmlyc3RJdGVyYXRvcihyb290KSkge1xuICAgIGlmICgkcHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICBpZiAoJG9uU3VjY2VzcyAhPT0gbnVsbCkge1xuICAgICAgICAkb25TdWNjZXNzKG5vZGUpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGRpZE11dGF0ZSA9IHRydWU7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHNJbXBsKG5vZGUsICRwcmVkaWNhdGUsICRvblN1Y2Nlc3MgfHwgKGNoaWxkID0+IG5vZGUuaW5zZXJ0QWZ0ZXIoY2hpbGQpKSk7XG4gICAgfVxuICAgIG5vZGUucmVtb3ZlKCk7XG4gIH1cbiAgcmV0dXJuIGRpZE11dGF0ZTtcbn1cblxuLyoqXG4gKiBBIGRlcHRoIGZpcnN0IHRyYXZlcnNhbCBvZiB0aGUgY2hpbGRyZW4gYXJyYXkgdGhhdCBzdG9wcyBhdCBhbmQgY29sbGVjdHNcbiAqIGVhY2ggbm9kZSB0aGF0IGAkcHJlZGljYXRlYCBtYXRjaGVzLiBUaGlzIGlzIHR5cGljYWxseSB1c2VkIHRvIGRpc2NhcmRcbiAqIGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgd3JhcHBpbmcgbm9kZXMgb24gYSBjaGlsZHJlbiBhcnJheSBpbiB0aGUgYGFmdGVyYFxuICogb2YgYW4ge0BsaW5rIGxleGljYWwhRE9NQ29udmVyc2lvbk91dHB1dH0uIEZvciBleGFtcGxlLCBhIFRhYmxlTm9kZSBtdXN0IG9ubHkgaGF2ZVxuICogVGFibGVSb3dOb2RlIGFzIGNoaWxkcmVuLCBidXQgYW4gaW1wb3J0ZXIgbWlnaHQgYWRkIGludmFsaWQgbm9kZXMgYmFzZWQgb25cbiAqIGNhcHRpb24sIHRib2R5LCB0aGVhZCwgZXRjLiBhbmQgdGhpcyB3aWxsIHVud3JhcCBhbmQgZGlzY2FyZCB0aG9zZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHJlYWQtb25seSBhbmQgcGVyZm9ybXMgbm8gbXV0YXRpb24gb3BlcmF0aW9ucywgd2hpY2ggbWFrZXNcbiAqIGl0IHN1aXRhYmxlIGZvciBpbXBvcnQgYW5kIGV4cG9ydCBwdXJwb3NlcyBidXQgbGlrZWx5IG5vdCBmb3IgYW55IGluLXBsYWNlXG4gKiBtdXRhdGlvbi4gWW91IHNob3VsZCB1c2Uge0BsaW5rICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50c30gZm9yIGluLXBsYWNlXG4gKiBtdXRhdGlvbnMgc3VjaCBhcyBub2RlIHRyYW5zZm9ybXMuXG4gKlxuICogQHBhcmFtIGNoaWxkcmVuIFRoZSBjaGlsZHJlbiB0byB0cmF2ZXJzZVxuICogQHBhcmFtICRwcmVkaWNhdGUgU2hvdWxkIHJldHVybiB0cnVlIGZvciBub2RlcyB0aGF0IGFyZSBwZXJtaXR0ZWQgdG8gYmUgY2hpbGRyZW4gb2Ygcm9vdFxuICogQHJldHVybnMgVGhlIGNoaWxkcmVuIG9yIHRoZWlyIGRlc2NlbmRhbnRzIHRoYXQgbWF0Y2ggJHByZWRpY2F0ZVxuICovXG5cbmZ1bmN0aW9uICRkZXNjZW5kYW50c01hdGNoaW5nKGNoaWxkcmVuLCAkcHJlZGljYXRlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzdGFjayA9IEFycmF5LmZyb20oY2hpbGRyZW4pLnJldmVyc2UoKTtcbiAgZm9yIChsZXQgY2hpbGQgPSBzdGFjay5wb3AoKTsgY2hpbGQgIT09IHVuZGVmaW5lZDsgY2hpbGQgPSBzdGFjay5wb3AoKSkge1xuICAgIGlmICgkcHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgIH0gZWxzZSBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyYW5kY2hpbGQgb2YgJGxhc3RUb0ZpcnN0SXRlcmF0b3IoY2hpbGQpKSB7XG4gICAgICAgIHN0YWNrLnB1c2goZ3JhbmRjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGl0ZXJhdG9yIHRoYXQgeWllbGRzIGVhY2ggY2hpbGQgb2Ygbm9kZSBmcm9tIGZpcnN0IHRvIGxhc3QsIHRha2luZ1xuICogY2FyZSB0byBwcmVzZXJ2ZSB0aGUgbmV4dCBzaWJsaW5nIGJlZm9yZSB5aWVsZGluZyB0aGUgdmFsdWUgaW4gY2FzZSB0aGUgY2FsbGVyXG4gKiByZW1vdmVzIHRoZSB5aWVsZGVkIG5vZGUuXG4gKlxuICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgd2hvc2UgY2hpbGRyZW4gdG8gaXRlcmF0ZVxuICogQHJldHVybnMgQW4gaXRlcmF0b3Igb2YgdGhlIG5vZGUncyBjaGlsZHJlblxuICovXG5mdW5jdGlvbiAkZmlyc3RUb0xhc3RJdGVyYXRvcihub2RlKSB7XG4gIHJldHVybiAkY2hpbGRJdGVyYXRvcigkZ2V0Q2hpbGRDYXJldChub2RlLCAnbmV4dCcpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gaXRlcmF0b3IgdGhhdCB5aWVsZHMgZWFjaCBjaGlsZCBvZiBub2RlIGZyb20gbGFzdCB0byBmaXJzdCwgdGFraW5nXG4gKiBjYXJlIHRvIHByZXNlcnZlIHRoZSBwcmV2aW91cyBzaWJsaW5nIGJlZm9yZSB5aWVsZGluZyB0aGUgdmFsdWUgaW4gY2FzZSB0aGUgY2FsbGVyXG4gKiByZW1vdmVzIHRoZSB5aWVsZGVkIG5vZGUuXG4gKlxuICogQHBhcmFtIG5vZGUgVGhlIG5vZGUgd2hvc2UgY2hpbGRyZW4gdG8gaXRlcmF0ZVxuICogQHJldHVybnMgQW4gaXRlcmF0b3Igb2YgdGhlIG5vZGUncyBjaGlsZHJlblxuICovXG5mdW5jdGlvbiAkbGFzdFRvRmlyc3RJdGVyYXRvcihub2RlKSB7XG4gIHJldHVybiAkY2hpbGRJdGVyYXRvcigkZ2V0Q2hpbGRDYXJldChub2RlLCAncHJldmlvdXMnKSk7XG59XG5mdW5jdGlvbiAkY2hpbGRJdGVyYXRvcihzdGFydENhcmV0KSB7XG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCkgO1xuICByZXR1cm4gbWFrZVN0ZXB3aXNlSXRlcmF0b3Ioe1xuICAgIGhhc05leHQ6ICRpc1NpYmxpbmdDYXJldCxcbiAgICBpbml0aWFsOiBzdGFydENhcmV0LmdldEFkamFjZW50Q2FyZXQoKSxcbiAgICBtYXA6IGNhcmV0ID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbiA9IGNhcmV0Lm9yaWdpbi5nZXRMYXRlc3QoKTtcbiAgICAgIGlmIChzZWVuICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG9yaWdpbi5nZXRLZXkoKTtcbiAgICAgICAgaWYgKCEhc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGNoaWxkSXRlcmF0b3I6IEN5Y2xlIGRldGVjdGVkLCBub2RlIHdpdGgga2V5ICR7U3RyaW5nKGtleSl9IGhhcyBhbHJlYWR5IGJlZW4gdHJhdmVyc2VkYCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfSxcbiAgICBzdGVwOiBjYXJldCA9PiBjYXJldC5nZXRBZGphY2VudENhcmV0KClcbiAgfSk7XG59XG5cbi8qKlxuICogUmVwbGFjZSB0aGlzIG5vZGUgd2l0aCBpdHMgY2hpbGRyZW5cbiAqXG4gKiBAcGFyYW0gbm9kZSBUaGUgRWxlbWVudE5vZGUgdG8gdW53cmFwIGFuZCByZW1vdmVcbiAqL1xuZnVuY3Rpb24gJHVud3JhcE5vZGUobm9kZSkge1xuICAkcmV3aW5kU2libGluZ0NhcmV0KCRnZXRTaWJsaW5nQ2FyZXQobm9kZSwgJ25leHQnKSkuc3BsaWNlKDEsIG5vZGUuZ2V0Q2hpbGRyZW4oKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgTm9kZSBzaWJsaW5nIHdoZW4gdGhpcyBleGlzdHMsIG90aGVyd2lzZSB0aGUgY2xvc2VzdCBwYXJlbnQgc2libGluZy4gRm9yIGV4YW1wbGVcbiAqIFIgLT4gUCAtPiBUMSwgVDJcbiAqICAgLT4gUDJcbiAqIHJldHVybnMgVDIgZm9yIG5vZGUgVDEsIFAyIGZvciBub2RlIFQyLCBhbmQgbnVsbCBmb3Igbm9kZSBQMi5cbiAqIEBwYXJhbSBub2RlIExleGljYWxOb2RlLlxuICogQHJldHVybnMgQW4gYXJyYXkgKHR1cGxlKSBjb250YWluaW5nIHRoZSBmb3VuZCBMZXhpY2FsIG5vZGUgYW5kIHRoZSBkZXB0aCBkaWZmZXJlbmNlLCBvciBudWxsLCBpZiB0aGlzIG5vZGUgZG9lc24ndCBleGlzdC5cbiAqL1xuZnVuY3Rpb24gJGdldEFkamFjZW50U2libGluZ09yUGFyZW50U2libGluZ0NhcmV0KHN0YXJ0Q2FyZXQsIHJvb3RNb2RlID0gJ3Jvb3QnKSB7XG4gIGxldCBkZXB0aERpZmYgPSAwO1xuICBsZXQgY2FyZXQgPSBzdGFydENhcmV0O1xuICBsZXQgbmV4dENhcmV0ID0gJGdldEFkamFjZW50Q2hpbGRDYXJldChjYXJldCk7XG4gIHdoaWxlIChuZXh0Q2FyZXQgPT09IG51bGwpIHtcbiAgICBkZXB0aERpZmYtLTtcbiAgICBuZXh0Q2FyZXQgPSBjYXJldC5nZXRQYXJlbnRDYXJldChyb290TW9kZSk7XG4gICAgaWYgKCFuZXh0Q2FyZXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjYXJldCA9IG5leHRDYXJldDtcbiAgICBuZXh0Q2FyZXQgPSAkZ2V0QWRqYWNlbnRDaGlsZENhcmV0KGNhcmV0KTtcbiAgfVxuICByZXR1cm4gbmV4dENhcmV0ICYmIFtuZXh0Q2FyZXQsIGRlcHRoRGlmZl07XG59XG5cbi8qKlxuICogQSB3cmFwcGVyIHRoYXQgY3JlYXRlcyBib3VuZCBmdW5jdGlvbnMgYW5kIG1ldGhvZHMgZm9yIHRoZVxuICogU3RhdGVDb25maWcgdG8gc2F2ZSBzb21lIGJvaWxlcnBsYXRlIHdoZW4gZGVmaW5pbmcgbWV0aG9kc1xuICogb3IgZXhwb3J0aW5nIG9ubHkgdGhlIGFjY2Vzc29ycyBmcm9tIHlvdXIgbW9kdWxlcyByYXRoZXJcbiAqIHRoYW4gZXhwb3NpbmcgdGhlIFN0YXRlQ29uZmlnIGRpcmVjdGx5LlxuICovXG5cbi8qKlxuICogRVhQRVJJTUVOVEFMXG4gKlxuICogQSBjb252ZW5pZW5jZSBpbnRlcmZhY2UgZm9yIHdvcmtpbmcgd2l0aCB7QGxpbmsgJGdldFN0YXRlfSBhbmRcbiAqIHtAbGluayAkc2V0U3RhdGV9LlxuICpcbiAqIEBwYXJhbSBzdGF0ZUNvbmZpZyBUaGUgc3RhdGVDb25maWcgdG8gd3JhcCB3aXRoIGNvbnZlbmllbmNlIGZ1bmN0aW9uYWxpdHlcbiAqIEByZXR1cm5zIGEgU3RhdGVXcmFwcGVyXG4gKi9cbmZ1bmN0aW9uIG1ha2VTdGF0ZVdyYXBwZXIoc3RhdGVDb25maWcpIHtcbiAgY29uc3QgJGdldCA9IG5vZGUgPT4gJGdldFN0YXRlKG5vZGUsIHN0YXRlQ29uZmlnKTtcbiAgY29uc3QgJHNldCA9IChub2RlLCB2YWx1ZU9yVXBkYXRlcikgPT4gJHNldFN0YXRlKG5vZGUsIHN0YXRlQ29uZmlnLCB2YWx1ZU9yVXBkYXRlcik7XG4gIHJldHVybiB7XG4gICAgJGdldCxcbiAgICAkc2V0LFxuICAgIGFjY2Vzc29yczogWyRnZXQsICRzZXRdLFxuICAgIG1ha2VHZXR0ZXJNZXRob2Q6ICgpID0+IGZ1bmN0aW9uICRnZXR0ZXIoKSB7XG4gICAgICByZXR1cm4gJGdldCh0aGlzKTtcbiAgICB9LFxuICAgIG1ha2VTZXR0ZXJNZXRob2Q6ICgpID0+IGZ1bmN0aW9uICRzZXR0ZXIodmFsdWVPclVwZGF0ZXIpIHtcbiAgICAgIHJldHVybiAkc2V0KHRoaXMsIHZhbHVlT3JVcGRhdGVyKTtcbiAgICB9LFxuICAgIHN0YXRlQ29uZmlnXG4gIH07XG59XG5cbmV4cG9ydCB7ICRkZXNjZW5kYW50c01hdGNoaW5nLCAkZGZzLCAkZGZzSXRlcmF0b3IsICRmaWx0ZXIsICRmaW5kTWF0Y2hpbmdQYXJlbnQsICRmaXJzdFRvTGFzdEl0ZXJhdG9yLCAkZ2V0QWRqYWNlbnRDYXJldCwgJGdldEFkamFjZW50U2libGluZ09yUGFyZW50U2libGluZ0NhcmV0LCAkZ2V0RGVwdGgsICRnZXROZWFyZXN0QmxvY2tFbGVtZW50QW5jZXN0b3JPclRocm93LCAkZ2V0TmVhcmVzdE5vZGVPZlR5cGUsICRnZXROZXh0UmlnaHRQcmVvcmRlck5vZGUsICRnZXROZXh0U2libGluZ09yUGFyZW50U2libGluZywgJGluc2VydEZpcnN0LCAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3QsICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdEF0Q2FyZXQsICRpc0VkaXRvcklzTmVzdGVkRWRpdG9yLCAkbGFzdFRvRmlyc3RJdGVyYXRvciwgJHJlc3RvcmVFZGl0b3JTdGF0ZSwgJHJldmVyc2VEZnMsICRyZXZlcnNlRGZzSXRlcmF0b3IsICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50cywgJHVud3JhcE5vZGUsICR3cmFwTm9kZUluRWxlbWVudCwgQ0FOX1VTRV9CRUZPUkVfSU5QVVQsIENBTl9VU0VfRE9NLCBJU19BTkRST0lELCBJU19BTkRST0lEX0NIUk9NRSwgSVNfQVBQTEUsIElTX0FQUExFX1dFQktJVCwgSVNfQ0hST01FLCBJU19GSVJFRk9YLCBJU19JT1MsIElTX1NBRkFSSSwgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCwgY2FsY3VsYXRlWm9vbUxldmVsLCBpc01pbWVUeXBlLCBtYWtlU3RhdGVXcmFwcGVyLCBtYXJrU2VsZWN0aW9uLCBtZWRpYUZpbGVSZWFkZXIsIG1lcmdlUmVnaXN0ZXIsIG9iamVjdEtsYXNzRXF1YWxzLCBtbGNQb3NpdGlvbk5vZGVPblJhbmdlIGFzIHBvc2l0aW9uTm9kZU9uUmFuZ2UsIHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyLCByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQsIHNlbGVjdGlvbkFsd2F5c09uRGlzcGxheSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lexical+utils@0.28.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\n");

/***/ })

};
;